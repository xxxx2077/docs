# 区块链

![image-20231231153919799](blockChain.assets/image-20231231153919799.png)

## 区块链类型

- 公有链
- 联盟链
- 私有链

![image-20231231191414112](blockChain.assets/image-20231231191414112.png)

**应用**

![image-20240101173102140](blockChain.assets/image-20240101173102140.png)

## 信息传递网络（TCP/IP）与价值传递网络（区块链）

**信息传递网络（TCP/IP）与价值传递网络（区块链）的区别与联系是什么？**

**区别：**

|          |     TCP/IP     |       区块链       |
| :------: | :------------: | :----------------: |
|   功能   | 传输、复制信息 |   传递、交换价值   |
|   特点   |   无成本复制   | 只能转移，不能复制 |
| 数据传输 |     中心化     |      去中心化      |

**联系：**

- 二者都是加密的网络技术
- 信息传递网络是价值传递网络的基础
- 信息传递网络与价值传递网络是相辅相成的

## 比特币（btc）

比特币是一种去中心化支付系统

比特币是区块链技术的首次应用

比特币的核心问题：

1. 如何发行比特币
2. 如何验证交易的有效性

### 比特币的密码学基础

#### 哈希函数

定义： Hash函数是将任意长度的消息映射成一个较短的**定长**输出消息的函数。

如下形式: h = H(M), M是变长的消息, h是定长的Hash值.

Hash算法具有以下特点：

- 正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值
- 输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同
- 逆向困难：给定特定hash 值，在有限时间内很难（基本不可能）逆推出明文
- 冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）

**时间复杂度：O(n)** 

**应用：**SHA2 系列生成的 hash 值更长， SHA256， SHA512......**数值代表hash长度**  

#### 密码学特性

1. 碰撞阻力(Collision-Resistance)  

   - 首先介绍哈希碰撞：找到两个数x 与 y, x!=y,而x和y满足H(x) = H(y)，那么我们称其为哈希碰撞
   - 如果“无法找到”两个值x 与 y, x!=y,而 H(x) = H(y)，那么，称哈希函数 H 具有碰撞阻力  
     - 这里的“无法找到”并不是理论上的“无法找到”，由于哈希函数输入空间可以为无限大，输出空间是有限的，例如SHA256输出空间为$2^{256}$，理论上只要输入空间足够大，那么就可以找到满足哈希碰撞的两个数x和y
     - 但实际中，在人类所能接受的时间开销或其他穷举开销内，我们很难找到满足哈希碰撞的两个数，因此我们称其为碰撞阻力Collision-Resistance
   - 应用：
     - 根据碰撞阻力(Collision-Resistance)  ，我们可以使用哈希函数判断文件是否被篡改（原文件生成一个哈希值，判断文件是否被篡改时再生成一个哈希值，如果哈希值相同，我们认为文件没有被篡改）

2. 隐秘性 (hiding)  / 不可逆性  

   > Definition: A hash function H is hiding if: when a secret value x is chosen from a probability distribution that has high min-entropy, then given H( x) it is infeasible to find x
   >
   > 隐秘性： 哈希函数H具有隐秘性，如果：当其输入 x 选自一个符合高阶最小熵（high min-entroy）的概率分布，在给定 H（ x）时，来确定x是不可行的  
   >
   > 高阶最小熵的意思就是：输入x足够混乱，即分布足够均匀

   - 哈希函数的计算过程是单向的/不可逆的，即给定H(x)，我们“无法知道”x的信息

   - **隐秘性 (hiding)  / 不可逆性  需要满足以下要求：**

     1. 输入空间足够大
     2. 输入空间分布均匀

   - 这里的“无法找到”并不是理论上的“无法找到”，与碰撞阻力(Collision-Resistance)  一样，理论上可行，但实践中，在人类所能接受的时间开销或其他穷举开销内，很难找到根据H(x)找到x

   - 应用：

     - 预测股市时：为了避免我们预测的结果影响股市的走向，利用知道H(x)无法得到x信息的hiding特性，我们只需要给定哈希值H(x)做出承诺，在股市开盘后，大家就很容易根据股市情况x得到哈希值H'(x)验证我们的预测是否成功(if H'(x)=H(x)?)

       ![image-20231231160912194](blockChain.assets/image-20231231160912194.png)

3. 谜题友好 (puzzle-friendliness)  

   > Definition: Puzzle friendliness. A hash function H is said to bepuzzle-friendly if for every possible n-bit output value y, if x is chosen from a distribution with high min-entropy, then it is infeasible to find x such that H(x) = y in time significantly less than 2^n
   >
   > 谜题友好. 如果对于任意 n 位输出值 y， 假定x选自高阶最小熵分布，如果无法找到一个可行的方法，在比 2^n小很多的时间内找到 x，保证 H(x ) = y 成立，那么我们称 哈希函数H 为 谜题友好  

   简单来说：就是如果给出一个谜题，该题目约束了哈希值满足的范围（例如哈希值必须前k位为0），那么除了穷举所有的x外，几乎没有别的方法比穷举更快找到一个x满足这个约束条件。

   - **挖矿很难，验证却很容易**

   - 应用：比特币挖矿就是给定一个谜题，使得得到的Hash值满足约束条件（H ( header || TXs || nonce ) < target）

     Mining 对每一个 miner 都是公平的：大家都不停地寻找一个合格的解 x —— nonce!，使得H ( header || TXs || nonce ) < target

#### 签名

比特币没有账户，但是用户有“钱包”

用户自己（在比特币App里）开设“钱包” ，通过使用一对独特的 公私钥对<public key, secret key>

 <pk, sk> 来源于 非对称加密

##### 对称加密

加密和解密用的是同一对密钥

对称加密算法假设的前提是传递密钥的网络是安全的

##### 非对称加密

实际中传递密钥的网络并不安全，因此我们提出非对称加密

加密和解密用的是不同密钥

假设发送者A要给接收者B发送一条消息M

1. 发送者A使用**接收者B的公钥pk**给M加密，得到M’
2. 接收者B得到M‘后，使用**接收者B的私钥sk**对M’进行解密

**如何理解公钥和私钥？**

- **公钥相当于银行账户**，别人只要知道银行账户就能给我们转账（对应于比特币，别人只要知道我们的公钥就能给我们发送信息）
- **私钥相当于账户密码**，我们知道密码就能获取别人给我们账户转的钱（对应于比特币，我们知道私钥就能获取别人给我们公钥发的信息）

##### 签名

当发生一笔交易时，转账者需要证明自己的身份：确实是本人发起的交易，而不是被冒名顶替

因此需要对这笔交易做签名

**签名的方法：转账者用转账者的私钥对这笔交易签名，其他人用转账者的公钥验证签名的正确性**

要求两个性质有效：

1. 有效的签名可以通过验证：verify(pk, message, sign(sk, message)) == true
2. **签名不可伪造**

实践中

- 比特币使用的签名算法是随机的，**需要良好随机源**——为了使大家的公私钥都不同
- 对要签名的信息 message 大小有限，所以使用 HashFunction，因为哈希函数的输出是定长的

**数字签名方案**

由三个算法构成

1. 生成公私钥： (sk, pk) := generateKeys (keysize)

   - 把 keysize 作为输入，来产生一对公钥和私钥
   - 私钥 sk 被安全保存，并用来签名一段消息；
   - 公钥 pk 是人人都可以找到的，拿到它用来验证你的签名。

2. 签名过程：sig := sign(sk, msg)

   - 把一段消息message 和私钥 sk 作为输入，输出是 签名sig

3. 验证过程：isValid := verify(pk, message, sig)

   - 通过把一段消息和签名消息与公钥作为输入，

   - 如果返回是真，证明签名属实；否则， 证明签名的消息为假

**为什么说“公钥即身份”？**

-  Bitcoin 用户自己开账户 —— <pk, sk>
- 其他用户看到一个签名，并能用一个 pk 验证这个签名： pk 就可以代表一个人的身份
  - 签名对应了某个人，而只有这个人的公钥才能验证这个签名，因此这个公钥就能代表这个人
-  比特币中用户的身份： 地址 := Hash (pk || x)

所以，比特币可以提供去中心化身份管理

- 随时定制新的随机身份
  - new <pk, sk> = generateKeys (keysize)
- 具有匿名性：一个人可以有多个 <pk, sk>，随便使用哪一个身份转账

> In fact, not strictly anonymous, some techniques, e.g., patternanalysis, can still find who is the sender of a transaction.

#### 私钥、公钥、钱包地址

**私钥、公钥、钱包地址生成**

![image-20231231194535547](blockChain.assets/image-20231231194535547.png)

**私钥、公钥和钱包地址之间的关系**

![image-20231231194612843](blockChain.assets/image-20231231194612843.png)

### 比特币的数据结构

区块链是特殊的链表，使用哈希指针代替传统指针将各个区块连接在一起

- version：区块链版本
- hash of previous block header：哈希指针
- Merkle root hash：对应Merkle Tree根节点的Hash
- target：挖矿的目标，Hash（Header) <  target
- nonce：随机数，保证谜题友好性

![image-20231231183922785](blockChain.assets/image-20231231183922785.png)

#### 哈希指针(Hash pointer) 

hash pointer := H(block header)

”牵一发而动全身“：只要改变区块链中的一个区块，该区块后面的所有哈希指针都需要发生变化。因此我们只需要保存最近的区块即可

如果需要之前的区块，只需要找别人（全节点）要

确认别人给的区块是否正确也很简单，只需要计算该区块的Hash与我想要的区块的Hash是否相同即可

#### Merkle Tree

使用哈希指针的二叉树

Merkle Tree分为Merkle Header和Merkle Body

- **具体交易信息记录在Merkle Body而不在Merkle Header**

如下图（TX表示transaction）

![image-20231231194207730](blockChain.assets/image-20231231194207730.png)

![image-20231231184540975](blockChain.assets/image-20231231184540975.png)

![image-20231231184447110](blockChain.assets/image-20231231184447110.png)

只要检测根节点的Hash值，就可以检测出Merkle Tree任何节点的修改

![image-20231231184732260](blockChain.assets/image-20231231184732260.png)

#### 全节点和轻节点

![image-20240101105624118](blockChain.assets/image-20240101105624118.png)

![image-20240101105630645](blockChain.assets/image-20240101105630645.png)

轻节点只存储每个区块的header，全节点既存储header又存储body

#### 如何验证交易存在  

注意轻节点只存储Merkle header，并不知道交易的具体信息

如果要求轻节点验证交易存在，我们需要使用一种叫做Merkle Proof的验证方法

##### Merkle Proof

如下图

![image-20231231185415041](blockChain.assets/image-20231231185415041.png)

如果想证明黄色节点对应的交易TX存在，轻节点已知Merkle Root的Hash值H(Merkle Root)和TX的Hash值，其余节点的Hash值都不知道

1. 轻节点（SPV）向某个全节点请求能够证明黄色节点的Merkle Proof
2. 全节点向轻节点回应Merkle Proof需要的Hash值（红色部分）
3. 轻节点根据全节点给出的Hash值和TX的Hash值，在本地计算Hash值，最终得到Merkle Root的Hash值H'(Merkle Root)
4. 将H'(Merkle Root)和H(Merkle Root)比较，如果相同，则证明该交易TX存在该Merkle Tree；否则不存在

在这个证明过程中，轻节点不需要知道其他节点的信息，只需要知道局部的Hash值

**碰撞阻力保证了全节点给出的Hash值不会被冒充**

验证Merkle Proof的时间复杂度为O(log(n))

#### 如何验证交易不存在

假设我们现在要验证$TX_n$不存在Merkle Tree中

1. 对TX节点按Hash值排序

2. 假设$TX_n$存在，那么我们可以找到$TX_n$相邻的两个TX节点$TX_{n-1}$和$TX_{n+1}$（在图中$TX_{n-1}$和$TX_{n+1}$分别对应$TX_{4}$和$TX_{5}$）

   但我们要验证$TX_n$不存在，因此**满足$TX_n$不存在的条件是，计算$TX_{n-1}$和$TX_{n+1}$的Merkle Proof得到H'(Merkle Root)，和当前区块H(Merkle Root)比较，如果相同，则表明交易$TX_n$不存在（因为相同，表明；否则存在**

3. 轻节点计算$TX_{n-1}$和$TX_{n+1}$的Merkle Proof得到Merkle Root的Hash值，将H'(Merkle Root)和当前区块H(Merkle Root)比较，如果相同，则表明交易$TX_n$不存在；否则存在

####   ![image-20231231190553373](blockChain.assets/image-20231231190553373.png)

**比特币不要求验证交易不存在**

### UTXO模型

#### 前引

如何确认一笔交易的有效性：

- 所有权确认（签名）
- 具有可动用的资金
- 其他交易不会用到同一笔资金

以上条件对应比特币情景中为：

假设转账者A要给接收者B转账，我们需要知道：

1. 接收者B的钱包地址（公钥生成）
2. 转账者A的公钥
   - 以便验证A的签名，即证明这笔钱确实由A发起，而不是其他人冒名顶替
   - 还要避免一种情况：冒名者C谎称将自己的公钥谎称是A的公钥，并给出自己私钥对应的签名，这种情况下，我们需要将转账者A的公钥得到的钱包地址和币的来源指针指向的交易的钱包地址比较，如果相同，则验证转账者A身份正确，否则就是冒充。
3. 转账者A币的来源（区块链的第二个哈希指针，第一个指针是用于连接各个区块的哈希指针）

#### UTXO

**U**nspent **T**ran**s**action **O**utput（UTXO）：未花费的交易输出

- 一个交易可能有多个输出，同一个交易中已花费的交易输出不在UTXO中
- 一个交易可能有多个输入，每个输入都需要提供签名

![image-20240101102347328](blockChain.assets/image-20240101102347328.png)



**UTXO输入**

![image-20240101103943200](blockChain.assets/image-20240101103943200.png)

**UTXO输出**

![image-20240101104001003](blockChain.assets/image-20240101104001003.png)

### 挖矿

#### 挖矿激励

1. 出块奖励
2. 交易费：让记账者把交易打包到区块中，需要支付记账者一定的交易费（当出块奖励为0之后，交易费就是主要的激励）

#### 挖矿难度

**挖矿难度定义**

![image-20240101104346795](blockChain.assets/image-20240101104346795.png)

**挖矿难度调整策略**  

解释以下：

- **`actual time`（实际时间）：** 是指过去一定数量的区块的实际产生时间的平均值。通过观察先前的区块产生时间，可以得出实际的区块产生速度。如果实际时间低于预期时间，说明挖矿速度过快；如果实际时间高于预期时间，说明挖矿速度过慢。
- **`expected time`（预期时间）：** 是系统设计或协议规定的理想的区块产生时间。在比特币中，预期的区块产生时间是大约10分钟。这个时间是由协议规定的，目的是确保新区块的产生速度适中，保持系统的稳定性。

![image-20240101104557543](blockChain.assets/image-20240101104557543.png)

![image-20240101104614058](blockChain.assets/image-20240101104614058.png)

![image-20240101105600632](blockChain.assets/image-20240101105600632.png)

除了更改nonce，还可以调整铸币交易的coinbase从而更改区块的merkle hash

#### 挖矿的策略 

#### ![image-20240101172554268](blockChain.assets/image-20240101172554268.png) 

![image-20240101172603843](blockChain.assets/image-20240101172603843.png)

![image-20240101172834786](blockChain.assets/image-20240101172834786.png)

1. **网络延迟：** 挖矿矿工在成功找到新区块时，需要将其广播到整个比特币网络。由于网络延迟，有时候矿工可能会为了更快地提交一个新块而选择不等待待处理的交易确认，从而挖掘一个挖空块。
2. **比特币协议设计：** 比特币协议本身并没有强制要求每个新区块都必须包含交易信息。区块的主要目的是确保交易的安全和不可篡改性，而挖矿矿工选择是否要在新区块中包含交易。
3. **提高区块产生速度：** 挖空块能够更快地添加到区块链中，因为不需要等待交易的确认。这可能被一些矿工用作一种方式来提高他们的区块产生速度。然而，这也可能引发一些争议，因为挖空块有时可能被视为不积极地贡献到整个比特币网络的交易确认过程中。

需要注意的是，挖空块不符合比特币的初衷，即通过挖矿来确认交易并维护整个网络的去中心化和安全性。因此，大多数矿工会选择包含交易信息的区块。挖空块通常只是在特定情况下，出于某种原因，为了更快地提交新区块而采取的一种临时性措施。

![image-20240101172721795](blockChain.assets/image-20240101172721795.png)

#### Q&A

**Q：比特币系统是分布式的，如何让所有节点同时调整目标阈值？** 

A：比特币系统的代码写好了，每当**2016**个区块后，自动调整。  

**Q：如果在挖矿过程中，全节点监听到了其他矿工挖出新区块，应该怎么办？**

重新组织新区块进行挖矿  

- 为什么不能沿用之前组装的区块继续进行挖矿？
  - 交易有可能被包含到新区块链里
  - Hash指针发生变化

### 脚本

![image-20240101113029342](blockChain.assets/image-20240101113029342.png)

![image-20240101113229120](blockChain.assets/image-20240101113229120.png)

![image-20240101113241706](blockChain.assets/image-20240101113241706.png)

![image-20240101114333114](blockChain.assets/image-20240101114333114.png)

#### 输入/输出脚本的几种形式

##### Pay to Public Key (P2PK)  

最简单的脚本

- 输入脚本直接给出签名
- 输出脚本直接给出公钥

![image-20240101114558510](blockChain.assets/image-20240101114558510.png)

脚本执行

![image-20240101114709930](blockChain.assets/image-20240101114709930.png)

![image-20240101114719792](blockChain.assets/image-20240101114719792.png)

将Sig和Pubkey弹出栈，检验是否匹配，如果匹配返回True入栈，否则False入栈

![image-20240101114728515](blockChain.assets/image-20240101114728515.png)



##### Pay to Public Key Hash (P2PKH)  

和P2PK的区别：

- 输出脚本不再直接给出公钥，而是给出公钥的哈希，对应名字Public Key Hash
- 输入脚本除了给出签名，还要给出公钥
- 其他操作为了验证

![image-20240101114924357](blockChain.assets/image-20240101114924357.png)

执行过程

![image-20240101115039331](blockChain.assets/image-20240101115039331.png)

![image-20240101115047331](blockChain.assets/image-20240101115047331.png)

![image-20240101115106003](blockChain.assets/image-20240101115106003.png)

![image-20240101115145134](blockChain.assets/image-20240101115145134.png)

![image-20240101115208838](blockChain.assets/image-20240101115208838.png)

![](blockChain.assets/image-20240101115428545.png)

如果以上任一环节发生错误，则该交易非法

##### Pay to Script Hash (P2SH)  

> 该机制为了支持多重签名

![image-20240101115835246](blockChain.assets/image-20240101115835246.png)

![image-20240101115919000](blockChain.assets/image-20240101115919000.png)

执行过程：

![image-20240101115956249](blockChain.assets/image-20240101115956249.png)

**第一阶段**

这一阶段验证redeem Script的Hash值和output Script中给定的redeem Script Hash值匹配

![image-20240101120103884](blockChain.assets/image-20240101120103884.png)

![image-20240101120112538](blockChain.assets/image-20240101120112538.png)

![image-20240101120136580](blockChain.assets/image-20240101120136580.png)

##### ![image-20240101120146491](blockChain.assets/image-20240101120146491.png)

![image-20240101120202857](blockChain.assets/image-20240101120202857.png)

第二阶段：

节点自行反序列化redeem Script并执行

![image-20240101120220609](blockChain.assets/image-20240101120220609.png)

![image-20240101120227044](blockChain.assets/image-20240101120227044.png)

###### 早期的多重签名

![image-20240101120854542](blockChain.assets/image-20240101120854542.png)

![image-20240101120936946](blockChain.assets/image-20240101120936946.png)

执行过程：

![image-20240101120949099](blockChain.assets/image-20240101120949099.png)

![image-20240101120956980](blockChain.assets/image-20240101120956980.png)

![image-20240101121031132](blockChain.assets/image-20240101121031132.png)



![image-20240101121328960](blockChain.assets/image-20240101121328960.png)

早期的多重签名把复杂性留给了用户（用户需要指明M和N值）

###### 用P2SH实现多重签名

将M和N值从输出脚本转移到赎回脚本

赎回脚本由输入者（收款人）提供

- 电商网站中，收款人是电商，电商提供赎回脚本的规则，用户不需要知道
- 如果赎回脚本改变，那么用户只需要改变输出脚本中赎回脚本的哈希值（由电商提供）

###### ![image-20240101121533522](blockChain.assets/image-20240101121533522.png)

![image-20240101121950318](blockChain.assets/image-20240101121950318.png)

![image-20240101122000534](blockChain.assets/image-20240101122000534.png)

![image-20240101122006948](blockChain.assets/image-20240101122006948.png)

![image-20240101122015099](blockChain.assets/image-20240101122015099.png)

![image-20240101122031782](blockChain.assets/image-20240101122031782.png)

赎回脚本执行

![image-20240101122054783](blockChain.assets/image-20240101122054783.png)

![](blockChain.assets/image-20240101122108132.png)

##### 销毁比特币

任何节点都可以使用这种方法往区块链写入内容

用途

1. 往区块链写入永久内容
2. 兑换小币种

![image-20240101122320619](blockChain.assets/image-20240101122320619.png)









##### Q&A

**Q：P2PK和P2PKH有什么相同点和不同点？**  

A：

**相同点：**

1. **支付形式：** P2PK和P2PKH都是比特币交易脚本的支付形式，用于指定接收比特币的收款地址。
2. **公钥相关：** 两者都涉及公钥的使用。在比特币交易中，公钥是与一个私钥对应的加密学密钥，用于验证交易的签名。

**不同点：**

1. **脚本构建：**
   - **P2PK：** P2PK支付脚本直接包含发送者的公钥，而接收者在后续的交易中使用这个公钥来验证签名。
   - **P2PKH：** P2PKH支付脚本使用了哈希函数。它包含接收者的公钥哈希（公钥的散列值），而实际的公钥在后续交易的输入脚本中被提供。
2. **隐私和安全性：**
   - **P2PK：** P2PK的主要问题是它暴露了公钥，可能涉及到一些隐私和安全性的问题。由于公钥是直接暴露的，存在一些潜在的攻击风险。
   - **P2PKH：** P2PKH通过使用公钥的哈希值来提高隐私和安全性。在交易中，只有公钥的哈希值会被公开，实际的公钥只有在验证签名时才会被提供，从而降低了一些潜在的风险。

**Q：P2PK就能成功实现转账功能， 为什么还需要P2PKH？**  

尽管P2PK可以成功实现转账功能，但引入P2PKH主要是出于隐私和安全性的考虑。使用P2PKH，真实的公钥并不直接暴露在区块链上，而是使用公钥的哈希值。这有助于保护用户的隐私，并降低某些攻击的可能性。此外，P2PKH的设计更加灵活，使得比特币地址更紧凑，交易的大小也更小，从而减少了交易手续费。因此，P2PKH成为比特币中更为广泛使用的支付脚本形式。

### 比特币的共识机制

1. Definition: Consensus（共识） is
   - A process of agreement between distrusted nodes on the final state of specified data.
2. Distributed consensus（分布式共识）
   - To attain a common state/value among multiple nodes despite that the failures of some nodes exist
3. An agreement（一致性）
   - between two nodes is easy: only few synchronization messages are needed, e.g., TCP’s handshaking
   - It becomes pretty a challenge to achieve consensus among multiple distributed nodes （分布式节点）

#### CAP定理

CAP定理指:

- Consistency（一致性）：所有节点在同一时间看到的数据是相同的，即系统保证所有节点都能访问到最新的写入操作结果。
-  Availability（可用性）：在有限时间内，每个请求都能接收到一个非错误的响应，即系统保证服务一直可用，不会出现长时间的不可用情况。
-  Partition tolerance（分区容错性）：系统能够在网络分区的情况下继续运行。分区容忍性意味着系统中的节点可以在彼此之间失去联系的情况下继续运行。

一个分布式系统不能同时满足以上3个性质

具体来说：

- 如果选择保证一致性和可用性，那么在发生网络分区时，系统可能会选择停止服务以保持一致性。
- 如果选择保证可用性和分区容忍性，那么系统可能在发生网络分区时允许节点之间的数据不一致。
- 如果选择保证一致性和分区容忍性，那么在发生网络分区时，系统可能会牺牲可用性。

![image-20231231204913578](blockChain.assets/image-20231231204913578.png)

![image-20231231204934920](blockChain.assets/image-20231231204934920.png)

![image-20231231210237691](blockChain.assets/image-20231231210237691.png)

![image-20231231210317748](blockChain.assets/image-20231231210317748.png)

#### 共识机制的类型

1. BFT-based（拜占庭容错，Byzantine Fault Tolerance）
2. Leader Election-based（基于领导者选举的）

##### BFT-based（拜占庭容错）

> 在拜占庭容错问题中，系统的节点可以分为两类：正常节点和拜占庭节点。正常节点遵循协议，而拜占庭节点可能采取任何行动，包括发送虚假信息、篡改数据等。

- **定义：** BFT是一种共识算法，其目标是在系统中存在最多f个恶意节点（拜占庭节点）的情况下，依然能够达成一致的共识。
  - 恶意节点为m，总节点为n，n>3m时， 是可解的
- **特点：** 这类算法通常能够容忍一定比例的节点故障或者恶意行为，确保在这种情况下系统仍然能够保持一致性。
- **工作原理：** BFT算法通常涉及多个节点之间的相互通信和协作，通过互相验证消息的方式来达成一致的决策。

**Strengths (优势):**

1. **高效处理少量节点：** 系统在处理有限数量的节点时表现出色，可能是因为设计初衷是专注于小规模的网络或者节点数量。
2. **低延迟和高性能：** 少量节点的情境下，系统可能更容易实现低延迟、高吞吐量和高性能，因为节点之间的通信相对简单和快速。

**Weaknesses (劣势):**

1. **规模扩展性差：** 当节点数量增加时，系统的性能逐渐下降。这可能是因为系统设计、通信负担或共识算法等方面未能有效应对大规模的节点。
2. **资源消耗增加：** 随着节点数量的增加，系统可能需要更多的资源（例如计算力、带宽、存储），而这可能导致系统不再能够有效地应对规模扩大的挑战。

##### Leader Election-based（基于领导者选举的）

- **定义：** 基于领导者选举的共识机制是通过选择一个特殊的节点作为领导者（Leader），由领导者负责提出决策，其他节点进行投票或者接受领导者的提案，从而达成一致。
- **特点：** 领导者选举机制通过减少决策的提出者，简化了共识过程，提高了系统的效率。
- **工作原理：** 系统中的节点周期性地进行领导者选举，选出领导者后，其他节点向领导者发送提案或者投票，最终领导者整合这些提案或者投票，达成一致的共识。

**Strengths (优势):**

1. **优越的规模扩展性：** 系统在处理大规模节点时表现出色，可能是因为其设计考虑到了高度的可扩展性，能够适应大规模的网络或节点数量的增长。
2. **横向扩展能力强：** 系统可能支持横向扩展，能够通过增加节点数量来应对系统负载的增加，从而实现更好的规模扩展性。

**Weaknesses (劣势):**

1. **性能较慢：** 为了实现高度的规模扩展性，系统可能采取了某些复杂的算法、通信协议或者其他机制，导致处理速度相对较慢。
2. **较高的延迟：** 大规模系统中节点之间的通信可能涉及更多的网络传输和处理步骤，从而导致较高的延迟。

##### 不同区块链的共识机制

**Permissionless Blockchain: 公有链**

- 几乎人人都可以参与，每个参与者都是匿名
- 参与者之间不存在任何信任
- 采用 算力敏感的“挖矿”共识 作为激励机制

**Permissioned Blockchain: 联盟链/私链**

- 在一组已知的、 已识别的、 且经过审查的参与者中进行区块链的操作
- 节点具有一定的信任基础
- 不需要算力敏感的共识机制， BFT 类型的共识机制比较适合

#### 比特币的共识机制（POW）

比特币的共识机制是通过工作量证明（PoW）实现的  

基本原理：

1. **挖矿**： 比特币网络中的节点（矿工）通过解决一个复杂的数学难题来参与竞争，这个过程称为挖矿。这个难题的解需要大量的计算力，但解的验证却很容易。矿工谁先解出这个难题，就有权力打包新的交易区块。
2. **挖矿奖励**： 矿工们争相竞争，通过不断尝试解题来创建新的区块。解出问题的矿工可以将新的区块添加到区块链上，并获得一定数量的比特币作为奖励，这个过程被称为挖矿奖励。
3. **最长链原则**： 当有多个节点同时解出问题时，可能会出现多个分支的区块链。为了维持一致性，比特币网络采用了最长链原则，即选择具有最长区块链的分支作为有效的区块链。这是因为最长链代表着被整个网络最多的工作量所接受的历史，因此被认为是最安全和最可信的链

**比特币的共识机制本质上是为了解决拜占庭将军问题，但拜占庭容错算法不适用于解决共识问题  ：**

以上两种算法都需要投票，投票在比特币网络中有一个弱点：创建账户的成本几乎没有，这意味着攻击者可以通过创建大量的账户获取投票权，从而影响最终投票结果，这就是女巫攻击。

为了避免女巫攻击，比特币网络采用资源成本（而不是身份）进行投票，这就是工作量证明(Proof Of Work,POW)

##### 基于工作量证明的挖矿

我们已经知道挖矿是一个获取记账权的行为，矿工为了获取挖矿得到的出块奖励而争夺记账权。

我们规定：记账权必须通过花费计算资源来获得。在之前我们提到：挖矿本质是一道谜题，需要矿工穷举nonce满足Hash(header|nonce) < target，要解这道谜题需要付出大量算力，挖矿过程就是工作量证明。

就算攻击者有多个身份，也只对应到单个计算资源，从而保证记账的公平性。

![image-20231231215501095](blockChain.assets/image-20231231215501095.png)

整个争夺记账的过程就是挖矿的过程， 也就是比特币发行的过程

“挖矿”争夺记账权奖励

- 记账有利润： 比特币奖励 + 交易手续费
- 很多人争夺记账权
- 通过付出计算量解决一个难题，谁先解决谁获得记账权
- 坏人作恶的成本变高

**比特币 PoW 挖矿的一些规则**  

- 每 **10 分钟**左右生成一个不超过 1 MB 大小的区块（记录了这 10 分钟内发生的验证过的交易内容），串联到区块链尾部，每个区块的成功提交者可以得到系统一定数量的比特币的奖励（该奖励作为区块内的第一个交易，一定区块数后才能使用），以及用户附加到交易上的支付服务费用

- **注：每个区块的奖励最初是 50 个比特币，每隔 21 万个区块自动减半，即 4年时间。**

- 最终在2140年比特币总量稳定在 2100 万个

  - Q: 为何总数是2100万枚？

    A：比特币白皮书规定了每个区块的奖励，最初是50比特币。然后，每经过210,000个区块，奖励就减半一次。因此，第一个减半事件发生在2009年1月，将比特币奖励降至25个。之后的减半发生在2012年、2016年和2020年，分别将奖励降至12.5、6.25和3.125比特币。

    根据这个减半规律，当比特币网络经历完32次减半事件，即在2140年左右，比特币的新发行奖励将减至零。这意味着在那个时候，挖矿将不再产生新的比特币。因此，2100万是比特币总供应量的上限，这个数字的设定是通过比特币协议和挖矿算法来确保的，旨在保持比特币的稀缺性和抵御通货膨胀。

- 因此，比特币是一种通缩的货币

##### POW最长链机制

![image-20231231220354602](blockChain.assets/image-20231231220354602.png)

##### Q&A

###### 如何理解挖矿即哈希？

POW具有和Hash函数一样的特点

![image-20240101094109060](blockChain.assets/image-20240101094109060.png)

###### 无中心网络需要何种工作量证明？  

PoW难题的设计必须满足如下条件：

1. 不容易完成（表明需要工作量）
2. 容易验证（其他节点可以快速确认确实付出了工作量）
3. 工作过程公平（任何节点没有完成工作的捷径）
4. 具有随机性（能力越强，只能保证率先完成概率越大）

### 分叉

如果因为两个节点在相近的时间”同时“挖出了区块产生了分叉，这种分叉叫做State Fork

- 51%攻击属于State Fork，但它是故意的，也叫Deliberate Fork

如果对协议进行了升级，无法保证对所有节点升级（可能有节点无法升级/拒绝升级等原因），对协议产生分歧从而产生分叉，称为Protocol Fork

- 根据协议修改内容的不同，可以分为硬分叉和软分叉

![image-20240101153146081](blockChain.assets/image-20240101153146081.png)

#### 硬分叉

新节点认为合法的交易，旧节点不认可；旧节点认为合法的交易，新节点认可

![image-20240101154513062](blockChain.assets/image-20240101154513062.png)

![image-20240101154957014](blockChain.assets/image-20240101154957014.png)



#### 软分叉

旧节点认为合法的交易，新节点不认可；新节点认为合法的交易，旧节点也认可

![image-20240101154540033](blockChain.assets/image-20240101154540033.png)

![image-20240101155009152](blockChain.assets/image-20240101155009152.png)

**硬软分叉的核心区别**

- 硬分叉：旧节点不兼容新节点，导致分叉永远存在

  （在旧节点看来，发生了新变化且不能接受新变化。除非该旧节点升级，否则旧节点永远不能接受新变化）

  - 新节点认为合法的交易，旧节点不认可
  - 旧节点认为合法的交易，新节点认可

- 软分叉：旧节点兼容新节点，分叉只是暂时性存在（旧节点经常被回滚）

  （在旧节点看来，没有发生新变化，只是旧节点在新节点看来很笨跟不上时代，会一直吃亏）

  - 旧节点认为合法的交易，新节点不认可
  - 新节点认为合法的交易，旧节点也认可

**判断软硬分叉只需代入旧节点视角，看有没有对自己产生变化即可**

像下图中，旧节点不知道coinbase有merkle tree root，但仍然能正常运行，所以是软分叉

![image-20240101160827545](blockChain.assets/image-20240101160827545.png)

### 比特币安全

#### 双花攻击

双花攻击：用户可以花费同一笔数字资产两次。  

**双花攻击的实现需要攻击者拥有超过一般一半以上的算力，即双花攻击是51%攻击的特例**。实现过程如下：

1. 攻击者创建2笔交易
2. 确认第一笔交易： 如果攻击者能够在全网范围内迅速建立一笔交易的多个确认（即被写入多个区块），他们就可以将这笔交易的物理商品或服务取走。
3. 在另一分支确认另一笔交易： 一旦攻击者确认取走商品或服务，他们就试图替换并广播另一笔交易链，即将另一笔交易也写入区块链，以使这两笔交易都被确认。
4. 网络选择最长链： 在比特币网络中，当出现两个相互独立的区块链时，网络会选择最长的链作为主链。攻击者需要控制网络上的大量算力，以确保他们的交易链成为最长链。
5. 成功的条件： 如果攻击者成功地替换了另一笔交易并使其成为最长链的一部分，那么系统中的节点将接受这个新的链作为事实。此时，攻击者成功地进行了双花攻击，既取得了商品或服务，又保留了相同数量的比特币

![image-20240101094653661](blockChain.assets/image-20240101094653661.png)

#### 女巫攻击（Sybil Attack）  

女巫攻击（Sybil Attack）：攻击者创建大量虚假的身份（或节点），然后将这些虚假身份引入系统中，以获取对系统的控制权  

BFT-based（拜占庭容错，Byzantine Fault Tolerance）和Leader Election-based（基于领导者选举的）算法都需要投票，投票在比特币网络中有一个弱点：创建账户的成本几乎没有，这意味着攻击者可以通过创建大量的账户获取投票权，从而影响最终投票结果，这就是女巫攻击。

为了避免女巫攻击，比特币网络采用资源成本（而不是身份）进行投票，这就是工作量证明(Proof Of Work,POW)

就算攻击者有多个身份，也只对应到单个计算资源，从而保证记账的公平性。

#### 51% 攻击（Majority Attack）  

51% 攻击（Majority Attack）：攻击者掌握了超过50%的网络算力，从而能够对区块链进行恶意操纵。这种攻击称为51%攻击，攻击者可以进行**双花攻击、阻止交易确认**等操作。比特币等基于工作量证明的区块链通常通过分散的全球性算力来防范此类攻击。  

51%攻击会造成很多消极影响，例如篡改交易历史，阻止新的交易被确认，甚至进行双花攻击。

双花攻击例子如下：

![image-20240101101117885](blockChain.assets/image-20240101101117885.png)

##### 如何防范51% 攻击

![image-20240101101233906](blockChain.assets/image-20240101101233906.png)

#### 自私挖矿攻击（Selfish Mining Attack）

攻击者通过隐藏其发现的新区块，只在发现多个连续区块后再广播，从而获得不当的挖矿奖励。这种攻击试图破坏区块链的共识机制，特别是对于采用基于挖矿的共识机制的区块链。  

![image-20240101161018863](blockChain.assets/image-20240101161018863.png)

#### 抢跑攻击（Front Running）

在去中心化交易所（Dex）或去中心化金融（DeFi）平台中，攻击者可能通过在交易执行之前获取相关信息，从而在市场上执行有利的交易，导致其他参与者的损失。  

#### 日蚀攻击（Eclipse Attack）

日蚀攻击是一种网络攻击，其中攻击者试图隔离特定的节点，使其与整个网络失去联系，以便攻击者能够对受害节点进行操纵。这个攻击的名字来自于天文学中的“日蚀”，暗示了节点被孤立的状态。

在比特币等分布式网络中，节点之间通过对等网络（Peer-to-Peer，P2P）进行通信。攻击者通过建立大量的恶意节点，并与目标节点建立连接，使得目标节点的视图被恶意节点完全包围。这样，目标节点将只能与攻击者的节点进行通信，而无法获取网络中其他节点的信息。日蚀攻击可以被用来执行一系列潜在的恶意行为，如双花攻击、拒绝服务等。

#### 延展性攻击（Transaction Malleability Attack）

延展性攻击是一种利用比特币交易可锻性（malleability）的攻击手法。比特币交易可锻性是指交易的签名部分可以在不影响交易有效性的情况下被更改。这种可锻性是由于比特币签名机制的设计，攻击者可以修改签名的特定部分，而不改变交易的有效性。

攻击者通过改变交易的签名，生成一个新的交易哈希，而不改变交易的含义。这可能导致一些问题，例如在比特币交易确认前，攻击者可以修改交易哈希，使其看起来不同于原始交易，但仍然有效。这可能导致一些混淆和问题，特别是对于依赖交易哈希的系统或应用。

为了应对延展性攻击，比特币引入了Segregated Witness（隔离见证，SegWit）等改进。SegWit将交易签名部分移出交易体，从而解决了延展性问题，提高了比特币交易的安全性。

### 比特币的匿名性

比特币的匿名性是相对的，不是绝对的

**什么情况会破坏BTC匿名性？**  

<u>本质原因是BTC的账本是公开的且不可篡改的</u>

1. 通过输入和输出金额来关联地址
2. 地址账户与个人在真实社会中的身份也可能会产生关联
   - 买卖BTC：用现实世界的资金买比特币 or 将比特币转换为现实世界的资金
   - 现实世界用BTC支付的时候，将账户和个人身份联系（可以跟踪消费行为对应时间和场所）

![image-20240101165432751](blockChain.assets/image-20240101165432751.png)

![image-20240101165512199](blockChain.assets/image-20240101165512199.png)

**提高比特币的匿名性**  

- 从网络层看，可以采用多路径转发的方法，数据不直接发送出去，而是经过很多跳(洋葱路由的基本思想)

  ![image-20240101171138676](blockChain.assets/image-20240101171138676.png)

- 从应用层看，可以将各个不同用户的BTC混合在一起，使得追查变得混乱(Coin mixing)

  ![image-20240101171043952](blockChain.assets/image-20240101171043952.png)

  ![image-20240101171103966](blockChain.assets/image-20240101171103966.png)

#### 零知识证明

零知识证明：一方（证明者）向另一方（验证者）证明某一个陈述是正确的，但不需要透露除该陈述是正确的之外的任何信息。

例子： A想要向B证明某一账户属于A，这说明A知道该账户的私钥。但不可能通过A公布私钥的方法来证明，该账户确实属于A。因此， A可以产生一个账户签名， B通过公钥对签名进行验证

**数学基础：同态隐藏**  

1. 如果E(x)=E(y)，则x=y
2. 不可逆性：知道E(x)不能推出x
3. 同态运算

![image-20240101171537029](blockChain.assets/image-20240101171537029.png)

![image-20240101171742420](blockChain.assets/image-20240101171742420.png)

![image-20240101171817309](blockChain.assets/image-20240101171817309.png)

#### 盲签

盲签名是一种特殊的数字签名技术。盲签名因签名的人看不到所签署文件的具体内容而闻名，它有两个显著的特点：

- 一是签名者对消息的内容是不可见的
- 二是签名被公开后，签名者不能追踪签名

**为什么需要盲签？**

电子交易中，我们的交易信息依赖于银行等第三方机构。第三方机构需要防范其他人伪造， 就需要对电子货币进行签名。而签名的过程中，必然会导致其了解到交易内容。如果想要银行等第三方机构负责相应工作，但不知道交易具体内容，就可以采用盲签的方法

![image-20240101172301265](blockChain.assets/image-20240101172301265.png)

### Q&A

Q：转账交易时候，如果接收者不在线(没有连在比特币网络上)怎么办？  

A：转账交易只需要在区块链上记录，将某账户比特币转到另一账户，而接收方是否在线并无影响



Q：假设某全节点收到某个转账交易，会不会有可能转账交易中收款人地址该全节点从未听过？  

A：可能，因为比特币账户只需要本地产生即可。只有该账户第一次收到钱时，其他节点才能知道该节点的存在



Q：如果账户私钥丢失怎么办？  

A：没有办法。因为比特币是去中心化货币，没有第三方中心机构可以重置密码，所以账户上的钱也就变成了死钱



Q：私钥泄露怎么办  ？  

A：尽快将剩余BTC转到其他安全账户上，没有第三方中心机构重置密码或冻结账户，只能自己对自己负责。BTC系统中账户便是公私钥对，密码就是私钥，无法更改



Q：转账写错地址怎么办？   

A：没有办法，只能自认倒霉，无法取消已经发布的交易。如果转入不存在地址，则该部分比特币便成为了死钱。 比特币系统中UTXO会永久保存该交易，记录该并不存在的地址。因此，对全节点来说，这是不友好的



Q：BTC系统挖矿，会不会有矿工“偷”答案？    

例如：某个矿工发现其他矿工发布了nonce，收到后验证该区块合法，将该nonce作为自己找到的nonce发布出去。

A：实际上这是不可能的。发布的区块中包含铸币交易，其收款人地址为挖到矿的矿工地址，如果要偷答案，需要修改该收款地址，而地址改变，铸币交易内容也发生改变，从而引发Merkle Tree根哈希值改变。从而导致原本的nonce作废。也就是说，不可能会“偷”答案



Q：交易费是交易者为了自己交易可以上链而给出的“小费”，那么如何得知哪个矿工可以挖到矿？  

A：事先无需知道谁会挖到矿，交易中总输入和总输出差额就是交易费。哪个矿工挖到矿，在打包交易时，可以将这些交易费收集起来作为自己获得的交易费



## 以太坊

> 了解更多以太坊信息：
>
> [账户 :: 以太坊技术与实现 (learnblockchain.cn)](https://learnblockchain.cn/books/geth/part1/account.html#账户数据结构)

比特币和以太坊是两种最主要的加密货币

比特币是区块链1.0，以太坊是区块链2.0

与比特币基于交易不同，以太坊基于账户（不需要说明币的来源，对于双花攻击有天然的防御作用，但有新的攻击：replay attack）

以太坊基于比特币的一些运行问题进行了改进

- 出块时间15s左右，减小交易延迟
- mining puzzle 对内存要求高（限制ASIC使用）
- 2022年9月升级后采用 PoS，代替 PoW

**第一个支持智能合约（去中心化的合约）的区块链系统**  

### 智能合约

![image-20240101184418356](blockChain.assets/image-20240101184418356.png)

智能合约指能够自动执行合约条款的计算机程序，其概念由**尼克·萨博**在**1994年**提出，具有事件驱动、价值转移、自动执行等特性  

例如：将自动售货机视为智能合约

- **事件驱动**：合约以投币等动作作为输入，触发其动作执行
- **价值转移**：外部以钱币为输入，合约输出饮料等商品，完成了价值的交换或转移
- **自动执行**：这一履约行为是完全自动的，不需要人在其中干预（投币动作除外）



中心化环境 的 弊端

- 容易受到篡改：可以人为地修改自动售货机的程序，使其免费出售商品
- 出错后难以追溯恢复：一旦售货机程序被篡改，篡改的源头是往往无法追溯的，因为恶意篡改人已经掌握了整个机器的控制权

智能合约依赖于环境的可靠性 ，一旦执行环境出错，则合约的执行也将出错。部署在**区块链**上的智能合约，就能使得智能合约有更高的可靠性。

**智能合约的出现解决了传统合约的信任问题，大幅降低了信任成本**  



**以太坊上的 智能合约**

- 以太坊在多个节点组成的点对点网络中，维护共同的区块链数据，通过区块链上的交易来进行智能合约的 创建、调用、结束 等操作
-  由于多个节点所维护的区块链状态是一致的，因此，多个节点上所运行的智能合约的 过程和结果 也是一致的

### 以太坊区块数据结构

![image-20240101201312546](blockChain.assets/image-20240101201312546.png)

**以太坊区块头内容**

-  记录以太坊状态的 状态根
- 交易列表、收据列表和叔块列表对应的 哈希值
- 最长不超过 100 KB 的 额外数据

**以太坊区块体内容**

- 由交易组成的 tx 列表
- 由交易执行信息组成的 收据列表
- 用于改进以太坊共识过程的 叔块列表

![image-20240101201339445](blockChain.assets/image-20240101201339445.png)

### 以太坊账户模型

账户模型由用户地址和账户状态组成

#### **账户地址**

160位，对应40个十六进制数

![image-20240101234000059](blockChain.assets/image-20240101234000059.png)

#### **账户状态**

##### 账户数据字段

1. **余额**：记录了当前地址持有的以太币的数额，单位是 Wei

2. **Nonce**：记录了这个地址创建以来累计发起的交易次数

   - 只有 账户的 Nonce 和 交易的 Nonce 能够对应的情况下，交易才是合法的

   - 当一个交易执行完毕之后，账户的 Nonce 值增加，原本执行完毕的 交易中的 Nonce 值就无法与现在 账户的 Nonce 值匹配

   - 如果要 修改对应的 Nonce 值，意味着原有交易的签名失效

     ![image-20240101234546919](blockChain.assets/image-20240101234546919.png)

   - Nonce 的 其他用途
     - 控制账户发起的交易的顺序，从而实现一些相对复杂的功能
     - 通过重复提交一个相同 Nonce 值的交易来使得一个「已经提交但是尚未被确认」的交易变得不合法，从而实现一定程度的撤销功能

3. **CodeHash**：智能合约代码的哈希值

4. **StorageRoot**：合约**存储树**的根节点哈希值（维护智能合约状态）

   - 合约存储树：
     - 合约账户下的存储也是一个映射表，它记录了从存储地址到存储值的一个映射关系
     - 在合约账户的数据结构中存储了这个映射表的哈希值，这个哈希值被称作存储根（Storage Root），它同样是由一棵 MPT 来维护和计算

##### 账户类型

合约账户才有CodeHash，外部账户CodeHash为空

![image-20240101234817886](blockChain.assets/image-20240101234817886.png)

#### Q&A

Q：比特币的 UTXO，以太坊的账户模型，哪一个更注重隐私保护？

A：比特币的 UTXO更注重隐私保护。



Q：比特币的 UTXOs 模型更有利于隐私保护，那为什么以太坊还要使用账户模型？

A：是为了支持 智能合约，要求参与者要有 稳定的身份  

### 以太坊的状态树：Merkle Patricia Trie (MPT)  

![image-20240101235531386](blockChain.assets/image-20240101235531386.png)

![image-20240101235541533](blockChain.assets/image-20240101235541533.png)

![image-20240101235635196](blockChain.assets/image-20240101235635196.png)

![image-20240101235709502](blockChain.assets/image-20240101235709502.png)



#### Merkle Patricia Trie (MPT)  

如果把 单词 都换成哈希值，然后计算每个中间节点的哈希值（使用哈希指针），便得到了MPT

**MPT 的构造**

- 按照 所有数据 的地址（或者键值）来构建一棵 压缩前缀树u 由于地址是以16进制为编码的，我们使用 0123456789abcdef 作为每一个编码的单元
- 按照构建得到的压缩前缀树，从叶子节点开始，逐步计算每一层的哈希值，并将其汇合到父节点中，与 Merkle Tree 的计算过程类似

![image-20240102000242771](blockChain.assets/image-20240102000242771.png)

![image-20240102000258162](blockChain.assets/image-20240102000258162.png)

![image-20240102000435770](blockChain.assets/image-20240102000435770.png)

解释一下：交易T改变了账户C的状态使其变成了C'，那么下个区块要生成一个新的状态树。但这个新的状态树具有以下特点：没有变化的账户则共享状态树节点，而状态改变的账户C在状态树内新增一个分支

既然账户C改变了状态，为什么不抛弃以前的账户C？

因为智能合约可以支持许多改变账户状态的复杂操作，保存历史账户状态方便回滚。比特币不需要保存历史状态，因为比特币回滚非常简单，只需将交易转账方发出的比特币加回来，将接收方添加的比特币减回来即可。

### 以太坊的 收据树、交易树、 Bloom Filter  

#### 收据 (Transaction Receipts)  

定义

- 收据是对应交易的数据结构，代表了交易执行的一些中间状态的写入 和 交易的执行结果 等信息

“收据” 的内容

- 以太坊的智能合约向虚拟机输出的一些执行日志
- 智能合约运行的 Gas 信息。
- 单个交易执行完毕后以太坊的状态根
- 一个交易创建智能合约的时候，如果执行成功会把新建合约的地址写到一个收据之中

![image-20240102001408585](blockChain.assets/image-20240102001408585.png)

#### 交易树和收据树

交易树和收据树

- 与比特币中的 Merkle Tree 类似的，对于以太坊区块中的所有 交易 和 交易的收据，都可以使用 MPT 进行组织和证明
- MPT 的构建不再是通过账户地址来进行，而是通过交易或者收据在区块中的序号来构建 MPT
- 收据树和交易的信息一一对应。主要是考虑到智能合约的执行比较复杂，收据树可以有利于快速查询，证明交易结果

为什么 交易树与收据树也使用 MPT，而不是普通的 Merkle Tree?

- 代码复用：以太坊其他数据结构都采用 MPT， 代码统一，利于管理– 查找效率高

#### Bloom Filter  

Bloom Filter （布隆过滤器）的 用途

- 以太坊中通过布隆过滤器对收据的日志进行索引、查找，比如：
  - Client 找到过去十天和某个智能合约有关的交易
  - Client 找到过去十天当中符合某种类型的所有事件（e.g., 众筹事件 or 发行新币的事件）

优点

- 布隆过滤器可以用于检索一个值是否在一个集合中。在容忍一定的误识别率的条件下，它有着远超过一般算法的空间效率和时间效率。

原理

- 通过多个哈希函数将键值映射到位图之中，并在位图中合并集合中所有键值的映射结果。
- 对于一个键值，如果经过同样的哈希函数映射之后，出现了在位图中没有出现的标记位，那么这个键值必定不存在于集合之中

![image-20240102085911644](blockChain.assets/image-20240102085911644.png)

### 以太坊基本架构与原理

#### 背景

- 在账户模型中，用户的余额通过地址上的账户数据来表示，具体为账户数据结构中的一个余额的数值– 在转账交易的过程中，通过转账预先定义好的语义，在发起者的账户中减去交易中定义好的转账金额，在接受者的账户中增加相应的金额– 可以把账户的余额泛化成一种账户的状态，而把转账交易当作是改变状态的一个方法

状态转移：由交易来驱动的状态机

- 在区块N执行前状态为S，经过区块N的交易进行状态转换后，转换为状态S'，再经过区块N+1的转换后，转换为状态S''

![image-20240102090952941](blockChain.assets/image-20240102090952941.png)

![image-20240102091054766](blockChain.assets/image-20240102091054766.png)

#### 架构与原理

![image-20240102091153658](blockChain.assets/image-20240102091153658.png)

![image-20240102091246038](blockChain.assets/image-20240102091246038.png)

### 以太坊交易

![image-20240102091331363](blockChain.assets/image-20240102091331363.png)

![image-20240102091526916](blockChain.assets/image-20240102091526916.png)

![image-20240102091927065](blockChain.assets/image-20240102091927065.png)

![image-20240102092050397](blockChain.assets/image-20240102092050397.png)

![image-20240102092108843](blockChain.assets/image-20240102092108843.png)

![image-20240102092128474](blockChain.assets/image-20240102092128474.png)

![image-20240102092302855](blockChain.assets/image-20240102092302855.png)

![image-20240102092329786](blockChain.assets/image-20240102092329786.png)

![image-20240102092556356](blockChain.assets/image-20240102092556356.png)

![image-20240102092630180](blockChain.assets/image-20240102092630180.png)

![image-20240102092640874](blockChain.assets/image-20240102092640874.png)

![image-20240102092733015](blockChain.assets/image-20240102092733015.png)

![image-20240102092835066](blockChain.assets/image-20240102092835066.png)

### 以太坊的共识机制

基于 PoW 机制

- ASIC resistance: memory hard puzzle
- 以太坊采用的哈希算法是 ethash 算法，对内存有要求（ASIC resistance)。

将来过渡为 PoS (Proof-of-Stake)

过渡方法：

![image-20240102093030898](blockChain.assets/image-20240102093030898.png)

![image-20240102093059421](blockChain.assets/image-20240102093059421.png)

![image-20240102093159482](blockChain.assets/image-20240102093159482.png)

叔父块特点  

- 某个区块最多只能接纳2个叔父块，也可以不接纳任何叔父块
- 叔父块必须是区块的前2层～前7层的祖先的直接子块
- 被接纳过的叔父块不能再重复接纳了
- 接纳了n个叔父块的区块，可以获得出块奖励的 n*1/32 
- 被引用了的叔父块，随着距离越远，得到的奖励递减1/8（最少奖励为 **出块奖励*2/8** ）

叔父区块中的交易会被执行吗?

不需要

原因：很可能叔父区块与当前区块之间的交易是存在冲突的交易，实际上以太坊中不会执行叔父区块中的交易

而只检查这个叔父是不是符合挖矿难度要求的合法区块

![image-20240102094805860](blockChain.assets/image-20240102094805860.png)

![image-20240102094821430](blockChain.assets/image-20240102094821430.png)



### 挖矿难度调整

![image-20240102095019591](blockChain.assets/image-20240102095019591.png)

![image-20240102095127433](blockChain.assets/image-20240102095127433.png)

![image-20240102095137034](blockChain.assets/image-20240102095137034.png)

![image-20240102095145564](blockChain.assets/image-20240102095145564.png)

![image-20240102095251062](blockChain.assets/image-20240102095251062.png)

![image-20240102095532343](blockChain.assets/image-20240102095532343.png)

## 区块链安全

### 安全隐患

#### 区块链层级架构视角

![image-20240102100320562](blockChain.assets/image-20240102100320562.png)

#### 区块链六类安全隐患

![image-20240102100337637](blockChain.assets/image-20240102100337637.png)

![image-20240102101036200](blockChain.assets/image-20240102101036200.png)

![image-20240102101049662](blockChain.assets/image-20240102101049662.png)

#### 网络连通性与区块链安全性  

网络 连通性 越低

- 系统越容易出现 分叉
- 矿工进行 51% 攻击所需的算力就会 越低

网络连通性的 差异性 越大

- 具有更好连通性的矿工 发起 51% 攻击所需的算力就会 越低

### 怎样让区块链不安全？  

①攻击 基础组件和设施（针对P2P网络特性攻击）

- 攻击基础组件：进行Eclipse日蚀攻击、分割攻击、延迟攻击、Ddos攻击、交易延展性攻击等；
- 攻击设施：进行劫持算力攻击、木马攻击等；

②攻击系统核心设计：通过双花、女巫攻击、51％算力攻击等手段攻击区块链共识层、攻击合约层DAO、对数据层进行破坏等；

③攻击区块链应用生态：如破坏区块链交易网站、数字钱包等，使区块链应用失去用户信任；

④攻击区块链本身：盗取用户私钥、破坏智能合约、破解交易内容等等。

## 区块链应用

week3-PPT-27页开始

### 以太坊应用

![image-20240101201201989](blockChain.assets/image-20240101201201989.png)