# 算法

## 前置知识

### 时间复杂度

$𝑂(1) ≤ 𝑂(𝑙𝑜𝑔_2𝑛) ≤ 𝑂(n)≤ 𝑂(𝑛𝑙𝑜𝑔_2𝑛) ≤ 𝑂(𝑛^2)≤ 𝑂(𝑛^3) … ≤ 𝑂(𝑛^𝑘) ≤ 𝑂(𝑛!)  $

➢ 当n = 1e8 = 108时，运行时间0.164s

➢ 当n = 1e9时，运行时间1.645s。

➢ 如果题目要求“Time Limit: 2000/1000 MS (Java/Others)” ，那么内部的循环次数应该满足n<=$10^8$，即1亿次以内。

即时间要求1s内时，对应的时间复杂度只能是$𝑂(1) 、𝑂(𝑙𝑜𝑔_2𝑛)、 𝑂(n)、𝑂(𝑛𝑙𝑜𝑔_2𝑛)$ 

### 数值范围

> **实际编程中，需要特别小心溢出的错误，为此我们列出数值范围**

C/C++常见的数值范围

![image-20231219170547365](algorithm.assets/image-20231219170547365.png)

对应十进制数值范围为：

| 常见类型说明符                     | 字节数 | 数的范围（十进制）                                           |
| ---------------------------------- | ------ | ------------------------------------------------------------ |
| 整型(int)                          | 4      | 正数：$10^{9}<2^{31}-1<10^{10}$<br>负数：$-10^{10}<-2^{31}<-10^{9}$ |
| 长整型(long int)                   | 4      | 正数：$10^{9}<2^{31}-1<10^{10}$<br/>负数：$-10^{10}<-2^{31}<-10^{9}$ |
| 双长整型(long long)                | 8      | 正数：$10^{19}<2^{63}-1<10^{20}$<br/>负数：$-10^{20}<-2^{63}<-10^{19}$ |
| 无符号双长整型(unsigned long long) | 8      | 正数：$10^{19}<2^{63}-1<10^{20}$                             |

Q：int最大能表示多少位的十进制正整数？

A：10。（注意$10^9$是10位，$10^{10}$是11位）

另外注意pow函数的返回值是double

![image-20240102192757243](algorithm.assets/image-20240102192757243.png)

## 基本数据结构

### 栈

先进后出

入栈和出栈都针对栈顶元素

#### 考法

一个栈的入栈序列是abcde，则栈的不可能的输出序列是

### 队列

先进先出

push入队：在队尾插入

pop出队：队头删除

#### 考法

- queue的插入push操作向右移动指针back一个单位,
- queue的删除pop操作不会真的删除（释放分配的内存），而是向右移动指针front一个单位(front+1)
- queue只有在析构时才会释放全部内存

![image-20231231144248519](algorithm.assets/image-20231231144248519.png)

### 优先队列

在优先队列中，元素被赋予优先级。

当访问元素时，具有最高优先级（当前队首）的元素最先删除

用二叉堆来实现，往队列中push入一个数或pop一个数，复杂度是O(logn)

## 位运算

![image-20231231152903064](algorithm.assets/image-20231231152903064.png)

![image-20231231152935803](algorithm.assets/image-20231231152935803.png)

**注意：右移的除法是程序里的除法，即对应数学中的$\lfloor x/2^k \ \rfloor$**

### 位运算技巧

![image-20231231153459547](algorithm.assets/image-20231231153459547.png)

### 应用

#### 状态压缩

位运算经常被用于状态压缩时的集合枚举

 比如现在有n件物品，编号从1到n，我们可以用一个n位的二进制数来表示每个物品取或者不取的状态，二进制数从右往左数第k位的01状态表示编号为k的物品取了还是没取（1表示取了， 0表示没取）

在枚举集合进行运算的过程当中，我们经常遇到要枚举当前集合的子集或者超集的情况

- 假设n=5，当前的状态$x=(11001)_2$
  - 其所有子集的二进制表示为： 11001, 11000, 10001, 10000, 01001, 01000, 00001,00000
  -  其所有超集的二进制表示为： 11001, 11011, 11101, 11111

![image-20240102192609835](algorithm.assets/image-20240102192609835.png)

## 哈希函数

定义：哈希函数实际上就是一种将你想要的关键字（比如姓名、电话、手机号等等），映射成方便查找的东西（一般为数字）的函数

- 好的哈希函数： 可以帮我们将一些关键字从大集合映射到较小的集合，然后我们可以将信息储存下来。比如存入一个数组里面，这个数组就成为哈希表
- 应用： 一些加密工作，需要将简单数字复杂化，就会有一种类似的反向哈希（加密）过程，比方区块链

### 哈希冲突解决方法

![image-20240102201006882](algorithm.assets/image-20240102201006882.png)

![image-20240102201030202](algorithm.assets/image-20240102201030202.png)

## 分治

> 1. **深度（Depth）：**
>    - **定义：** 一个节点的深度是指从根节点到该节点的路径的长度，即经过的边的数量。根节点的深度通常为 0。
>    - **性质：** 深度用于描述一个节点在树中的相对位置，越接近根节点的节点深度越小。
> 2. **层数（Level）：**
>    - **定义：** 一个节点的层数是指从根节点到该节点的路径上的边数，也就是深度加 1。根节点的层数通常为 1。
>    - **性质：** 层数表示节点在树中所处的层次，越接近根节点的节点层数越小。

### 归并排序

![image-20240102192926740](algorithm.assets/image-20240102192926740.png)

## 贪心

贪心法在解决问题的策略上目光短浅，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心法并不是从整体最优考虑，它所做出的选择只是在某种意义上的局部最优。

这种局部最优选择并不总能获得整体最优解（Optimal Solution），但通常能获得近似最优解（Near-Optimal Solution）。

### 贪心求解的问题的特征

当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质，也称此问题满足最优性原理。

**最优子结构**

当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质，也称此问题满足最优性原理

**贪心选择**  

问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来得到

## 动态规划

### 动态规划的两个性质

**最优子结构**

- 大问题的（最优）解可以由小问题的（最优）解推出。
- 在爬楼梯问题中，大问题f(n)的解可以由小问题f(n-2)和f(n-1)的解推出。注意在问题拆解过程中不能无限递归。

**重叠子问题**

-  子问题的空间要“很小”，也就是用来解原问题的递归算法可以反复的解同样的子问题，而不是总在产生新的子问题。
- 在爬楼梯问题中，要求出f(n)，只需要递归调用f(n-2)和f(n-1)，不会有新的问题产生

### 动态规划的两个元素

**状态**

求解过程进行到了哪一步，可以理解成一个子问题

**转移**

从一个状态（小问题）的（最优）解推导到另一个状态（大问题）的（最优）解的过程

### 动态规划和贪心算法的异同？

![image-20240102195215772](algorithm.assets/image-20240102195215772.png)

### 动态规划和分而治之的异同？    

![image-20240102195224765](algorithm.assets/image-20240102195224765.png)

## 图论

### 基本概念

> 这里仅放出最基本的概念，想要了解详细的，可以看docs文件夹下数据结构总结

![image-20231212112548073](algorithm.assets/image-20231212112548073.png)

![image-20231212112556795](algorithm.assets/image-20231212112556795.png)

**顶点的度(Degree of a Vertex)**

➢ 顶点𝒗的度𝒅𝒆𝒈(𝒗)是𝒗关联的边数

**有向图顶点的度分为入度和出度**

➢ 顶点𝒖的出度：起点为𝒖的边数

➢ 顶点𝒖的入度：终点为𝒖的边数

**图的度(Degree of a Graph)**

➢ 图𝑮 = < 𝑽, 𝑬 > 的度，是图各顶点的度之和， 𝒅𝒆𝒈(𝑮) = Σ𝒗∈ 𝑽 𝒅𝒆𝒈(𝒗)

![image-20231212112512590](algorithm.assets/image-20231212112512590.png)

#### 图的表示

![image-20231212112649218](algorithm.assets/image-20231212112649218.png)

![image-20231212112657829](algorithm.assets/image-20231212112657829.png)

### 拓扑排序

#### 基本概念

![image-20231212113245967](algorithm.assets/image-20231212113245967.png)

**拓扑排序（Topological Sorting, TopoSort）**

是对有向无环图（DAG，Directed Acyclic Graph）的**顶点**进行的一种线性排序，排序序列中每个顶点都会仅且只出现一次，且对所有有向边u→v，排完序后u都在v前面

> 大白话说就是：有向无环图表示多件事之间的先后关系，拓扑排序的作用就是将所有事的先后关系梳理清楚，梳理后的先后关系就是拓扑排序

**需要注意几点：**

- 拓扑排序是对**顶点**做排序，不是对边排序
- 只有有向无环图才存在拓扑排序，存在环就不存在拓扑排序
- **拓扑序不唯一**
  - 有n个顶点的有向无环图最多/最少存在几种合法的拓扑序列？  最多n!，最少1种  

#### 算法流程

> 拓扑排序可以看作一种贪心算法，每次取入度为0的顶点

入度为0的顶点v，说明这个顶点没有依赖（不存在另一顶点u，使得存在边u->v），因此这个顶点可以作为拓扑排序的起点

![image-20231212114902539](algorithm.assets/image-20231212114902539.png)

#### 算法优化

L和S可用同一个队列实现！只需要自己用数组模拟  

#### 算法实现