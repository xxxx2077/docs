## 数据库系统概述

### 基本概念

- **数据**：在计算机系统中，凡是能被计算机所接收和处理的各种字符、数字、图形、图像、视频及声音等都可称为数据。

- **信息**：经过加工处理并对人类客观行为产生影响的事物属性的表现形式。**信息是有用的数据，数据是信息的表现形式。**

- **数据处理**：将各种类型的数据转换成信息的过程，包括对数据的采集、整理、存储、分类 、排序、检索、维护、加工、统计和传输等一系列处理过程。数据处理的目的是从大量的、原始的数据中获得人们所需要的资料，并提取有用的数据成份，作为行为和决策的依据

- **数据管理**：**是数据处理的核心**，是指对数据进行组织、存储、分类、检索和维护等操作。随着计算机硬件和软件技术的发展，数据管理技术经历了人工管理、 文件管理和数据库系统几个阶段。

- **数据库 (Data Base, DB)**是按一定的组织形式存储在一起的相互关联的**数据的集合**

- **数据库管理系统(Data Base Management System, DBMS)**是数据库系统的核心部分，由**一个互相关联的数据的集合（数据库）**和**一组用以访问这些数据的程序**组成。主要目标是提供一个可以方便、高效地存取数据库信息的途径

  ![image-20231223094505967](数据库.assets/image-20231223094505967.png)



### 数据模型

数据库结构的基础是数据模型，一个描述数据、数据联系、数据语义、以及一致性约束的概念工具的集合  

- 关系模型：**用表的集合来表示数据和数据间的联系。表也称为关系**，每个表有多行多列，每列有唯一的列名，每行为一条记录。
  - 使用最广泛的数据模型  
- 实体-联系（Entity-Relationship， E-R）模型：描述实体对象以及它们之间的联系。
  - 广泛用于数据库设计
- 半结构化数据模型：允许在其数据定义中某些相同类型的数据项含有不同的属性集（JSON和XML被广泛用于表示半结构化数据）
- 基于对象的数据模型：面向对象的程序设计的发展 -> 面向对象的概念整合到关系数据库中（目前基于对象的数据模型视作对于关系模型的扩展）

### 数据抽象

![image-20231223095551140](数据库.assets/image-20231223095551140.png)

### 实例与数据库模式

数据库模式(schema)：数据库的总体设计

实例：特定时刻存储在数据库中的信息的集合

类比：数据库模式对应于程序中的变量声明，变量在某个时刻的值对应于数据库模式的一个实例

**补充：数据库模式(schema)**

数据库模式（Schema）是指数据库中存储和组织数据的结构和逻辑设计。它定义了数据库中的表、字段、关系、视图等元素，并规定了它们之间的关系和约束。数据库模式是数据库的蓝图，描述了数据的结构和组织方式，为数据库的创建、使用和维护提供了指导。

具体来说，数据库模式包括以下几个方面的定义：

1. **表定义：** 描述了数据库中每个表的结构，包括表名、字段名、数据类型、长度、约束条件等。
2. **字段定义：** 定义了表中的每个字段的属性，如数据类型、是否允许为空、默认值等。
3. **主键和外键：** 指定了表中哪些字段是主键，以及表与表之间的关系，包括外键关系。
4. **索引：** 定义了表中哪些字段上创建了索引，以提高检索性能。
5. **视图：** 定义了虚拟表，是一个基于一个或多个实际表的查询结果集。
6. **存储过程和触发器：** 定义了数据库中的存储过程和触发器，是预先定义的一些操作序列。

### 数据库语言

数据库系统提供了数据定义语言和数据操作语言，**数据定义语言和数据操纵语言不是两种互相独立的语言，它们只是构成了单一的数据库语言（例如SQL语言）的不同部分**

![image-20231223100221818](数据库.assets/image-20231223100221818.png)

**数据库存储和定义语言**：特定DDL的集合，这些特定的DDL用来说明数据库系统所采用的存储结构和访问方式

存储在数据库中的值必须满足某些一致性约束，DDL语言提供了指明这些约束的工具。

完整性约束：

- 域约束(domain constraint)：每个属性都必须对应一个所有可能的取值构成的域（例如整数型、字符型、日期/时间型）。声明一个属性属于某个具体的域就相当于约束它可以取的值
  - 域约束是完整性约束的最基本形式
- 引用完整性(referential integrity)：确保一个关系中给定属性集的取值也在另一关系的某一属性集中出现（例如外键）
  - 当引用完整性被违反时，通常的处理是：拒绝执行导致完整性被破坏的操作

### 数据库设计（重点）

数据库设计的主要内容是数据库模式的设计

数据库设计是指对于一个给定的应用环境，设计最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各类用户的应用需求。

- **概念设计**：重点在于描述数据以及它们之间的联系。从关系模型的角度来看，概念设计决定数据库中应该包括哪些数据， 以及如何组织这些属性到各个表中。使用实体-联系模型。

  - 具体而言，就是描述实体对象有哪些，对象有哪些特征/属性（包括标识实体的码），它们之间的关系是1对1，1对多，还是多对多

  - 这一阶段成果为**ER图**

    ![image-20231223102633655](数据库.assets/image-20231223102633655.png)

- **逻辑设计**：将高层次的概念模式遇到要使用的实现数据库系统的数据模型上。

  - 具体而言，就是将ER图转换为关系模式，包括有哪些实体，每个实体包含哪些属性，实体域实体之间的关系可通过哪些属性进行关联（例如主键/外键）。再根据关系规范化理论，将关系进行优化，消除数据冗余、插入异常、删除异常得到相对高级范式，满足数据的正常处理。

  - 这一阶段成果为关系模式

    ![image-20231223102701740](数据库.assets/image-20231223102701740.png)

- **物理设计**：设计数据库的物理特性， 包括文件组织形式以及内部存储结构。

  - 具体而言，就是将逻辑结构中优化过的关系模式转化成一张张数据库中的关系表，每个属性用合适的类型和长度存储，并设置主键和相关约束，即可完成数据的设计，满足应用程序对于数据的存储、插入、删除要求。

  - 这一阶段成果为若干关系表

    ![image-20231223102820837](数据库.assets/image-20231223102820837.png)

    ![image-20231223102810004](数据库.assets/image-20231223102810004.png)

#### 数据库设计的过程

![image-20231223102920517](数据库.assets/image-20231223102920517.png)

![image-20231223103140424](数据库.assets/image-20231223103140424.png)



![image-20231223103327436](数据库.assets/image-20231223103327436.png)

![image-20231223103336205](数据库.assets/image-20231223103336205.png)

![image-20231223103406662](数据库.assets/image-20231223103406662.png)



### 数据库引擎

数据库系统被划分为多个模块，每个模块完成整个系统的一个功能 。数据库系统的功能部件包括存储管理器、查询处理器和事务管理部件

#### 存储管理器

> 负责数据库中数据的存储、检索和更新

具体来说：

- 数据库系统中负责在**数据库中存储的低层数据与应用程序**以及**向系统提交的查询**之间提供接口的部件。
- 存储管理器负责与文件管理器进行交互。
- 原始数据通过操作系统提供的文件系统存储在磁盘上，<u>**存储管理器将各种DML语句翻译为底层文件系统命令。**</u>

存储管理器部件包括：

- 权限及完整性管理器：检测是否满足完整性约束，并检查试图访问数据的用户的权限
- 事务管理器：保证即使系统发生了故障，数据库也保持在一致的状态（持久性&一致性），并保证并发事务的执行不发生冲突（隔离性）。
-  文件管理器：管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构
- 缓冲区管理器：负责将数据从磁盘上取到内存中，并决定哪些数据应被缓冲存储在内存中
  - 数据库的关键部分，使数据库能够处理比内存大得多的数据

作为系统物理实现的一部分，存储管理器实现了以下数据结构：

- 数据文件：存储数据库的所有实际数据（所有记录）
- 数据字典：存储关于数据库结构的**元数据**，特别是数据库模式。元数据包含了关于数据库中各个数据元素（字段、表、关系等）的详细描述和定义。
- 索引：提供对数据项的快速访问

**补充：关于数据文件和数据字典的区别**

- **内容不同：** 数据文件包含实际的数据记录，而数据字典包含数据库结构的元数据描述。
- **用途不同：** 数据文件用于存储和维护实际的数据，而数据字典用于描述和维护数据库的结构和元数据。
- **级别不同：** 数据文件是数据库中最底层的存储单元，而数据字典是对数据库结构的高层抽象描述。
- **关注点不同：** 数据文件关注存储实际数据，而数据字典关注数据库结构和元数据的管理。

#### 查询处理器

> 负责数据检索

查询处理器部件包括：

- DDL解释器：解释DDL语句并将这些定义记录在数据字典中
- DML编译器：将查询语言中的DML语句翻译为包括一系列查询执行引擎能理解的低级指令的执行方案。
  - 一个查询通常可被翻译成给出相同结果的多个候选执行计划中的任何一个。DML编译器还进行查询优化，就是从几个候选执行计划中选出代价最小的哪个执行计划
- 查询执行引擎：执行由DML编译器产生的低级指令。

查询处理器的检索偏向于应用层，满足用户的查询方案

存储管理器的检索偏向于底层文件系统中的检索

查询处理器指挥存储管理器完成检索，查询处理器的一条低级指令可能需要存储管理器检索多次（类比于汇编和机器指令的区别）

#### 事务管理部件

> 负责完成原子性、一致性功能的操作

事务管理部件包括：

- 并发控制管理器：保证一致性
- 恢复管理器：保证原子性和持久性

### 数据库和应用体系结构

#### 系统体系结构

![image-20231223114616106](数据库.assets/image-20231223114616106.png)

#### 两层和三层体系结构

以前用两层体系结构，现在用三层体系结构

![image-20231223114256868](数据库.assets/image-20231223114256868.png)

### 数据库系统历史（了解即可）

![image-20231223115017032](数据库.assets/image-20231223115017032.png)

## 关系模型介绍

### 关系数据库的结构

![image-20231210155450740](数据库.assets/image-20231210155450740.png)

**层次模型（Hierarchical Model）**

表示数据间的从属关系结构，是一种以记录某一事物的类型为根结点的有向树结构

➢ 特点1：有且仅有一个根结点无父结点。

➢ 特点2：其它结点：向上仅有一个父结点，向下有若干子结点。

➢ 层次模型反映了实体间**一对多**的关系

**网状模型（Network Model）**

是层次模型的扩展，它表示多个从属关系的层次结构，呈现一种交叉关系的网络结构。

➢ 基本特征：一个父结点允许有多个子结点，一个子结点也可有多个父结点。

➢ 特点1：有一个以上结点无父结点。

➢ 特点2：至少有一个结点有多于一个的父结点。

➢ 网状模型表示了一种**多对多**的关系

**关系模型（Relational Model）** 

关系 (表)关系模型是目前应用广泛、 最重要的一种数据模型。最先提出关系模型的是数据库的鼻祖，美国IBM的研究员E.F.codd (1970年)。

关系模型的理论基础， 是基于数学中的关系代数的关系演算。

• 关系数据库由表(Table)的集合构成

• 表中的一行代表了一组值之间的某种联系。

### 关系模型

![image-20231210155744943](数据库.assets/image-20231210155744943.png)

原子性的域：一个域中的元素被认为是不可再分的单元，则该域是原子的

以address属性为例：

- 如果address能分成省、市、区，那我们认为address属性不是原子的，它的域不是原子域
- 如果address可以存放一组地址，因为address域中其中一个元素是address的集合，那我们认为address属性不是原子的，它的域不是原子域

**我们要求对所有关系r而言，r的所有属性的域都是原子的**

空值：标识值未知或不存在

### 数据库模式

![image-20231224111155506](数据库.assets/image-20231224111155506.png)

![image-20231224111207373](数据库.assets/image-20231224111207373.png)

![image-20231224111251064](数据库.assets/image-20231224111251064.png)

### 键（码,key）

码是整个关系的性质，不是单个元组的性质

- 候选码加上若干“无用”属性为超码，超码的任意超集还是超码
- 候选码是最小唯一标识属性集的单位，候选码的子集无法唯一标识属性集
- 主码是用户选定的候选码

表示方法：

- 主码放最前面，并且加上下划线

![image-20231224111429301](数据库.assets/image-20231224111429301.png)

**外码：**

注意外码一定是被引用属性集的**主键**

假设A的某个属性a引用B的主键b，那么a称为A的外键，A称为该外键约束的引用关系，B称为该外键约束的被引用关系（只要该属性为主键，则拥有该属性的关系就是被引用关系）

**引用完整性约束：**

要求A的某个属性a引用B的某个属性b时，a的取值一定会出现在b的取值里（相比于外键，放松了约束，不要求被引用关系的对应属性为主键）

![image-20231224111609362](数据库.assets/image-20231224111609362.png)

![image-20231224111717919](数据库.assets/image-20231224111717919.png)

### 模式图

一个带有主码和外码约束的数据库模式的表示形式  

![image-20231224113626571](数据库.assets/image-20231224113626571.png)

#### 模式图和ER图的区别：

模式图标明以下元素：

- 关系（表）名
- 属性集
- 主码和外码约束（用下划线和箭头表示）

ER图标明以下元素：

- 实体（集）名
- 属性集
- 主码和外码约束
- 实体之间的联系（描述关系是一对一，一对多还是多对多）
- 甚至更复杂一点，ER图还能表明关系的属性

可以参考`ChatGPT`回答：

1. **焦点不同：**
   - **模式图：** 主要关注数据库中的表、视图、索引等对象之间的关系，以及它们的组织结构。它展示了数据库的整体架构，但并不深入到具体的实体属性和关系。
   - **ER图：** 主要关注实体、实体之间的关系以及实体的属性。ER图强调数据模型中的概念，如实体、关系和属性。
2. **抽象级别：**
   - **模式图：** 更接近于数据库的物理实现，展示了表、字段、索引等实际的数据库对象。这使得模式图更适合数据库管理员和开发人员。
   - **ER图：** 更抽象，关注数据模型的概念层面，而不是具体的数据库对象。ER图更适合数据库设计者和业务分析师。
3. **内容表达：**
   - **模式图：** 包含表、列、键、索引等数据库对象的详细信息，以及它们之间的关系。
   - **ER图：** 主要包含实体、关系、属性等概念，强调业务实体之间的关系。
4. **目的：**
   - **模式图：** 用于展示数据库的物理结构，帮助数据库管理员实施和维护数据库。
   - **ER图：** 用于捕捉业务需求和概念模型，帮助数据库设计者创建一个符合业务需求的数据模型。
5. **应用领域：**
   - **模式图：** 主要在数据库实现和管理阶段使用，强调数据库的物理结构。
   - **ER图：** 主要在数据库设计阶段使用，强调业务需求和概念模型的构建。

简而言之，ER图偏向于概念设计，模式图偏向于逻辑乃至物理设计；ER图侧重实体之间的联系，模式图侧重数据表如何实现

#### 关系模式和关系数据库模式

模式图描述的就是关系模式，关系模式描述一个关系（表）如何组织，关系数据库模式就是关系模式的集合

![image-20231224114417873](数据库.assets/image-20231224114417873.png)

### 关系查询语言

关系代数语言是函数式查询语言

关系演算语言是声明式查询语言

**SQL语言同时包含命令式、函数式、声明式**

![image-20231224114523093](数据库.assets/image-20231224114523093.png)

### 关系代数

#### 概念简述

![image-20231210160045721](数据库.assets/image-20231210160045721.png)

关系代数运算， 按运算符的不同主要分为两类：

◼ 传统的集合运算：把关系看成元组的集合， 以元组作为集合中元素来进行运算， （行运算） 。其运算是从关系的“水平” 方向即行的角度进行的。 包括并、 差、 交和笛卡尔积等运算。

◼ 专门的关系运算：不仅涉及行运算， 也涉及列运算， （行和列的运算） 。 这种运算是为数据库的应用而引进的特殊运算。 包括选取、 投影、 连接和除法等运算。

#### 关系代数运算符对应表

![image-20231210160305091](数据库.assets/image-20231210160305091.png)

#### 关系代数基本运算

关系代数基本运算有：选择、投影、并、集合差、笛卡尔积和更名。

其中**选择、投影和更名运算**称为**一元运算**，因为它们对一个关系进行运算

**并、集合差、笛卡尔积**称为**二元运算**，因为它们对两个关系进行运算

##### 选择运算

这里的select与sql语句中的select不同，这里的select对应sql语句的where

![image-20231210160651833](数据库.assets/image-20231210160651833.png)

![image-20231210160757753](数据库.assets/image-20231210160757753.png)

![image-20231210160822604](数据库.assets/image-20231210160822604.png)

##### 投影运算

**选择**是从**行**的角度进行运算，而**投影**是从**列**的角度进行运算

![image-20231210160906298](数据库.assets/image-20231210160906298.png)

![image-20231210161048918](数据库.assets/image-20231210161048918.png)

![image-20231210161122230](数据库.assets/image-20231210161122230.png)

##### 笛卡尔积运算

笛卡尔积提出了对两个关系进行连接的雏形，之所以称为雏形，是因为笛卡尔积没有实现连接的两个关系相关属性一一对应，例如：

![image-20231210161311465](数据库.assets/image-20231210161311465.png)

上图中，笛卡尔积并没有实现R.A与S.A相同，而实际连接中，我们常常希望R.A与S.A相同

**概念简述**

简单来说，笛卡尔积就是关系A中的每个元组与关系B中的所有元组组合，假设A有m个元组，B有n个元组，那么AxB就有mn个元组

如果关系A和关系B中存在相同命名的属性，需要在其属性前加上关系前缀，例如：关系teacher和student都有属性ID，那么笛卡尔积中分别将其重命名为teacher.ID和student.ID

![image-20231210161240174](数据库.assets/image-20231210161240174.png)



![image-20231210161424134](数据库.assets/image-20231210161424134.png)

##### 连接运算

我们对笛卡尔积得到的结果进行限制，从而得到我们希望得到的连接结果

![image-20231210161622254](数据库.assets/image-20231210161622254.png)

![image-20231210163646179](数据库.assets/image-20231210163646179.png)

##### 自然连接

首先形成关系A和关系B的笛卡尔积，然后基于两个关系模式中都出现的属性上的相等性进行选择，最后去除重复属性

(大白话说就是：笛卡尔积之后，找出两列名字相同的属性列，从笛卡尔积结果中取出这两列值相同的元组，并且这几名字相同的属性列只取一列)

例如：

查询“找出所有教师的姓名，连同他们教的所有课程的course_id”

用自然连接表述为：

$\Pi_{name,course_id}({instructor}\Join {teaches})$

##### 集合运算

注意：

1. 集合运算会删除重复的元素（集合的性质）
2. 下图中指的“度” or “目”（这里的“目”是“n目关系”中的“目”，不是”n目运算“中的"目"）和书中的“元数”相同：一个关系的属性数量
3. 也就是说，两个集合必须满足：、
   1. 属性数量相同 
   2. 每个属性一一对应（对应的类型相同）

![image-20231210163753969](数据库.assets/image-20231210163753969.png)

![image-20231210163805443](数据库.assets/image-20231210163805443.png)

##### 更名运算

更名运算使用是为了在一个表达式里面多次使用同一个关系，通过为同一个关系使用不同的名称可以在一个表达式内重复使用这个关系

![image-20231210165310936](数据库.assets/image-20231210165310936.png)

还有另一种形式，该形式可以顺便命名运算结果的属性名称

![image-20231210165847101](数据库.assets/image-20231210165847101.png)

**等价查询**

![image-20231210165550683](数据库.assets/image-20231210165550683.png)

## SQL介绍

### SQL语言

SQL语言，全名为结构化查询语言(Structured Query Language,SQL)  

![image-20231224212313003](数据库.assets/image-20231224212313003.png)

**数据定义语言(Data Definition Language, DDL)**

是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。

DDL用来创建数据库中的各种对象，创建、删除、修改表的结构，比如表、视图、索引、同义词、聚簇等。

其主要功能是定义数据库对象，核心指令为create、 drop、 alter。

**事务控制语言(Transaction Control Language, TCL)**

用于管理数据库中的事务。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。

TCL经常被用于快速原型开发、脚本编程、 GUI和测试等方面。

TCL的核心指令为commit、 rollback。

**数据控制语言 (Data Control Language, DCL)**

是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。

DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。

DCL的核心指令为grant、 revoke。

**数据操纵语言(Data Manipulation Language, DML)**

实现对数据库的基本操作，对数据库其中的对象和数据运行访问工作的语言。DML的主要功能是访问数据，因此其语法都是以读写数据库为主。

DML的核心指令为insert、 update、 delete。

**数据查询语言(Data Query Language, DQL)**

是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句。

DQL的核心指令为select。通常与关键字from、 where、 group by、 having、 order by等一起使用，组成查询语句。

### SQL数据类型

> 在讨论数据类型时，使用了精度、小数位数和长度三个概念，前两个概念是针对数值型数据的：
>
> - 精度： 指数值数据中所存储的十进制数据的总位数。
> - 小数位数： 指数值数据中小数点右边可以有的数字位数的最大值。例如，数值数据3560.697的精度是7，小数位数是3。
> - 长度： 指存储数据所使用的字节数。

![image-20231224212701887](数据库.assets/image-20231224212701887.png)

![image-20231224212724675](数据库.assets/image-20231224212724675.png)

decimal(3,2)表示三位长度，其中小数点右边有2位，如4.55

![image-20231224213010108](数据库.assets/image-20231224213010108.png)

![image-20231224213039969](数据库.assets/image-20231224213039969.png)

![image-20231224213048093](数据库.assets/image-20231224213048093.png)

![image-20231224213212841](数据库.assets/image-20231224213212841.png)

![image-20231224213237103](数据库.assets/image-20231224213237103.png)

![image-20231224213337062](数据库.assets/image-20231224213337062.png)

![image-20231224213445363](数据库.assets/image-20231224213445363.png)

![image-20231224213551509](数据库.assets/image-20231224213551509.png)

![image-20231224213622013](数据库.assets/image-20231224213622013.png)

### SQL数据定义语言

一些小总结如下：

- 创建：create database/table+db名/table名
- 修改：alter table +db名/table名+操作
- 删除：drop database/table +db名/table名

表的增删改查

- 增：insert table
- 删：delete from table
- 改：update table
- 查：select

### SQL数据查询语言（重点）

![image-20231226110638554](数据库.assets/image-20231226110638554.png)

![image-20231226110707327](数据库.assets/image-20231226110707327.png)

#### FROM

![image-20231226110747991](数据库.assets/image-20231226110747991.png)

#### WHERE

![image-20231226110811865](数据库.assets/image-20231226110811865.png)

#### DISTINCT

![image-20231226110844262](数据库.assets/image-20231226110844262.png)

#### 附加基本运算

![image-20231226110919658](数据库.assets/image-20231226110919658.png)

![image-20231226110929869](数据库.assets/image-20231226110929869.png)

![image-20231226111007251](数据库.assets/image-20231226111007251.png)

#### ORDER BY

![image-20231226111033264](数据库.assets/image-20231226111033264.png)

#### LIMIT

![image-20231226111212236](数据库.assets/image-20231226111212236.png)

#### 集合运算

##### 并集UNION

![image-20231226111727309](数据库.assets/image-20231226111727309.png)

![image-20231226111734411](数据库.assets/image-20231226111734411.png)

##### 交集INTERSECT

示例里面有错误：CScore>4

![image-20231226111826404](数据库.assets/image-20231226111826404.png)

##### 差集Except

示例里面有错误：CScore<=4

![image-20231226111846335](数据库.assets/image-20231226111846335.png)

##### NULL

如果有一个操作数的结果是NULL，则大多数运算符的求值结果也会是NULL。

当NULL值表达式在函数中被用于操作数时，运算符将产生NULL。

WHERE子句也有相同的情况， WHERE子句会丢弃那些条件不是TRUE的记录

#### 聚集函数

![image-20231226112925220](数据库.assets/image-20231226112925220.png)

![image-20231226113027576](数据库.assets/image-20231226113027576.png)

![image-20231226223008044](数据库.assets/image-20231226223008044.png)

![image-20231226223037186](数据库.assets/image-20231226223037186.png)

![image-20231226225435891](数据库.assets/image-20231226225435891.png)

### SQL连接专题

> select from where结构中：
>
> - from 表示将多个关系通过笛卡尔积连接
> - where表示对笛卡尔积进行特定条件的选择（关系代数的选择运算）
> - select表示结果的投影（关系代数的投影运算）

![image-20231226230028053](数据库.assets/image-20231226230028053.png)

![image-20231226230126250](数据库.assets/image-20231226230126250.png)



#### 内连接

```
(inner)join on
```

内连接分三种： 等值连接、非等值连接、自然连接

> 等值连接与自然连接的区别  
>
> 1、自然连接一定是等值连接，但等值连接不一定是自然连接。
>
> 2、等值连接要求相等的值，不一定是公共属性；而自然连接要求相等的值必须是公共属性。
>
> - 如果等值连接要求相等的值是公共属性，此时等值连接就是自然连接
>
> 3、等值连接不把重复的属性除去；而自然连接要把重复的属性除去

##### 等值连接

在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列， 包括其中的重复列。

![image-20231227174626853](数据库.assets/image-20231227174626853.png)

##### 非等值连接

在连接条件使用除等于号(=) 运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括>、 >=、 <=、 <、 !>、 !<和!=。

##### 自然连接

在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列， 并**删除连接表中的重复列。**

- 如果待连接的关系A和关系B有多个公共属性，那么自然连接要求这些公共属性取值都一一对应相等。

 ![image-20231227174617826](数据库.assets/image-20231227174617826.png)

#### 外连接

![image-20231227174729745](数据库.assets/image-20231227174729745.png)

![image-20231227174713568](数据库.assets/image-20231227174713568.png)

#### 交叉连接

对饮关系代数的笛卡尔积

![image-20231227174811851](数据库.assets/image-20231227174811851.png)

#### 自连接

通过给同一张表取不同别名实现逻辑上的不同表

![image-20231227174916376](数据库.assets/image-20231227174916376.png)

## 视图

(1) 视图是一个**虚拟表**，其内容来自对表查询的基础上。

- 视图不占用磁盘空间，只是一个逻辑简化设计

(2) 视图的行和列数据来自于定义视图的查询所引用的表，并在引用表时动态生成。

- **这里”动态生成“的意思是：视图以创建视图时定义的查询语句的实际形式存储在数据表中，每当用到该视图的时候，都会调用创建该视图的查询语句完成查询，从而获得查询结果**

(3) 视图的结构和显示的数据行并没有实际地以视图结构存储在数据库中，而是存储在视图所引用的基本表中。

(4) 视图集中、简化和自定义每个用户对数据库的不同认识， 是数据库的外模式。用户可以将数据库中自己感兴趣的特定数据展现在视图中。

(5) 视图也可作为一种安全机制，允许用户通过视图访问数据，而不授予用户直接访问视图基础表的权限。

![image-20231227175311306](数据库.assets/image-20231227175311306.png)

### 视图更新

视图更新条件：

1、视图必须未涉及连接**(from 后只有一个表）**；

2、视图必须不包含GROUP BY子句；

3、视图不能包含任何组合函数；

4、不能使用DISTINCT子句；

5、 WHERE子句不能包含表的嵌套引用

![image-20231227175757837](数据库.assets/image-20231227175757837.png)

### 视图的优缺点

视图的优点

- 查询的简单性：将复杂的查询定义为视图， 保留用户所关心的数据内容， 简化用户浏览和操作。
- 安全保护：视图可以设置不同用户对数据的访问权限。
- 屏蔽数据的复杂性：简化用户对数据库的操作， 还可以使用视图重新组织数据。

视图的缺点

- 性能降低
- 修改的限制

![image-20231227175902676](数据库.assets/image-20231227175902676.png)

## 完整性约束

> 完整性约束防止对数据的意外破坏

### 域完整性约束

每一个属性的值应该是其值域中的值

指定一个值域的通常方法是指定一个数据类型，如整型、实型、字符型等，从而属性的值都应该属于该数据类型。

除此之外，一个属性的值能否为空值（NULL），也是域完整性约束的内容。

### 实体完整性约束

关系中主码的值不能为NULL，每个元组的主码值应是唯一的。

主码包含的所有属性都不能取空值 

### **引用完整性约束**

引用完整性约束是不同关系之间或同一关系的不同元组间的约束，它规定不允许引用不存在的元组。

设F是关系R的一个或一组属性。如果F与关系S的主码K相对应，则称F是关系R的**外码**（foreign key），并且称关系S为**基本关系(基本表)**，关系R为**依赖关系(依赖表)**。

➢引用完整性约束规定依赖关系R中外码F的取值只允许两种可能：**①** 空值；**②** 等于基本关系S中某个元组的 K值（主码值）。

➢在引用完整性约束中，基本关系S与依赖关系R可以是同一个关系。

### 用户自定义完整性 (Check子句)

![image-20231227185409933](数据库.assets/image-20231227185409933.png)

### SQL用户和授权

![image-20231227185640718](数据库.assets/image-20231227185640718.png)

## 函数&存储过程&触发器

### 函数和过程的语法

![image-20231227192707613](数据库.assets/image-20231227192707613.png)

![image-20231227192827629](数据库.assets/image-20231227192827629.png)

![image-20231227192838506](数据库.assets/image-20231227192838506.png)

![image-20231227192849823](数据库.assets/image-20231227192849823.png)

![image-20231227193126421](数据库.assets/image-20231227193126421.png)

![image-20231227193212036](数据库.assets/image-20231227193212036.png)

![image-20231227193356876](数据库.assets/image-20231227193356876.png)

![image-20231227193438725](数据库.assets/image-20231227193438725.png)



### 函数

#### 内置函数

![image-20231227190109817](数据库.assets/image-20231227190109817.png)

![image-20231227190302849](数据库.assets/image-20231227190302849.png)

#### 自定义函数

变量用declare定义，用set赋值

用begin和end包住复合查询语句：

```
begin
	select复合语句
end
```

![image-20231227192028758](数据库.assets/image-20231227192028758.png)

### 存储过程

存储过程就是存储在数据库当中的可以执行特定工作（查询和更新）的一组SQL 代码的程序段。

**与自定义函数的区别：**

自定义函数有且只有一个返回值，就像普通的函数一样，可以直接在表达式中嵌入调用。

存储过程可以没有返回值，也可以有任意个输出参数，必须单独调用。

➢ 执行的本质都一样。只是函数有如只能返回一个变量的限制。而存储过程可以返回多个。

➢ 而函数是可以嵌入在sql中使用的，可以在select中调用，而存储过程不行。

➢ 函数限制比较多，比如不能用临时表，只能用表变量。而存储过程的限制相对就比较少。

➢ 一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。

➢ 对于存储过程来说可以返回参数，而函数只能返回值或者表对象

**存储过程的优点**

1. 存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次，所以使用存储过程可提高数据库执行速度。
2. 当对数据库进行复杂操作时（如对多个表进行Update、Insert、Query、Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。
3. 存储过程可以重复使用，可减少数据库开发人员的工作量。
4. 安全性高，可设定只有某此用户才具有对指定存储过程的使用权。

![image-20231227192357695](数据库.assets/image-20231227192357695.png)

### 触发器

触发器(trigger)是作为对数据库修改的连带效果而由系统自动执行的一条语句

触发器是特定事件出现的时候，自动执行的代码块。

定义触发器需要指明

- 什么时候执行触发器
- 当触发器执行时采取的动作

类似于存储过程，触发器与存储过程的区别在于:

- 存储过程是由用户或应用程序显式调用的,而触发器是不能被直接调用的。

触发器是在对表进行插入、更新或删除操作时自动执行的存储过程，触发器通常用于强制业务规则

触发器还是一个特殊的事务单元，当出现错误时，可以执行ROLLBACK TRANSACTION回滚撤销操作

触发器一般都需要使用临时表： deleted表和inserted表，它们存放了被删除或插入的记录行副本

触发器类型：

– DML触发器

– DDL触发器

#### 触发器的执行原理

![image-20231227212357125](数据库.assets/image-20231227212357125.png)

![image-20231227212502195](数据库.assets/image-20231227212502195.png)

#### DML触发器

定义： 当数据库服务器中发生数据操作语言（DML）事件时要执行的操作。

DML数据定义语言： 对已存在数据库表进行元组插入，删除，修改。

![image-20231227211945868](数据库.assets/image-20231227211945868.png)

![image-20231227212054055](数据库.assets/image-20231227212054055.png)

![image-20231227212103305](数据库.assets/image-20231227212103305.png)

![image-20231227212124086](数据库.assets/image-20231227212124086.png)

#### DDL触发器

定义： 当服务器或者数据库中发生数据定义语言（DDL）时触发器将被调用。

DDL数据定义语言： 创建，修改或删除数据库中各种对象，包括表，视图，索引等。

#### 触发器其他操作

![image-20231227212719184](数据库.assets/image-20231227212719184.png)

![image-20231227212731715](数据库.assets/image-20231227212731715.png)

#### 不能在触发器中使用的语句

![image-20231227212650330](数据库.assets/image-20231227212650330.png)

## E-R模式数据库设计  

![image-20231228164542143](数据库.assets/image-20231228164542143.png)



### 需求分析

![image-20231228165953622](数据库.assets/image-20231228165953622.png)

![image-20231228170047599](数据库.assets/image-20231228170047599.png)



![image-20231228170559742](数据库.assets/image-20231228170559742.png)

![image-20231228170605630](数据库.assets/image-20231228170605630.png)

![image-20231228170615239](数据库.assets/image-20231228170615239.png)

![image-20231228170625829](数据库.assets/image-20231228170625829.png)

![image-20231228170632804](数据库.assets/image-20231228170632804.png)

### 实体-联系模型

![image-20231228170914534](数据库.assets/image-20231228170914534.png)

![image-20231228171117245](数据库.assets/image-20231228171117245.png)

![image-20231228171916569](数据库.assets/image-20231228171916569.png)

![image-20231228171928756](数据库.assets/image-20231228171928756.png)



![image-20231228172357081](数据库.assets/image-20231228172357081.png)

实体集的属性应在第一次出现时显示，后续出现的实体集应显示为不带属性的

### 复杂属性

**注意看图示的属性表示方法**

![image-20231228174034946](数据库.assets/image-20231228174034946.png)

### 映射基数、弱实体集

#### 映射基数

- 一对一：A中的一个实体至多与B中的一个实体相关联，而B中的一个实体也至多与A中的一个实体相关联
- 一对多：A中的一个实体可以与B中任意数量（零个或多个）实体相关联，而B中的一个实体至多与A中的一个实体相关联
- 多对一：A中的一个实体至多与B中的一个实体相关联，而B中的一个实体可以与A中任意数量（零个或多个）实体相关联
- 多对多：A中的一个实体可以与B中任意数量（零个或多个）实体相关联，而B中的一个实体可以与A中任意数量（零个或多个）实体相关联

![image-20231228174206100](数据库.assets/image-20231228174206100.png)

**有向线段从n端指向1端**

如instructor->student表示：n个教师对应1个学生，即1个学生可以选多个导师，而1个导师只能带1个学生

**无向线段没有箭头，也就没有1端，即表示多对多**

![image-20231228174227852](数据库.assets/image-20231228174227852.png)

![image-20231228175334566](数据库.assets/image-20231228175334566.png)

#### 主码

主码用于区分实体集中的不同实体和给定联系集中的不同联系

##### 实体集的主码

关系模式中的超码、候选码和主码的概念同样适用于实体集

##### 联系集的主码

假设R是一个涉及实体集$E_1,E_2,...,E_n$的联系集，primary-key($E_i$)表示构成实体集$E_i$的主码的属性集合

- 假设所有主码的属性名互不相同

  - 如果联系集R没有属性

    属性集合`primary-key`$primary-key(E_1) \bigcup primary-key(E_2) \bigcup primary-key(E_2) \bigcup ... \bigcup primary-key(E_n)$

    唯一标识联系集R中的一个联系

  - 如果联系集R有属性{$a_1,a_2,...,a_n$}

    属性集合`primary-key`$primary-key(E_1) \bigcup primary-key(E_2) \bigcup primary-key(E_2) \bigcup ... \bigcup primary-key(E_n) \bigcup \{a_1,a_2,...,a_n\}$

    唯一标识联系集R中的一个联系

- 假设所有主码的属性名不是互不相同的，而是存在同名属性，那么使用$E_i.aj$的形式使用该属性名

以上两种情况，**属性集合`primary-key`为联系集的超码，因为它唯一表示了联系集中的每个联系**

**我们可以根据映射基数对选择联系集的主码：**

- 一对一：任一参与实体集的主码都构成最小超码，并且可以选择任意一个作为联系集的主码
- 一对多&多对一：多的一方的主码是最小的超码，并被用作主码
- 多对多：像上面讨论的，取两个实体集主码的并集作为主码

#### 从实体集中删除冗余属性

在实体集之间，如果存在关联，那么关联的两个实体集不应该存在公共属性，需要删除这种冗余属性。我们将这种关联以联系集的方式给出。

删除的方式：如果实体集A的属性a是主码，实体集B的属性b不是主码，A和B通过a和b相关联，并且a和b为同一属性，那么删除b

![image-20231228192438792](数据库.assets/image-20231228192438792.png)

#### 弱实体集

> 使用弱实体集的条件：
>
> 1. **关系B中当前所有属性唯一标识一个关系**，如section属性集{course_id,sec_id,semester,year}唯一标识section
> 2. 关系A和关系B通过同一属性相关联，如section属性{course_id,sec_id,semester,year}，course属性{course_id,title,credits}通过属性course_id相关联
>
> 这两个条件保证使用弱实体集后，标识性实体集的主码及称为分辨符属性的额外属性来唯一标识弱实体，而不是将主码与弱实体相关联

如下图，原本section可以拥有属性{course_id,sec_id,semester,year}，course可拥有属性{course_id,title,credits}，然后两个实体集之间构造联系集sec_course，但我们发现存在属性的冗余：两者都拥有属性course_id。

如果去掉联系集sec_course就不会有属性冗余，但这使得两者之间的联系没有被显式指出，而是通过公共同名属性course_id暗示两个实体集具有联系，而这不是我们想要的，我们想要：只要实体之间有关联，就画出联系集

于是提出了弱实体集

![image-20231228202842670](数据库.assets/image-20231228202842670.png)

**弱实体集的存在依赖于另一个实体集，称为共识性实体集**

**非弱实体集的实体集被称为强实体集**

每个弱实体必须和一个标识性实体相关联，即弱实体集被称为存在依赖于标识实体集。标识实体集被称为拥有它所标识的弱实体集。将**弱实体集与标识性实体集相关联的联系被称为标识性联系**

标识性联系是从弱实体集到标识性实体集的**多对一联系**，并且**弱实体集在联系中的参与是全部的**。**标识性联系集不应该有任何描述性属性**，因为任何这样的属性都可以与弱实体集相关联。

我们使用标识性实体集的主码及称为分辨符属性的额外属性来唯一标识弱实体，而不是将主码与弱实体相关联

- 上图中，section的标识性实体集是course，将section实体和它们对应的course实体关联在一起的sec_course联系是标识性联系。section的主码由course的主码course_id加上弱实体集的分辨符(sec_id,semester,year)构成，因此**主码为{course_id,sec_id,semester,year}**

**一个弱实体集可以作为属主参与与另一个弱实体集的标识性联系，也可能与不止一个标识性实体集相关联。**

- 弱实体集的主码由标识性实体集主码的并集加上弱实体集的分辨符组成

#### E-R模型设计

![image-20240103163548916](数据库.assets/image-20240103163548916.png)

#### 将E-R图转换为关系模式

![image-20231228210519431](数据库.assets/image-20231228210519431.png)

> 以下介绍转换规则，具体例子见黑书P181-183

##### 强实体集转换规则

1. 若强实体集只有简单属性{$a_1,a_2,...,a_n$},其中$a_1$为主码，则强实体集直接转换为关系模式{$a_1,a_2,...,a_n$}，同样地，该关系模式中$a_1$为主码

2. 若强实体集还有复合属性$b_n(a_1,a_2,...,a_n)$，则将复合属性拆开，不记录复合属性$b_n$，而是记录组成复合属性的简单属性$a_1,a_2,...,a_n$

3. 若强实体集A具有多值属性M，则需要再创建一个关系模式R。该关系模式属性集由以下部分组成：

   - 多值属性M所在的实体集或联系集的主码的属性$a_1$
   - 多值属性M，我们在R中记作$a_2$

   关系模式R的主键由以上两部分构成，即R={$\underline{a_1,a_2}$}

   关系模式R还需要建立外码约束：实体集**主码生成的属性**必须引用根据实体集生成的关系，也就是说，$a_1$外键引用实体集A对应的关系模式

   最终R表示为R={<u>*a1,*a2</u>},主键为{$\underline{a_1,a_2}$}，外键为a1

   - **特别地，如果强实体集A只有一个主码属性B和多值属性M，由于A转为关系模式$R_A$后只有主码属性B（多值属性M被分去了新的关系模式R，R包含主码属性B和属性M’(M‘是多值属性中的一个属性值)），那么我们可以删去$R_A$，而保留关系模式R**

##### 弱实体集转换规则

假设弱实体集A拥有属性集{$a_1,a_2,...,a_n$}，弱实体集A依赖于强实体集B，强实体集B的主码为{$b_1,b_2,...,b_n$}

假设弱实体集A转换得到的关系模式为$R_A$

那么$R_A$的属性集为$\{a_1,a_2,...,a_n\}\bigcup\{b_1,b_2,...,b_n\}$，且主码为$\{a_1,a_2,...,a_n\}\bigcup\{b_1,b_2,...,b_n\}$

同时$R_A$具有外码约束，外键$\{b_1,b_2,...,b_n\}$引用强实体集B对应的关系模式$R_B$

##### 联系集转换规则

设联系集A，$\{a_1,a_2,...,a_n\}$是每个参与R的实体集的主码的并集所构成的属性的集合，并且R的描述性属性（如果有）为{$b_1,b_2,...,b_n$}

假设联系集A转换得到的关系模式为$R_A$

那么$R_A$的属性集为$\{a_1,a_2,...,a_n\}\bigcup\{b_1,b_2,...,b_n\}$，且联系集的主码为该关系模式的主码

（联系集主码选取方法简单来说就是：**有多选多，无多或都多随便选**。细节详见主码章）

同时$R_A$具有外码约束，由实体集得到的属性的并集$\{a_1,a_2,...,a_n\}$为$R_A$的外码，其中$a_i$为$R_A$的外码之一，引用对应实体集$E_i$的主码$e_i$

##### 模式的冗余

一般而言，连接弱实体集与其对应的强实体集的联系集的模式是冗余的，并且在基于E-R图的关系数据库设计中不必给出

##### 模式的合并

- 多对一：假设实体集A到实体集B的多对一联系集AB，假设A在该联系中的参与是全部的，那么**我们可以将A和AB的模式合并为单个模式，它由两个模式A和AB的属性的并集构成，合并后模式的主码为：”多“的一方的主码，即A的主码**

- 一对一：联系集的关系模式可以跟参与联系的任何一个实体集的模式进行合并

如果是部分合并，也当作全部参与来合并，只是没有参与的实体在对应的关联属性上存放空值即可

**合并后关联属性仍然具有外码约束**

## 关系数据库设计

### 函数依赖理论  

数据依赖

- 一个关系内部属性与属性之间的约束关系
- 语义的体现  

数据依赖的类型  

- 函数依赖（Functional Dependency，简记为FD）  
- 多值依赖（Multivalued Dependency，简记为MVD）  
- 其他  

#### 函数依赖

数学中的 函数y = f(x) , 当 x 的值确定，函数值 y 就可唯一确定。

定义： 设R(U)是一个属性集U上的关系模式， X和Y是U的子集。若对于R（U）的任意一个可能的关系r， r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，记作X -> Y

**换句话说，Y=f(X)，f表示某种依赖，X上的属性值相等得到Y上的属性值也相等**

![image-20231230192748870](数据库.assets/image-20231230192748870.png)

**1、完全函数依赖**

设X,Y是关系R的两个属性集合， X’是X的真子集，存在X→Y，但对每一个X’都有X’ !→Y ，则称Y完全函数依赖于X。

**2、部分函数依赖**

设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’ →Y，则称Y部分函数依赖于X。

**3、传递函数依赖**

设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。

![image-20231230203049950](数据库.assets/image-20231230203049950.png)

示例： 有⼀个关系模式S(Sno,Sname,Cno,Grade)

完全函数依赖： 如果想知道某位学⽣的某⼀门课的成绩Grade，那必须得同时知道他的学号Sno和课程号Cno。但如果只知道⼀部分信息，⽐如他的Sno或者Cno可以吗？答案是不⾏的！此时称Y[Grade]完全依赖于X[Sno,Cno]。

部分函数依赖： 如果想知道某位学⽣的姓名Sname，那知道他的学号Sno就可以了。也就是说Y[Sname]只函数依赖于X[Sno,Cno]中的⼦集x[Sno]，此时称Y部分函数依赖于X。

#### 闭包  

![image-20231230203236317](数据库.assets/image-20231230203236317.png)

#### 关系范式

范式（Normal Form, NF） 是指规范化的关系模式。由规范化程度不同，就产生了不同的范式。根据满足条件的不同，经常称某一关系模式Ｒ为“第几范式” 。

关系规范化理论是研究如何将一个不十分合理的关系模型转化为一个最佳的数据关系模型的理论，它是围绕范式而建立的

![image-20231230204007466](数据库.assets/image-20231230204007466.png)

##### 第一范式(1NF)

![image-20231230204050988](数据库.assets/image-20231230204050988.png)



##### 第二范式 (2NF)  

如果一个关系满足1NF，并且除了主键以外的其他列，都依赖与该主键，则满足第二范式（2NF）

第二范式要求每个表只描述一件事情

首先， 它必须**满足第一范式**， 并且**不存在非主关键字对主关键字的部分函数依赖**。也就是说：所有的非主关键字都完全函数依赖于主关键字， 不存在只与主关键字中的部分属性的函数依赖。

![image-20231230204241186](数据库.assets/image-20231230204241186.png)

![image-20231230211515760](数据库.assets/image-20231230211515760.png)

##### 第三范式（3NF）

如果一个关系满足2NF，并且除了主键以外的其他列都不传递依赖于主键列，则满足第三范式（3NF）Armstrong公理定义的传递依赖：ABC是关系R的3个属性，如果A→B且B→C，可得出A→ C首先， 它必须满足第二范式， 并且不存在非主关键字对主键的传递函数依赖。也就是说：所有的非主关键字都直接函数依赖于主关键字， 不存在间接地函数依赖于主关键字

##### 例子

[Mysql - 什么是三大范式（通俗详解） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/590135927)

##### Boyce-Codd范式 (BCNF)  

![image-20240103161226504](数据库.assets/image-20240103161226504.png)



## 复杂数据类型

### 半结构化数据  

**半结构化数据的特征**  

灵活的模式

- 宽列表示：允许每个元组具有不同的属性集，可以随时添加新属性
- 稀疏列表示：模式有一组固定但很大的属性，每个元组只使用它所需要的属性，剩下的则为空值

多值数据类型

- 允许将集合、多值集合或数组存储为属性值
  - 示例：兴趣集{篮球、西甲、烹饪、动漫、爵士乐}

**键值映射（或简称映射）**

-  存储一组键值对
- 例如： {(brand, Apple), (ID, MacBook Air), (size, 13), (color, silver)}
- 映射操作： put(key, value), get(key), delete(key)）

 阵列/数组

- 广泛用于科学和监测应用

#### 嵌套数据类型  

##### JavaScript对象表示法 (JavaScript Object Notion,JSON)

![image-20231231091544001](数据库.assets/image-20231231091544001.png)

##### 可扩展标记语言（eXtensible Markup Language,XML）

![image-20231231091603332](数据库.assets/image-20231231091603332.png)

##### 知识表示 (Knowledge Representation)  

![image-20231231092338220](数据库.assets/image-20231231092338220.png)

## 应用程序开发

![image-20231231092658033](数据库.assets/image-20231231092658033.png)

![image-20231231092836366](数据库.assets/image-20231231092836366.png)

![image-20231231092845103](数据库.assets/image-20231231092845103.png)

![image-20231231092936584](数据库.assets/image-20231231092936584.png)

![image-20231231093030167](数据库.assets/image-20231231093030167.png)

## 物理存储系统和文件存储结构  

### 磁盘

#### 磁盘物理结构

磁盘被逻辑地分为磁道，磁道又被划分为扇区。

- **扇区**：扇区是从磁盘读出和读入的最小单位，扇区的大小通常为512字节
- **读写头**：读写头将信息磁化存储到扇区上
  - 磁盘盘片的每一面都有一个读写头，读写头通过在盘片上移动来访问不同的磁道。
- **磁盘臂**：所有磁道的读写头被安装在一个被称为磁盘臂的单独装置上，并且一起移动。
- **磁头-磁盘装置**：安装在转轴上的磁盘盘片和安装在磁盘臂的读写头合在一起被称为磁头-磁盘装置。
- **柱面**：因为所有盘片上的读写头是一起移动的，所以当一个盘片的读写头位于第i条磁道上，所有其他盘片的读写头也都在它们相应盘片的第i条磁道上，由此，所有盘片的第i条磁道合在一起被称为第i个柱面

![image-20231231093831361](数据库.assets/image-20231231093831361.png)

![image-20231231094245656](数据库.assets/image-20231231094245656.png)

##### 磁盘块

磁盘块是存储分配和检索的逻辑单元。

数据以块为单位在磁盘和主存之间传输。

术语“页面”通常指块

磁盘上的地址

从磁盘请求块的序列可以分为顺序访问模式和随机访问模式

**顺序访问模式**

连续的请求都是针对连续编号的块，这些块位于相同的磁道上或相邻的磁道上。为了在顺序访问中读取块，对于第一个块可能需要磁盘寻道，但后续的请求要么不需要寻道，要么需要向相邻的磁道寻道，这比更远的磁道寻道要快。

**在顺序访问模式下，数据传输速率是最高的，因为寻道时间最短**

**随机访问模式**

连续的请求是针对随机分布在磁盘上的块的。每一个这样的请求都需要一次寻道。

#### 磁盘的性能指标

**访问时间**

从发出读或写请求到数据开始传输之间的时间

- 为了访问（读或写）磁盘上指定扇区的数据，磁盘臂必须先移动到正确磁道的上方，然后等待磁盘旋转，直到指定的扇区出现在它下方，之后数据开始传输。
- **访问时间是寻道时间和延迟时间的总和**

**寻道时间**

磁盘臂重定位的时间，随磁盘臂必须移动距离的增大而增大。

较小的磁盘因为读写头需要移动的距离较短而通常有较短的寻道时间

**平均寻道时间**

寻道时间的平均值，是在一个均匀分布的随机请求序列上测量得出的。

- 如果所有的磁道包含相同数量的扇区，同时我们忽略读写头开始移动和结束移动所花费的时间，那么我们可以得到平均寻道时间是最坏情况下寻道时间的**三分之一**。
- 考虑上面忽略的因素，平均寻道时间大约是最大寻道时间的**一半**。

**旋转延迟时间**

一旦读写头到达所需的磁道，等待被访问的磁道出现在读写头所花费的时间称为旋转延迟时间

**平均（旋转）延迟时间**

平均情况下，磁盘需要旋转半周才能使所要访问的扇区的开始处出现在读写方的下方，因此磁盘的平均延迟时间是磁盘旋转一整周时间的**一半**

**数据传输率**

从磁盘获取数据或者向磁盘存储数据的速率

磁盘的内测磁道传输率明显低于最大传输率，因为它们具有较少的扇区

**每秒I/O操作**

一秒钟内可以由磁盘满足的**随机块访问数量**，取决于磁盘的访问时间、块的规模和数据传输速率

**平均故障时间**

平均说来我们可以期望系统无任何故障连续运行的时间量。

#### 磁盘块与扇区的区别和联系

**什么是扇区？**

<u>盘面中一圈圈灰色同心圆为一条条磁道</u>，从圆心向外画直线，可以将磁道划分为若干个弧段，<u>每个磁道上一个弧段被称之为一个扇区</u>。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）

**什么是磁盘块？**

<u>操作系统与磁盘之间交流的最小单位就是磁盘块，它是一个虚拟的概念</u>。是对于操作系统（软件）来说有意义的概念。由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在<u>系统中认为块是最小的单位。</u>

**磁盘的读写基本单位是什么？**

<u>读写基本单位是扇区。磁盘的原理，物理实现，磁盘控制器是按照扇区这个单位读取等操作数据的</u>。此题问磁盘的读写，和操作系统没有关系，千万不要联系到操作系统层面去了。

**磁盘块与扇区的大小关系**

既然磁盘块是一个虚拟概念。是操作系统自己＂杜撰＂的。软件的概念，不是真实的。所以大小由操作系统决定，操作系统可以配置一个块多大。一个块大小=一个扇区大小*2的n次方。 N是可以修改的。

**块与页的关系**

操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块” 的概念，都需要一种虚拟的基本单位。所以，与**内存**操作，是虚拟一个**页**的概念来作为最小单位。与**硬盘**打交道，就是以**块**为最小单位。

数据块的长度不一定恰好等于记录的整数倍，通常有两种 组块方式 ：

- 不跨块方式： 一个数据块只包含若干完整记录，不足以容纳一个记录的零头空间放弃不用。
- 跨块方式： 允许一个记录跨在不同数据块。这种组块方式虽然可节省空间，但实现比较困难，用得较少。

### RAID 独立磁盘冗余阵列  

![image-20231231102410557](数据库.assets/image-20231231102410557.png)

**块级拆分**

将磁盘和磁盘块视作一个矩阵，其中行为磁盘块号，列为磁盘号，如下表格所示

|         | 磁盘1      | 磁盘2      | 磁盘3      | 磁盘4      |
| ------- | ---------- | ---------- | ---------- | ---------- |
| 磁盘块0 | 逻辑块号0  | 逻辑块号1  | 逻辑块号2  | 逻辑块号3  |
| 磁盘块1 | 逻辑块号4  | 逻辑块号5  | 逻辑块号6  | 逻辑块号7  |
| 磁盘块2 | 逻辑块号8  | 逻辑块号9  | 逻辑块号10 | 逻辑块号11 |
| 磁盘块3 | 逻辑块号12 | 逻辑块号13 | 逻辑块号14 | 逻辑块号15 |

当我们要存储第11号存储块

- 若要计算存储在哪个磁盘，只需要用块号对磁盘数n取余再加1（磁盘号从1开始），即11%4+1=3+1=4，存储在磁盘4

- 若要计算存储在磁盘4的哪一个磁盘块，只需要用块号除以磁盘数n（求下界），即$\lfloor 11/4 \rfloor=2$，

**位拆分** 

位拆分可视作块的大小为1bit

#### RAID级别

> 镜像：复制每张磁盘。即一张逻辑磁盘由两张物理磁盘组成，并且每一次写操作都要在两张磁盘上执行。只有当两张磁盘都发生故障时，数据才会丢失
>
> 奇偶校验：
>
> - RAID系统中的块被划分为若干组。对于每一个给定的块集合，可以计算奇偶校验块并将其存储在磁盘上
> - 奇偶校验块的第i位被计算为集合中所有块的第i位的异或

**写动作少时 常用RAID-5， 写动作多 时常用RAID-1**

**RAID Level 0:** 

Block striping; non-redundant. 块级拆分，无冗余（冗余指镜像或奇偶校验位的磁盘阵列），多盘并发 （实用中， 只用Level 1和5）

**RAID-1:** 

写双份 ， 读一份。完整镜像 改善可靠性。每个物理记录同时写入两个磁盘阵列系统。读操作是每个独立的查询并行地访问磁盘阵列，以达到改善系统性能的目的。 RAID-1 相对与其它 RAID 结构，能满足大多数需要。

**RAID-5:** 

写双份+奇偶校验页。 

**逻辑块4k,4k+1,4k+2,4k+3对应的奇偶检验块位标记为$P_k$，存储在第（k mod 5 +1）张磁盘中，余下的四张磁盘中相应的块存储从4k到4k+3这四个数据块**

- 如下图，每张磁盘有4（N=4）个逻辑块，1个奇偶校验块，共有5(N+1=5)张磁盘
- 当存入逻辑块0,1,2,3(k=0)，对应的对应的奇偶检验块位标记为$P_0$，存储在第1张磁盘中，剩下逻辑块0,1,2,3分别存在磁盘2，3，4，5
- 当存入逻辑块4,5,6,7(k=1)，对应的对应的奇偶检验块位标记为$P_1$，存储在第2张磁盘中，剩下逻辑块4,5,6,7分别存在磁盘1，3，4，5

![image-20231231112418064](数据库.assets/image-20231231112418064.png)

读操作能在磁带上并行操作。写操作同时写入数据页面和纠错页面。为了减少磁盘争用,纠错页面被随机的存储在任意的交叉磁盘上。RAID-5使用存储空间 比 RAID-1 更有效，写时。 需写纠错页面，降速。

> 下图中，P表示纠错位，C表示数据的第二份拷贝

![image-20231231110514800](数据库.assets/image-20231231110514800.png)

### 文件的存储

![image-20231231112840849](数据库.assets/image-20231231112840849.png)

### 文件的逻辑结构

![image-20231231135253319](数据库.assets/image-20231231135253319.png)

外存中，数据库以文件形式组织，而文件又是由记录组成。

文件组织： 记录在物理文件中的实现。

文件组织的两种方式： 定长记录和变长记录。

![image-20231231141640949](数据库.assets/image-20231231141640949.png)

![image-20231231141701969](数据库.assets/image-20231231141701969.png)

## 索引

### 搜索码与超码、候选码、主码 

回顾：超码、候选码、主码 

> 简述三者的区别：
>
> ​		超码能唯一标识一条记录，但超码范围非常大，可以包含多余的属性
>
> ​		候选码是超码的最小子集，候选码的真子集不能唯一标识一条记录
>
> ​		主码是候选码中的某一个，由数据库设计者指定
>
> 超码(super key)：能够唯一标识一条记录的属性或属性集
>
> - 可能包含无关属性
> - 超码的任意超集也是超码。（通俗讲，就是同一个关系r上，如果某个属性集合S包含超码K，即K是S的子集，那么S也是 r 的超码）
> - 一张表（一个关系）一定有超码，因为至少所有属性的组合一定是超码，能唯一确定一个元组
> - 不唯一
>
> 候选码（candidate key）：能够唯一标识一条记录的最小属性集(**不含多余属性**)
>
> - 是超码的一个子集
> - 任意真子集都不可能是超码，候选码就是最小的超码
> - 没有无关属性
> - 不唯一
>
> 主码（primary key）：**某个**能够唯一标识一条记录的最小属性集。
>
> - 是候选码之一
> - 唯一或没有
> - 由数据库设计者指定，不指定的话表就没有主码

搜索码（search key）：用于在文件中查找记录的**属性或属性集**

搜索码的定义与超码、候选码、主码的定义不同，它不是用于唯一标识记录的，而是用于查找记录的

一个索引对应一个搜索码，一个搜索码可拥有用于查找的一个属性或多个属性（属性集）



### 索引基本概念

索引是**数据结构**，一个单独的、存储在**磁盘**上的 数据库结构 ，包含着对数据表里 所有记录的 引用指针。

我认为索引就是包含了搜索码和对数据表里 所有记录的 引用指针的数据结构

因此，通常来说，索引的简化结构如下：

![image-20231205221942519](数据库.assets/image-20231205221942519.png)

### 两种基本的索引类型

1. 顺序索引(ordered index)：基于搜索码的值的顺序排列，包括索引顺序文件和B+树索引文件等。
   - 顺序索引主要用于支持快速地对文件中的记录进行顺序或随机地访问。**顺序索引的结构是按顺序存储搜索码的值，并将搜索码的值与包含该搜索码值的记录关联起来 **

2. 散列索引(hash index)：通过搜索码值的散列函数(也称哈希函数)的值将所有记录平均、随机地分布到若干个散列桶中。

### 索引的优缺点

❑优点：

✓提高数据的查询的效率（类似于书的目录）

✓可以保证数据库表中每一行数据的唯一性（唯一索引）

✓减少分组和排序的时间（使用分组和排序子句进行数据查询）

✓被索引的列会自动进行分组和排序

❑缺点：

✓占用磁盘空间

✓降低更新表的效率（不仅要更新表中的数据，还要更新相对应的索引文件）

### 索引的分类

索引可以按不同指标分类

**1、普通索引 和 唯一索引**

➢普通索引：MySQL 中的基本索引类型，允许在定义索引的列中插入 重复值 和 空值

➢唯一索引：要求索引列的值必须 唯一，但允许 有空值

如果是组合索引，则列值的组合必须唯一

唯一主键索引是一种特殊的唯一索引，不允许 有空值

**2、单列索引 和 组合索引**

➢单列索引：一个索引只包含单个列（即搜索码只包含一个属性），一个表可以有多个单列索引

➢组合索引：在表的 多个字段 组合上 创建的 索引（即搜索码包含多个属性）

**只有在查询条件中使用了这些字段的 左边字段 时，索引才会被使用（最左前缀原则）**

> 最左前缀原则：从左到右依次匹配索引字段，如果某个字段与索引字段不匹配，例如学号与索引中对应字段性别不匹配，则无法使用索引

**3、全文索引**

➢全文索引 的类型为 fulltext

➢在定义索引的 列上 支持值的全文查找，允许在这些索引列中插入 重复值 和 空值

➢全文索引 可以在 char、varchar 和 text 类型的 列 上创建

**4、空间索引**

➢空间索引 是对 空间数据类型 的字段 建立的索引

### 顺序索引文件

顺序索引：按顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来

其中，包含该搜索码的记录可以为一条，但也可以为多条

#### 主索引和辅助索引

根据**包含该搜索码的记录的排列顺序**，可以分为聚集索引（主索引）和非聚集索引（辅助索引）

> 记忆方法：主索引通常是主键，文件通常按主键排序；辅助索引为非主键，文件不需要可以随意排序

聚集索引/主索引

- 如果**记录的排列顺序**与按照**搜索码**指定的顺序**相同**，那么该搜索码对应的索引称为**聚集索引/主索引**
- **在搜索码上有聚集索引的文件称作索引顺序文件**

非聚集索引/辅助索引

- 如果**记录的排列顺序**与按照**搜索码**指定的顺序**不同**，那么该搜索码对应的索引称为**非聚集索引/辅助索引**



##### 辅助索引

辅助索引必须是稠密索引。

因为记录排列顺序与搜索码的顺序不同，记录排列顺序是杂乱无序的，因此每个搜索码需要对应一个索引项，并且该**索引项存储该搜索码对应的每条记录的指针**

（与聚集索引相比，聚集索引只需要存储第一条记录的指针，而不是每条记录）

###### 候选码上的辅助索引

辅助索引使得候选码对应一个索引项，由于候选码唯一标识一个元组，因此这个索引项存储该候选码对应的**单条记录**的指针（候选码的唯一标识性）

这么一看，候选码上的辅助索引与稠密聚集索引好像非常相似

**相同点**

- 两者都是稠密索引，即一个搜索码对应一个索引项
- 每个索引项都只存储一个指针
  - 候选码上的辅助索引：由于候选码唯一标识性，一个搜索码只对应一条记录，因此只需存一个指针
  - 稠密聚集索引：一个搜索码虽然能够对应多条记录，但由于聚集性，索引项只需要存储第一条记录的指针，其他记录按顺序就可访问
    - 当然，如果这个搜索码是候选码，那么第一条记录也是唯一一条记录，这时候我们也能说稠密聚集索引（搜索码为候选码的情况）也要存储每条记录的指针

**不同点**

- 候选码上的辅助索引本质还是辅助索引，因此，尽管搜索码按顺序排列，但搜索码对应的记录并不是按顺序排列的，而是杂乱无序的
- 稠密聚集索引本质还是聚集索引，因此，搜索码按顺序排列，搜索码对应的记录也是按顺序排列的

###### 非候选码上的辅助索引

如果辅助索引的搜索码不是一个候选码，那么该搜索码能够对应多条记录，并且由于非聚集性，这几条记录的分布毫无规律，因此需要该搜索码对应的索引项存储每一条记录的指针



#### 稠密索引和稀疏索引

根据**搜索码与索引项的对应关系**，可以分为稠密索引（一个搜索码值对应一个索引项）和稀疏索引（部分搜索码值对应一个索引项，部分搜索码值没有索引项）

**稠密索引**

- **每个搜索码值都有一个索引项**

- 在**稠密聚集索引**中，**索引项**包括**搜索码值**以及指向具有该搜索码值的**第一条数据记录**的**指针**，具有相同搜索值的其余记录**顺序**地存储在第一条数据记录之后

- 在**稠密非聚集索引（例如辅助索引）**中，索引必须存储指向所有具有相同搜索码值的记录的指针列表

- 稠密聚集索引和稠密非聚集索引区别，如下图：

  ![image-20231206175527281](数据库.assets/image-20231206175527281.png)

**稀疏索引**

- 在稀疏索引中，只为搜索码的某些值建立索引项
- 只有索引是聚集索引（记录按搜索码顺序存储）才能使用稀疏索引
- **索引项**包括**搜索码值**以及指向具有该搜索码值的**第一条数据记录**的**指针**，具有相同搜索值的其余记录**顺序**地存储在第一条数据记录之后

##### 稠密索引和稀疏索引的区别

- 显然，稠密索引“稠密”：每个搜索码都拥有一个索引项，稀疏索引“稀疏”：只有部分搜索码才拥有索引项

- 稠密索引可以是聚集索引（按搜索码顺序存储记录），也可以不是聚集索引；稀疏索引必须是聚集索引

  > 很好解释，因为如果稀疏索引不是聚集索引，由于同一个搜索码值的其他记录的分布没有规律，只有一个指针找不到同一个搜索码值的其他记录

- 更详细的区别可以看下图：

  ![image-20231206180051259](数据库.assets/image-20231206180051259.png)

##### 稠密索引和稀疏索引的优缺点

- 稠密索引比稀疏索引更快定位到目标记录
- 稀疏索引比稠密索引占用空间更小，插入和删除所需的维护开销也较小

通常来说，为每个块建立一个索引项的稀疏索引

#### 多级索引

如果索引小到可以放在主存内，搜索一个索引项的时间就会很短，但是，如果索引过大而不能放在主存中，那么当需要时，就必须从磁盘中取索引块（即使索引比计算机的主存小，但内存还需要处理其他一些任务，因此也可能不能将索引放在整个内存中）

于是搜索一个索引项需要多次读取磁盘块，我们通常假设一个索引项占据$R_b$个磁盘块

多级索引：将索引项当做记录处理，将索引项分为多层，外层索引是内层索引的稀疏索引

**多级索引这么处理，是为了将索引所占据的磁盘块不断减小，最终减小到外层索引所占的磁盘块非常小，小到能够放在内存里**

这样，我们就能在内存中直接搜索最外层索引，而不需要和磁盘进行IO操作，在内存中搜索索引的时间与磁盘IO相比非常短

使用多级索引，一次查询只需要读取一个索引块，比二分法搜索记录相比的IO操作要少的多

#### 多码上的索引

一个搜索码可以含有多个属性，一个包含多个属性的搜索码称为复合搜索码（composite search key）

搜索码值按字典序排列，如果$a_1<b_1或a_1=b_1且a_2<b_2，那么(a_1,a_2)<(b_1,b_2)$

### B+树索引文件

索引顺序文件最大的缺点在于，随着文件的增大，索引查找性能和数据顺序扫描性能都会下降。

B+树会增加文件插入和删除处理的性能开销，同时增加空间开销，但是与索引顺序文件相比，索引顺序文件重组带来的代价和B+树性能的提高使得这些开销都可以接受


## 查询处理

### 简述

查询处理是指从数据库提取数据时涉及的一系列活动。这些活动包括：将用高层数据库语言表示的查询语句翻译为能在文件系统的物理层上使用的表达式，为优化查询而进行各种转换，以及查询的实际执行

![image-20231207200713955](数据库.assets/image-20231207200713955.png)

![image-20231207200924584](数据库.assets/image-20231207200924584.png)

一个查询能用几种不同的方式标识，每个SQL查询可以用其中的一种方式翻译为关系代数表达式。

关系代数表达式可能有许多等价表达式。

### 概念

**执行原语**（书上为“计算原语(evaluation primitive)“）： 带有详细执行策略注释的关系代数表达式。

**查询执行计划**：用于执行一个查询的原语操作序列。  

![image-20231207201427942](数据库.assets/image-20231207201427942.png)

该例子中，执行原语为：“可利用salary上的索引来查找余额小于75000的账户 ”或”丢弃那些余额>=75000的账户 “ 

**查询优化**: 在所有等价的执行计划中选择代价最低者  

**查询执行引擎**：接受一个查询执行计划，执行该计划并把结果返回给查询

### 查询代价的度量

磁盘存取代价的度量要考虑

- 寻址次数 * average-seek-cost
- 读块数 * average-block-read-cost
- 写块数 * average-block-write-cost
  -  写一块的代价大于读一块的代价（写代价是读代价的两倍）
    - 写数据后要读回, 以确保写成功

为简单起见, 我们仅用**磁盘块传送数**作为代价的度量：

> 书上以**传送磁盘块数**和**搜索磁盘次数**作为代价的度量，为了应付考试，我们这里也仅仅考虑磁盘块传送数

- 忽略顺序与随机I/O之间的代价不同之处
- 也忽略CPU代价

代价依赖于**内存缓冲区**的大小

- 内存多可以减少磁盘存取数
- 可用于缓冲区的实际内存量取决于其他并发OS进程, 在实际执行之前难以确定
- 经常用最坏情形估计, 故假定只有操作所需的最小内存量可用
- 实际系统要考虑CPU代价, 区分顺序与随机I/O, 考虑缓冲区大小
- 在查询代价公式中不包括将输出写到磁盘的代价

优化器通常努力去尽可能降低查询计划总的**资源消耗**，而不是尽可能缩短响应时间。

### 选择运算

#### 线性搜索

![image-20231207203036841](数据库.assets/image-20231207203036841.png)

假设关系r的元组占用的总块数为$b_r$

- 如果选择条件为主键的相等比较操作，那么最好代价为$0块$（不用扫描，直接找到），平均代价为$b_r/2$，最差代价为$b_r$
  - 因为主键，所以选择条件只对应一条记录，搜索到满足选择条件的记录就能停止
- 如果选择条件为非主键的相等比较操作，那么平均代价为$b_r$
  - 因为非主键，所以选择条件能够对应多条记录，需要扫描全部文件块

#### 二叉搜索

![image-20231207203218247](数据库.assets/image-20231207203218247.png)

#### 索引扫描

以上介绍的都是文件扫描算法，以下开始介绍使用索引的搜索算法

##### 索引等值比较

![image-20231207205053680](数据库.assets/image-20231207205053680.png)

> 回顾：主索引是聚集索引，每个搜索码对应一个索引项

###### 候选键上的主索引，等值比较

候选键上的主索引：每个候选键对应一个索引项，且这个索引项存储候选键唯一标识记录的指针

候选键上的主索引检索得到唯一一条文件记录

**总共需要访问$h_i+1$个文件块**

- 由于候选键唯一标识记录，因此只需要在B+树中深度遍历找到候选键对应的记录即可，这一过程需要访问树高$h_i$个文件块
- B+树叶子节点存储候选码对应记录的指针，因此最后还要顺着指针找到对应的文件块，这一过程需要访问1个文件块

###### 非键属性上的主索引，等值比较

> 主属性/码属性：如果某个属性在候选键内，那么我们称这个属性为主属性
>
> 非主属性/非码属性/非键属性：一个记录除了主属性，剩余的就是非主属性；非主属性不在候选键内，非主属性能够有重复值或空值，非主属性对应多条记录。

非键属性上的主索引：

- 如果是稠密主索引，每个搜索码对应一个索引项，每个索引项存储
- 如果是稀疏主索引，部分搜索码对应一个索引项，由于文件顺序存储，每个索引项存储第一个文件记录的指针

这些文件记录按顺序存储（主索引特性），与候选键上的主索引情况不同，**非键属性上的主索引检索得到多条文件记录**

**需要访问$h_i+检索到的记录数$个文件块**

###### 次级索引（辅助索引）搜索键上的等值比较

辅助索引：文件存储顺序和搜索键排列顺序不同。

辅助索引一定为稠密索引，即每个搜索码值对应一个索引项，该索引项存储该搜索码值对应的多个记录的指针

根据搜索键是否为候选键讨论：

- 搜索键为候选键，则索引项只需要存储一个记录的指针；因此检索得到单个记录，平均代价为$h_i+1$
- 若搜索键不是候选键则检索多个记录，平均代价为$h_i+检索到的记录数$

![image-20231208110807867](数据库.assets/image-20231208110807867.png)

**主索引的比较与次级索引的比较区别：**

- 主索引能够直接通过索引找到第一条记录，随后顺序扫描记录即可
- 辅助索引也能直接通过索引检索，但是与主索引不同，辅助索引找到的是索引项，要扫描具体的记录，需要扫描索引项的指针，找到对应的记录（因为文件不是顺序存储的）
  - 因为文件不是顺序存储的，因此每扫描一个指针，就需要一次IO操作，找到对应的文件块

##### 索引合取操作

![](数据库.assets/image-20231208110839227.png)

##### 索引析取操作

![image-20231208110919070](数据库.assets/image-20231208110919070.png)

## 查询优化

查询优化在两方面发生：

1. 在关系代数级别发生，系统尝试找出一个与给出的表达式等价但执行起来更为高效的表达式
2. 为处理查询选择一个详细的策略，比如对一个操作的执行选择所用的算法，选择使用的特定索引等

![image-20231210183807178](数据库.assets/image-20231210183807178.png)

实际系统的查询优化步骤

1. 将查询转换成某种内部表示， 通常是语法树
2. 根据一定的等价变换规则把语法树转换成标准 （优化） 形式
3. 选择低层的操作算法对于语法树中的每一个操作计算各种执行算法的执行代价选择代价小的执行算法
4. 生成查询计划(查询执行方案)查询计划是由一系列内部操作组成的。

### 关系代数表达式等价变换规则

![image-20231210193647809](数据库.assets/image-20231210193647809.png)

![image-20231210193659125](数据库.assets/image-20231210193659125.png)

![image-20231210193711629](数据库.assets/image-20231210193711629.png)

![image-20231210194259442](数据库.assets/image-20231210194259442.png)

![image-20231210195511881](数据库.assets/image-20231210195511881.png)

![image-20231210195534653](数据库.assets/image-20231210195534653.png)

![image-20231210195546986](数据库.assets/image-20231210195546986.png)

### 代数优化策略

![image-20231210195617468](数据库.assets/image-20231210195617468.png)

![image-20231210195625510](数据库.assets/image-20231210195625510.png)

### 查询树的启发式优化（代数优化算法）

![image-20231210200243241](数据库.assets/image-20231210200243241.png)

![image-20231210200251309](数据库.assets/image-20231210200251309.png)

## 事务

### 基本概念

事务(Transaction)是用户定义的一个单一逻辑工作单位的数据库操作序列，这些操作要么全做，要么全不做，是一个**不可分割**的工作单位，是**数据库环境中的逻辑工作单位**。

事务和程序是两个概念

- 在关系数据库中，一个事务可以是一条SQL语句、一组SQL语句、或整个程序

- 一个应用程序通常包含多个事务

 **重点：事务是恢复和并发控制的基本单位**

如果单元中的一个语句不能完成，整个单元就会回滚（撤销），所有影响到的数据将返回到事务开始以前的状态。

因而，只有事务中的所有语句都成功地执行才能说这个事务被成功地执行

### 事务的特性（ACID特性）

- 原子性（Atomicity）
- 一致性（Consistency）
- 隔离性（Isolation）
- 持续性/持久性（Durability ）

**原子性：**

- 事务是不可分割的逻辑工作单位；
- 事务中包括的所有操作要么都做，要么都不做；
- 事务的所有操作在数据库中要么全部反映出来，要么完全不反映。
- **如果一个事物开始执行，无论任何原因故障，事务对数据库所做的任何可能的修改都必须撤销。**

**隔离性：**

数据库采取特殊操作确保事物正常执行而不被来自并发执行的数据库语句所干扰

尽管多个事务可能并发执行，但系统保证：对于任何一对事务$T_i$和$T_j$，在$T_i$看来，$T_j$要么在$T_i$前开始之前已经完成执行，要么在$T_i$完成之后$T_j$才开始执行。

因此，**每个事务都感觉不到系统中有其他事务在并发地执行**

简而言之，就是**事务之间能够并发执行，但是不允许发生并发执行问题**

**持久性：**

只要事务成功完成，它对数据库地改变必须是持久的，即使发生系统崩溃也是持久的。

**一致性：**

如果事务从一个一致的数据库开始以原子方式隔离地运行，那么该数据库在事务结束时必须重新保持一致

以隔离方式执行事务（即，没有其他事务的并发执行）以保持数据库的一致性；

**事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态；**

- 一致性状态：数据库中只包含成功事务提交的结果；
- 不一致状态：
  - 书：由于故障，系统的状态不再反映数据库本应描述的现实世界的真实状态。
  - slide：数据库中包含失败事务的结果

**一旦事务已提交，就不能通过中止它来撤消其造成的影响。** 

**撤消已提交事务所造成影响的唯一方法是执行一个补偿事务。**

例如，如果一个事务给一个帐户上加了200元，其补偿事务应当从该帐户减去200元。

书写和执行补偿事务的责任留给用户，而不是由数据库系统处理

### 事务模型（举例）

这里的事务模型实则就是举例

在例1中，我们假设:

1. read为从数据库读取数据项的操作（磁盘->主存），write为往数据库填写数据项的操作（主存->磁盘）
2. 执行事务前，A有1000元，B有2000元

![image-20231221155654351](数据库.assets/image-20231221155654351.png)

**一致性：**执行事务前后，A+B都等于3000

**原子性：**如果在以下时间点发生故障：执行完write(A)之后，执行write(B)之前，那么会导致A=1000-50=950，B=2000，此时A+B=2950，违背了一致性A+B=3000，我们称这种情况为不一致状态。

无论事务是否执行，执行过程中都会出现不一致状态。但是所谓原子性，就是保证执行过程中的不一致状态不可见，事务的所有操作要么在数据库中全部反映出来，要么全都不反映。在本例中，表现为：要么A=1000,B=2000;要么A=950,B=2050

**保证原子性的基本思想**：数据库系统在磁盘上记录事务要执行写操作的任何数据项的旧值，将其记录在日志文件中，如果事务没能完成它的执行，数据库系统从日志中恢复出旧值。（具体细节详见恢复系统章节）

**持久性：**一旦事务成功执行，并且发起事务的用户被告知资金转账已经发生，系统就必须保证任何系统故障都不会导致与这次资金转账相关的数据丢失。

**保证持久性的基本思想：**

1. 由事务所执行的更新在事务结束前已经写入磁盘

2. 有关事务已执行的更新的信息被写入磁盘，并且这些信息足以使数据库在故障后重新启动数据库系统时重建这些更新

   （具体细节详见恢复系统章节）

**隔离性：**如果几个事务并发地执行，那么即使每个事务都能确保一致性和原子性，它们的操作也会以某种不希望的方式交叉执行，导致不一致的状态。

也就是并发控制章节提到的：并发执行会出现的三大问题：丢失修改、不可重复读和脏读。对应的解决方法在并发控制章节。

### 事务状态

事务必须处于以下状态之一：

✓活动状态（active）：初始状态。

✓部分提交状态（partially committed）：最后一条语句被执行之后。

✓失败状态（failed）：发现正常的执行不能继续之后。

✓中止状态（aborted）：事务**已回滚**并且数据库**已被恢复**到事务开始执行前的状态之后。

✓提交状态（committed）：成功完成之后。

**活动状态 -> 失败状态 or 部分提交状态 **：事务开始执行语句，如果执行到某条语句出现故障，则进入失败状态；如果执行完所有语句且没有发生故障，则进入部分提交状态。

**部分提交状态 -> 失败状态 or 提交状态**：事务完成其执行，数据库往磁盘上写入一些信息，这些信息保证即使出现故障，事务所执行的更新也能在系统重启后重新创建，若写入过程发生故障，则进入失败状态，否则进入提交状态。

**失败状态-中止状态**：事务回滚，数据库恢复到事务开始前状态

进入中止状态后，系统有两种选择：

- 重启(restart)事务：当且仅当引起事务中止的原因是某些硬件错误或不是由于事务的内部逻辑而察省的软件错误。重启的事务被看成一个新事务。
- 杀死(kill)事务：程序具有内部的逻辑错误/输入错误/所需数据在数据库中没有找到，总结就是无法重启事务（如果重启会一直重复该错误）

![image-20231221161629961](数据库.assets/image-20231221161629961.png)

事务进入提交状态后，我们才说该事务已提交(committed)

事务进入中止状态后，我们才说该事务已中止(aborted)

如果一个事务要么是提交的要么是中止的，我们称该事务为已经终止的(terminated)

### SQL Server&MySQL事务处理实例

#### SQL Server

![image-20231221163846670](数据库.assets/image-20231221163846670.png)

#### MySQL 

![image-20231221170617447](数据库.assets/image-20231221170617447.png)

![image-20231221170626202](数据库.assets/image-20231221170626202.png)

![image-20231221170635681](数据库.assets/image-20231221170635681.png)

![image-20231221170644581](数据库.assets/image-20231221170644581.png)

![image-20231221170652841](数据库.assets/image-20231221170652841.png)

![image-20231221170818864](数据库.assets/image-20231221170818864.png)

![image-20231221170826915](数据库.assets/image-20231221170826915.png)

### 可串行化(serializable)

> 先回顾几个概念：
>
> 调度：指令在系统中执行的时间顺序
>
> 串行调度：执行完一个事务内所有语句后执行第二个事务，对于有n个事务的一个集合，存在n!种不同的有效串行调度
>
> 并发调度：操作系统对一个事务执行一小段时间后，上下文切换，对第二个事务执行一段时间，再切换回第一个事务执行一段时间

操作系统负责实际的调度执行

数据库系统负责保证所执行的所有调度都能使数据库处于一致性状态。

如果并发调度效果和串行调度效果一样，则称为可串行化调度

**冲突可串行化**

![image-20231222083842707](数据库.assets/image-20231222083842707.png)

冲突可串行化：若一个调度S与一个**串行调度**冲突等价，则称调度S是冲突可串行化的

**并非所有串行调度之间都是冲突等价的**

如下图调度1和调度2就不是冲突等价的

| ![image-20231222084935884](数据库.assets/image-20231222084935884.png) | ![image-20231222084946080](数据库.assets/image-20231222084946080.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

### 事务的隔离级别

隔离级别排序：可串行化>可重复读>提交读>未提交读

1. **可串行化： SERIALIZABLE**

   如果隔离级为可串行化，用户之间通过一个接一个顺序地执行当前的事务提供了事务之间最大限度的隔离。

2. **可重复读： REPEATABLE READ**

   只允许读取已提交的数据

   事务不会被看成是一个序列。不过，当前在执行事务的变化仍然不能看到，也就是说，如果用户在同一个事务中执行同条SELECT语句数次，结果总是相同的。

3. **提交读： READ COMMITTED**

   只允许读取已提交的数据，但并不要求可重复读

   （第二次读取的数据可能和第一次读取的数据不同）

   安全性比REPEATABLE READ隔离级的安全性要差。不仅处于这一级的事务可以看到其他事务添加的新记录，而且其他事务对现存记录做出的修改一旦被提交，也可以看到。

4. **未提交读： READ UNCOMMITTED**

   允许读取未提交数据（脏读）

   **提供了事务之间最小限度的隔离**。除了容易产生虚幻的读操作和不能重复的读操作外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，导致了大量的数据变化

以上所有隔离性级别附带都不允许脏写(dirty write)，即如果一个数据项已经被另外一个尚未提交或中止的事务写过，则不允许对该数据项再执行写操作

> 脏读：读未提交的数据项
>
> 脏写：写未提交的数据项

许多数据库缺省隔离级别为提交读，MySQL默认为REPEATABLE READ隔离级，  

![image-20231222090239371](数据库.assets/image-20231222090239371.png)

## 并发控制

### 并行与并发

并发：同一时间段内，同一处理器有多个任务在交替执行。每个任务都会分配到一定的时间片来执行（调度），直到任务完成或者时间片用完。

并行：同一时间段内，不同处理器有多个任务同时执行。在多处理器系统中，不同的处理器可以同时执行不同的任务。

> 吞吐量：单位时间内系统执行的事务数

并发提高系统的资源利用率和吞吐量，并行提高提高系统的性能和效率。

CPU处理和磁盘I/O可以同时进行，利用二者的并行性，可以并发地执行多个事务。提高CPU和磁盘的利用率。

### 并发执行可能产生的问题

并发不恰当执行会带来三个问题：丢失修改、不可重复读和脏读，这三个问题破坏了事务ACID中的四项原则，特别是隔离性原则。

![image-20231218105435299](数据库.assets/image-20231218105435299.png)

#### 丢失修改

两个事务T1和T2读入同一数据并修改， T2提交的结果破坏了T1提交的结果，T1的修改丢失

#### 不可重复读

事务T1读取某一数据后，事务T2读取并修改了该数据，使T1无法读取到与前一次相同的读取结果; 

T2的修改也包括T2的插入和删除→幻影现象

![image-20231218110316838](数据库.assets/image-20231218110316838.png)

#### 脏读

脏读：事务T1修改了某一数据后，事务T2读取了同一数据，而T1由于某种原因被撤销，则称T2读到了脏数据

（与不可重复读的差别在于：不可重复读需要读两遍，第二遍到的结果和第一遍不同；脏读只需读一遍，读取数据后该数据被其他事务撤销）

脏读之后再读，就是不可重复再读

### 并发控制方法

并发控制的主要技术是封锁（locking）、时间戳（Timestamp）和乐观控制法

#### 封锁（locking）

封锁类型: 排它锁(X)和共享锁(S)

❑ X锁 (e**x**clusive lock): 排它锁或称写锁, 若事务T对数据对象A加上X锁, 则只允许T读取和修改A, 其他事务对A的任何封锁请求都不能成功

❑ S锁 (**S**hared lock): 共享锁或称读锁, 若事务T对数据对象A加上S锁, 则事务T可以读A, 但不可以修改A, 其他事务可以对A加S锁, 而不可以加X锁

同个数据对象只能加一个X锁，但可以加多个S锁

有X锁不能加其他X锁和S锁；有S锁不能加X锁，但可以加S锁；

![image-20231218111333598](数据库.assets/image-20231218111333598.png)

#### 封锁协议的不同等级介绍

> 丢失修改是因为事务T1修改数据R后，**还没来得及提交**，此时调度给事务T2执行，事务T2也对数据R做了修改操作，最后导致结果为事务T2修改后的结果，事务T1修改的结果丢失。

**一级封锁协议**：事务T在修改数据R之前，必须先对其加X锁，直到事务结束才释放。

一级封锁协议可以防止丢失修改（加X锁保证修改后一定能提交）

![image-20231218111829822](数据库.assets/image-20231218111829822.png)

> 造成脏读的原因：事务T1还没有执行完数据写的所有相关操作（只执行了写，没有执行数据撤销操作）就被调度到事务T2，也就是说，没有对事务T2读操作做限制，导致别的事务还没执行完就被读取了。

**二级封锁协议**：一级封锁协议+事务T在读取数据R之前，必须先对其加S锁，读完后即可释放S锁。

二级封锁协议可以进一步防止读“脏”数据（加S锁限制别的事务读取操作，保证读取到的一定是事务完成后的数据）

![image-20231218112240486](数据库.assets/image-20231218112240486.png)

> 不可重复读原因：两次读操作之间调度到了其他事务的数据修改操作

**三级封锁协议**：一级封锁协议+事务T在读取数据R之前，必须先对其加S锁，直到事务结束才释放。

三级封锁协议可以更进一步防止读-写依赖（让所有读操作进行完再调度到其他事物的修改数据操作）。

![image-20231218112614474](数据库.assets/image-20231218112614474.png)

到第三级封锁协议时，实际上已经失去并发性，事务T2必须等到T1执行完才能继续进行，这是串行操作。因此谨慎选择封锁协议。

**不同级别封锁协议比较**

![image-20231218112842834](数据库.assets/image-20231218112842834.png)

#### 两阶段封锁协议

使用封锁遵循的协议叫做封锁协议。在这里，我们介绍其中一种封锁协议：两阶段封锁协议。

两阶段封锁协议: 所有事务必须分两个阶段对所要存取的数据项加锁和解锁 （Eswaran等人1976年提出的）

- **在对任何数据进行读写操作之前, 首先申请并获得对该数据项的封锁**
- **在释放一个封锁之后, 事务不再申请和获得任何其他的封锁**
  - 可以证明, 若并发执行的所有事务都遵循两段封锁协议, 则对这些事务的任何并发调度策略都是正确的
  - 事务遵守两段封锁协议是可串行化调度的充分条件
  - 遵守两段封锁协议的事务可能发生死锁, 与防止死锁的一次封锁法不同

![image-20231218113416964](数据库.assets/image-20231218113416964.png)

两阶段封锁协议能够避免以上提到的三种并发控制问题：避免丢失修改、不可重复读和脏读

##### 避免丢失修改错误

因为两阶段封锁协议要求一开始就申请所有需要使用的锁，这种情况很容易造成死锁。

为了避免死锁，某个事务需要释放自己拿到的所有锁（我们称为谦让行为，现实生活中当两个人僵持就需要有一个人谦让），指定哪个事务释放以及释放的细节在后面提到。

![image-20231218113545481](数据库.assets/image-20231218113545481.png)

**避免不可重复读错误**

![image-20231218113636171](数据库.assets/image-20231218113636171.png)

**避免脏读数据错误**

![image-20231218113656278](数据库.assets/image-20231218113656278.png)



## 恢复系统

### 故障分类

主要的故障可以归纳为三类：事务故障、系统崩溃、磁盘故障

#### 事务故障

![image-20231220105540184](数据库.assets/image-20231220105540184.png)

#### 系统崩溃

![image-20231220105555360](数据库.assets/image-20231220105555360.png)

#### 磁盘故障

![image-20231220105645288](数据库.assets/image-20231220105645288.png)



### 存储器

数据库中的各种数据项可在多种不同存储介质（存储器）上存储并访问。

按照存储器的速度、容量和顺应故障的能力，可以分成三类：易失性存储器、非易失性存储器、稳定存储器

![image-20231220105916682](数据库.assets/image-20231220105916682.png)

#### 稳定存储器的实现

要实现稳定存储器，我们需要在多个非易失性存储器（通常是磁盘）上以独立的故障模式负值所需信息，并且以受控的方式更新信息，以保证数据传送过程中发生的故障不会破坏所需信息。

- RAID系统能够保证单个磁盘的故障不会导致数据丢失，但不能防止由于灾难导致的数据丢失。

  ![image-20231220110510868](数据库.assets/image-20231220110510868.png)

- 远程备份系统（更安全）：系统远程为存储器的每一个块保存一份拷贝，除在本地磁盘系统进行块存储外，还通过计算机网络写到远程去。避免由于灾难造成的数据丢失。

**在内存和磁盘存储器之间进行块传送有以下几种可能结果：**

➢ 成功完成：被传输的信息安全到达其目的地

➢ 部分失败：传输过程中发生故障，目的地块中有不正确信息

➢ 完全失败：传输过程中故障发生得足够早，目的地块未被写入任何信息

如果发生**数据传输故障**，要求系统能检测到并且调用恢复过程，将块恢复到一致性状态。 为达到这个要求，**系统必须为每个逻辑数据库块维护两个物理块**；

➢ 在镜像磁盘的情况下，两个块在同一地点；

➢ 在远程备份的情况下，一个块在本地，另一个块在远程站点

**输出操作执行步骤：**

1. 将信息写入第一个物理块
2. 当第一次写成功完成时，将相同信息写入第二个物理块
3. 只有第二次写成功完成时，输出才算完成

test
