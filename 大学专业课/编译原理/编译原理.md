# 编译原理

> 着重复习Chapter3 （词法分析）、Chapter4 （语法分析）、Chapter6 （中间代码生成）

## 章节概览







## Chapter 1

### Knowledge

#### 编译简述

- 语言处理器：一个集成的软件开发环境，其中包括很多种类的语言处理器，比如编译器、解释器、汇编器、连接器、加载器、调试器以及程序概要提取工具
- 编译器的步骤：一个编译器的运作需要一系列的步骤，每个步骤把源程序从一个中间表示转换成为另一个中间表示。

![image-20231126140943786](编译原理.assets/image-20231126140943786.png)

![image-20231126140956468](编译原理.assets/image-20231126140956468.png)

#### 编译器与解释器

- 编译器：阅读某种语言（源语言）编写的程序（源程序），将其翻译成为另一种语言（目标语言）编写的程序（目标程序）
  - 用户输入进入目标程序，生成对应输出
  - 目标语言可以是机器码，也可以是其他语言

- 解释器：直接利用用户提供的输入执行源程序中指定的操作

![image-20231126141032835](编译原理.assets/image-20231126141032835.png)

- 混合编译器：Java编译器

  将Java源程序编译为字节码的中间表示形式，由**虚拟机**对字节码加以**解释**执行

  ![image-20231126141200010](编译原理.assets/image-20231126141200010.png)



#### 编译器的结构

基本上前后端的区分在中间代码生成阶段，前端负责将源程序转换为中间代码，后端负责处理中间代码产生目标代码

![image-20231126141647152](编译原理.assets/image-20231126141647152.png)

##### 符号表

存放整个源程序的信息，供编译器的**各个步骤**使用（类比于编译器的“全局变量”）

- **分析阶段**收集源程序的信息，将信息存储在符号表中
- 符号表和中间表示形式一起传给综合阶段（后端）

##### 词法分析(Lexical analysis/Scanning)

![image-20231126142205477](编译原理.assets/image-20231126142205477.png)

##### 语法分析（Syntax analysis/parsing)

![image-20231126142258279](编译原理.assets/image-20231126142258279.png)

语法树每个内部节点表示一个运算，每个子节点表示运算的分量

##### 语义分析（Semantic analysis)

![image-20231126142734969](编译原理.assets/image-20231126142734969.png)

**语义分析的主要任务**

1. 根据语法树收集标识符的属性信息，填入符号表中
2. 语义检查

![image-20231126143133788](编译原理.assets/image-20231126143133788.png)

![image-20231126142916717](编译原理.assets/image-20231126142916717.png)

种属信息包括：简单变量，复合变量（数组、记录、...）、过程、...

类型信息包括：整型、实型、字符型、布尔型、指针型、...

##### 中间代码生成

生成类机器语言的中间表示形式（例如三地址代码）

##### 代码优化

略

##### 代码生成

目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言  

##### 趟(Pass)

以上提到的都是理论步骤，趟是实际执行步骤

![image-20231126143424063](编译原理.assets/image-20231126143424063.png)

#### 构造工具

简单了解

![image-20231126143519964](编译原理.assets/image-20231126143519964.png)

#### 程序设计语言的发展历程

![image-20231126144755987](编译原理.assets/image-20231126144755987.png)

![image-20231126144425292](编译原理.assets/image-20231126144425292.png)

#### 程序设计语言基础

##### 静态和动态 (static/dynamic)

静态：支持编译器静态决定某个问题（编译期 compile time）

动态：只允许在程序运行时刻作出决定（运行时 run time） 

##### 作用域 (scope)

x的作用域指程序的一个区域，在其中对x的使用都指向这个声明

- 静态作用域 (static scope)
  - 编译期即可决定作用域 （仅通过阅读程序就可以确定一个声明的作用域）
  - 也叫词法作用域 (lexical scope)
  - 大部分语言（如C和Java）使用静态作用域
- 动态作用域 (dynamic scope)
  - 运行时才可决定作用域
  - 程序运行时，同一个对x的使用会指向x的几个声明中的某一个

##### 环境和状态

通常而言：环境和状态映射是动态的

但也有特例：

- 名字到位置的静态绑定与动态绑定。大部分名字到位置的绑定是动态的，但类似于全局变量的某些声明是静态的，编译器生成目标代码时就能将名字和位置绑定。
- 位置到值的静态绑定与动态绑定。大部分位置到值的绑定是动态的，因为无法在运行程序之前就知道某个值实际存放的位置，但例如(`#define ARRAYSIZE 100`)这种常量声明，能够将名字和值绑定一起，这种绑定是静态的。

![image-20231126162526689](编译原理.assets/image-20231126162526689.png)

##### 静态作用域和块结构

块是声明和语句的组合，C语言中由{}界定，另一种界定方法是begin和end

![image-20231126164054669](编译原理.assets/image-20231126164054669.png)

![image-20231126164413612](编译原理.assets/image-20231126164413612.png)

##### 名字、标识符和变量

![image-20231126164255607](编译原理.assets/image-20231126164255607.png)

##### 过程、函数和方法

- 函数返回某个类型的值（返回值只有一个）
- 过程不返回参数，可看作是返回类型为void的函数
- 方法可以像函数或过程运行，但与某个类相关联

##### 声明和定义

- 声明告诉我们事物的类型
- 定义告诉我们它的值

##### 动态作用域（*粗略掌握）

我们直接谈论静态作用域与动态作用域的区别：

- 静态作用域在编译期间就确定变量的作用域，其变量的作用域不受程序执行过程的影响。静态作用域以声明在程序中出现的位置或者以public、private和protected等关键字的使用，对作用域进行控制。
- 动态作用域指在程序运行期间才能确定变量的作用域。具体来说，就是检查函数的调用栈或专业地称为调用链。动态作用域中，函数执行遇到一个符号，会由内向外逐层检查函数的**调用链**，并打印第一次遇到的那个绑定的值。显然，最外层的绑定即是全局状态下的那个值。
- 更白话地说，静态作用域找最内层的、包含变量使用位置的块（最近块），动态作用域找最内层的、包含了变量使用时间的过程调用（最近调用链）

举个例子

###### 例1

```c
#define a(x+1)
int x = 2;
void b(){
	int x = 1;
	printf("%d\n",a);
	c();
}
void c(){
	printf("%d\n",a);
}
void main(){b();}
```

在这段代码里面，我们编译时不能确定a的取值

程序运行时，b函数调用c函数，即使c函数体内没有对a的声明，但是调用链里面x的最近值为1，所以c打印a为2(1+1=2)

如果是静态作用域，显然c只会返回3(2+1=3)，因为c函数体内没有对c的声明，此时认为x为全局变量2

###### 例2

> 1. 有一个类C，它有一个名字为m()的方法
> 2. D是C的子类，D也有一个自己的名字为m()的方法
> 3. 有一个形如x.m()的对x的使用，其中x是类c的一个对象

只有到运行时刻，我们才能知道x指向类c的对象还是类d的对象，以及使用哪个m()

##### 参数传递机制

###### 值调用（call-by-value）

关键词为“拷贝”，即实参拷贝给形参

实参有以下类型

- 如果是变量，将变量值**拷贝**给形参

- 如果是表达式，求出表达式的值之后将值**拷贝**给形参

- 如果是函数，将函数执行后的返回值**拷贝**给形参

- 如果是指针，将指针拷贝给形参

  **一般来说，值调用不会影响调用者的值**。但**指针情况**下，尽管拷贝的是指针，我们对指针做的任意操作，都会对应操作后指针的位置，从而实现能**改变调用者值的值调用**

  例如：

  ```c
  int array[3];
  x[2] = 2;
  void test(int* x,int size)
  {
  	x[2] = 1;
  }
  
  test(array,3);
  printf("%d",array[2]);
  ```

  在以上代码中，我们想对改变数组的值，传入了指针array；编译器会拷贝array的值给函数test的形参x，尽管是拷贝的指针，但是x[2]对应指针（array+2），`x[2] = 1;`会对这个指针指向的位置进行赋值，因此影响到了调用者，打印结果为2

特别的，Java使用值调用，但是拷贝的“值”为指针，因此**java的值调用：名为“值调用”，实际效果为“引用调用”**

###### 引用调用（call-by-reference）

- 实参的地址作为相应的形参的值被传递给被调用者
  - **值调用中实参为指针不同，值调用为“拷贝”，而引用调用不拷贝，无论你给变量/表达式/函数，都直接给它们的地址**
- 改变形参看起来就像是改变了实在参数一样

###### 名调用（call-by-name）

- 被调用者的运行方式好像是用实参以字面方式替换了被调用者的代码中的形参一样。
- 形参是一个代表了实参的宏

名调用这么说太绕了，简单说就是：**把形参直接替换成实参（无论是变量，表达式还是函数），替换后再计算形参的值**

（而值调用是先计算出表达式的值或先得到参数函数执行后的返回值，再传给形参）

##### 别名

引用调用或其他方法（例如值调用传递指针or java把对象的引用当作值传递），可能会导致两个形式参数x和y指向同一个位置，此时称x是y的别名，y是x的别名

优化程序时，需要注意别名现象

### Question

**Q1.1.1：编译器和解释器的区别？**

**A1.1.1：**

简单概括就是：

- 编译器需要编译生成目标程序之后，才能通过目标程序对输入处理生成输出；在编译阶段（生成目标程序过程）能检测源程序错误
- 解释器不需要编译，直接对输入处理生成输出

> A compiler is a program that can read a program in one language - the source language - and translate it into an equivalent program in another language – the target language and report any errors in the source program that it detects during the translation process.
>
> Interpreter directly executes the operations specified in the source program on inputs supplied by the user.



**Q1.1.2：编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么？**

**A1.1.2：**

- 编译器相对于解释器的优点：

  输入映射为输出的过程，编译器编译得到的机器语言目标程序比解释器运行速度快得多

  

- 解释器相对于编译器的优点：

  解释器对源程序的错误诊断能力比编译器更好（因为解释器逐条语句执行源程序）

> a. The machine-language target program produced by a compiler is usually much faster than an interpreter at mapping inputs to outputs.
>
> b. An interpreter can usually give better error diagnostics than a compiler, because it executes the source program statement by statement.



**Q1.1.3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？**

**A1.1.3：**

1. 汇编语言更容易输出，而且容易debug

   （一个汇编指令对应一条机器指令，汇编指令调试和优化肯定比机器指令简单方便）

2. 汇编语言到机器语言的转换由硬件实现，减弱编译器编写的复杂性和冗余（避免每个编译器都实现高级语言到机器语言的转换，而是统一由硬件实现到机器语言的转换）

> The compiler may produce an assembly-language program as its output, because assembly language is easier to produce as output and is easier to debug.



**Q1.1.4：把一种高级语言翻译成为另一种高级语言的编译器称为端到端的翻译器。编译器使用C语言作为目标语言有什么好处？**

**A1.1.4：**

C语言较为普及，各种平台（硬件）上都有对其实现的支持

> For the C language there are many compilers available that compile to almost every hardware.

相对于汇编语言，C的抽象更为高级，分离了更多具体的实现细节，可以避免在代码在移植时由于具体机器架构，指令集的不同等其他问题而受到影响。



**Q1.1.5：描述以下汇编器所要完成的一些任务**

**A1.1.5：**

将汇编代码翻译成机器语言代码，并且这份机器语言代码是可重定位的（relocatable）

（可重定位指：机器语言代码中使用的地址为逻辑地址（相对地址），当加载器加载到实际物理内存时，逻辑地址更新为实际物理地址）

> It translates from the assembly language to machine code. This machine code is relocatable.



**Q1.3.1**

![image-20231126144604598](编译原理.assets/image-20231126144604598.png)

**A1.3.1：**

> - 强制式语言：在程序中指明如何完成一个计算任务的语言（我们常用的语言）
>   - （白话讲就是：指明计算机应该先干什么，再干什么，注重过程）
> - 声明式语言：程序中指明要进行哪些计算的语言（函数式编程）
>   - （白话讲就是：指明只关注想要的结果）
> - 冯诺依曼式语言：以冯诺依曼计算机体系结构为计算模型的语言
>   - 冯系列的特征，基于机器抽象。
>     - ​	程序变量↔计算机存储单元
>     - ​	控制语句↔计算机测试和跳转指令
>     - ​	赋值语句↔获取，存储指令
>     - ​	表达式↔内存引用和算术指令。
>     - ​		例如：基于机器抽象的C，java系列就是冯语言。
>   - 非冯的特点就是语言基础不是机器抽象。
>     - ​		例如：基于lambda演算的lisp，就是非冯。
>
> - 脚本语言：解释性语言，读一行执行一行

1. 强制式的（Imperative）：C，C++，Fortran，Java（C#，此处未提到）
2. 声明式的（Declarative）：ML（Haskell、Prolog，此处未提到）
3. 冯·诺伊曼式的（Von Neumann）：C，C++，Fortran，Java，VB
4. 面向对象的（Object-oriented）：C++，Java（C#、Ruby，此处未提到）
5. 函数式的（Functional）：Lisp，ML（Haskell，此处未提到）
6. 第三代（Third-generation）：C，C++，Fortran，Java，VB
7. 第四代（Fourth-generation）：
8. 脚本语言（Scripting）：Perl，Python（Awk、Javascript、PHP、Ruby，此处未提到）



**Q1.6.1-1.6.4：**

![image-20231127202722209](编译原理.assets/image-20231127202722209.png)

**A1.6.1：**

w = 13, x = 11, y = 13, z = 11.

**A1.6.2：**

w = 9, x = 7, y = 13, z = 11.

**A1.6.3：**

```
Block B1:
	declarations:  ->   scope
		w				B1-B3-B4
		x				B1-B2-B4
		y				B1-B5
		z				B1-B2-B5
Block B2:
	declarations:  ->   scope
		x				B2-B3
		z				B2
Block B3:
	declarations:  ->   scope
		w				B3
		x				B3
Block B4:
	declarations:  ->   scope
		w				B4
		x				B4
Block B5:
	declarations:  ->   scope
		y				B5
		z				B5
```

**A1.6.4：**

```
3

2
```



## Chapter 3

### Knowledge

#### 词法分析器

词法分析器的主要任务：

1. **识别词素。**读入源程序的输入字符，将它们组成词素，生成并输出一个词法单元序列，每个词法单元对应一个词素，这个词法单元序列输出到语法分析器进行语法分析
2. **记录词素到符号表中。**词法分析器发现一个词素时，将其添加到符号表中
3. **过滤掉源程序中的注释和空白**（空格、换行符、制表符以及在输入中用于分隔词法单元的其他字符）
4. **将编译器生成的错误信息与源程序的位置联系起来。**（词法分析器能够读取换行符并记录换行符的个数，从而给每个出错信息赋予一个行号）

词法分析器可以分为两个级联的处理阶段：

1. 扫描阶段：完成一些**不需要生成词法单元**的简单处理，例如：删除注释，将多个连续的空白字符压缩成一个字符。
2. 词法分析阶段：处理扫描阶段的输出并生成词法单元

![image-20231127204222548](编译原理.assets/image-20231127204222548.png)

#### 词法单元、模式、词素

![image-20231127205647731](编译原理.assets/image-20231127205647731.png)

##### 词法单元

- 词法单元名可以是一个特定的关键字，或者是一个标识符（输入字符序列）
- 词法单元名是语法分析器处理的输入符号
- 词法单元的通用分类
  - 每个**关键字**有一个词法单元**（关键字的模式就是这个关键字本身）**
  - 表示**运算符**的词法单元
  - 表示所有**标识符**的词法单元
  - 一个或多个表示**常量**的词法单元，例如数字和字面值字符串
  - 每一个**标点符号**有一个词法单元

##### 模式

- 当词法单元是一个关键字，它的模式就是组成这个关键字的字符序列**（关键字的模式就是这个关键字本身）**

- 对于标识符和其他词法单元，模式更复杂，可以和很多符号串匹配

  例如：

  ```
  "struct"    { yylval = createNode("STRUCT", ENUM_LEX_OTHER, yylineno, 0, NULL);
                return STRUCT; }
  {ID}        { yylval = createNode("ID", ENUM_LEX_ID, yylineno, 0, NULL);
                strcpy(yylval->strVal, yytext);
                return ID; }
  ```

  其中`ID`为：

  ```
  digit       [0-9]
  letter      [_a-zA-Z]
  ID          {letter}+({digit}|{letter})*
  ```

  在这个例子中，`struct`是关键字，它的模式就是`struct`；而对于变量标识符（对应ID），它的模式为`{letter}+({digit}|{letter})*`，把缩写letter和digit换成实际表示后，实际模式为：`{[_a-zA-Z]}+({[0-9]}|{[_a-zA-Z]})*`比struct关键字的模式`struct`复杂得多的多

##### 词素

- 词素是从实际输入的字符序列的划分出的有意义的单元，例如x,y,if等等

##### 词法单元、模式、词素举例

**下图中的非正式描述对应模式**

![image-20231127211018980](编译原理.assets/image-20231127211018980.png)

#### 词法单元的属性

多个词素能够对应同一个词法单元名，为了区分不同的词素，我们还要给词法单元添加属性值。

一个模式匹配多个词素时，必须通过属性来传递附加的信息

词法分析器向语法分析器返回词法单元名字和一个描述这个词法单元的词素的属性值

属性值将被用于语义分析、代码生成等阶段

- 不同的目的需要不同的属性
  - 属性值通常是一个结构化数据（包含多种信息）
-  如词法单元id的属性
  - id内容、类型、第一次出现的位置、…（或**存放于符号表中，属性值为符号表条目指针**）

#### 词法错误

- 如果拼写错误，但是能被模式识别，那么词法分析器无法发现错误，只能将其返回给语法分析器及以上处理
- 如果连模式都无法识别，那么词法分析器无法处理输入，也就能发现错误。**我们不仅要发现错误，而且发现错误后要继续让词法分析器处理输入，因此我们需要错误恢复策略。**
  - 最简单的错误恢复策略：**”恐慌模式“**恢复：从剩余的输入中不断删除字符，知道词法分析器能够在剩余输入的开头发现一个正确的词法单元为止。

![image-20231201225438594](编译原理.assets/image-20231201225438594.png)

#### 词法单元的规约

##### 字母表、串和语言

- 字母表：顾名思义，一堆符号的有穷/可数集合
- 串：字母表中多个符号组成的序列
  - 串s的长度|s|就是字母的个数
  - 空串表示为$\epsilon$，长度为0
  - 单个符号也可以是串，长度为1
- 语言：用字母表中的符号组成串，多个这样的串放在一个集合里，这个有穷/可数集合叫做语言
  - 空集和包含空串的集合{$\epsilon$}也是语言，前者是含有0个串的集合，后者是含有1个串（空串也是串）的集合
  - 所有语法正确的C程序的集合、所有语法正确的英语句子的集合是语言

![image-20231201230240762](编译原理.assets/image-20231201230240762.png)

### ![image-20231201231000282](编译原理.assets/image-20231201231000282.png)

**字串连续（相邻的字符组成），子序列不连续（不一定相邻的字符组成）**

![image-20231201231448471](编译原理.assets/image-20231201231448471.png)

![image-20231201231914677](编译原理.assets/image-20231201231914677.png)

**例题：**

![image-20231201232635843](编译原理.assets/image-20231201232635843.png)

##### 正则表达式

正则表达式，就是一种模式，能够表示若干个词素的公共特征

- 正则表达式的表示语言：正则表达式对应的所有符号串的集合

- 正则表达式的运算

  - ![image-20231202220557194](编译原理.assets/image-20231202220557194.png)
  - 为了表示方便，我们引入优先级从而去掉多余的括号![image-20231202220627172](编译原理.assets/image-20231202220627172.png)

- 正则语言/正则集合：能够用正则表达式表示的语言

- 如果两个正则表达式r和s表示同样的语言，则称r和s等价，记作r=s

  - 判断正则表达式等价的定律

    ![image-20231202220813648](编译原理.assets/image-20231202220813648.png)

- 正则表达式的例子

  ![image-20231202220923692](编译原理.assets/image-20231202220923692.png)

##### 正则定义

正则定义：给正则表达式命名的若干个定义序列

注意区分正则定义和正则表达式：

- 正则定义能够给正则表达式取名字，**使用别名来代替正则表达式**，起到简化表示的作用
- 正则表达式只能使用正则表达式（单个符号也可以是正则表达式）和运算符（选择，连接，闭包，括号）的组合表示一系列词素，**不能使用别名**

![image-20231202221106655](编译原理.assets/image-20231202221106655.png)

###### 正则定义的例子

![image-20231202222554128](编译原理.assets/image-20231202222554128.png)

###### 正则表达式的扩展

- ”+“：表示一个或多个正则表达式
- ”？“：表示零个或一个实例

这两种符号优先级和结合性和闭包符号”*“相同

![image-20231202222714253](编译原理.assets/image-20231202222714253.png)

#### 词法单元的识别

##### 状态转换图

- 起始状态：以一条标有start的边开始

- 接收状态/最终状态：用双层圈表示，接收状态向语法分析器返回词法单元和对应的属性值

- 回退：在接收状态附近加上*，吐出连接到该接收状态的边对应的符号

  *的个数表示回退多少个状态

![image-20231203141924920](编译原理.assets/image-20231203141924920.png)

![image-20231203142403721](编译原理.assets/image-20231203142403721.png)

##### 保留字和标识符的识别

- 方法一：在符号表先填保留字并指明它们不是普通标识符。那么词法分析的时候，如果遇到符号表中不存在的符号，这个符号一定是标识符。
- 方法二：为每个关键字建立单独的状态转换图
  - 注意最后需要判断是否为非字母或非数字
  - 需要设定词法单元之间的优先级

![image-20231203142756979](编译原理.assets/image-20231203142756979.png)

![image-20231203144126994](编译原理.assets/image-20231203144126994.png)

#### 词法分析工具Lex/Flex

![image-20231203170227363](编译原理.assets/image-20231203170227363.png)

![image-20231203170250476](编译原理.assets/image-20231203170250476.png)

#### 有穷自动机

有穷自动机：识别输入串，判断其是否属于对应正则语言，返回Yes/No

![image-20231203204430976](编译原理.assets/image-20231203204430976.png)

有穷自动机分为**不确定的有穷自动机（NFA）**和**确定的有穷自动机（DFA）**

##### 不确定的有穷自动机

![image-20231203204619206](编译原理.assets/image-20231203204619206.png)

![image-20231203204657607](编译原理.assets/image-20231203204657607.png)

![image-20231203204726283](编译原理.assets/image-20231203204726283.png)

缺点：如果表中空缺太多，浪费空间

![image-20231203204741869](编译原理.assets/image-20231203204741869.png)

上图中的iff是“当且仅当”的意思

注意：接受语言中的每个串一定是从**开始状态到接收状态**的标号串，接受语言是这些串的集合



##### 正则表达式到自动机的转换

- 正则表达式：简洁、精确地描述词法单元的模式
- 自动机：便于机器执行的计算模型
  - NFA：易于从正则表达式转换（ε跳转）
  - DFA：可由NFA转换，便于机器高效模拟执行
    - DFA最小化，优化空间使用率

###### 正则表达式到NFA

- 基本思想

  - 根据正则表达式的递归定义，按照正则表达式的结构递归地构造出相应的NFA

- 算法分成两个部分

  - 基本规则处理ε和单符号的情况

    ![image-20231203205711503](编译原理.assets/image-20231203205711503.png)

  - 归纳部分：对于每个正则表达式的运算，建立组合相应NFA的方法（递归）

    - 图3-40：已知正则表达式s和t，N(s)和N(t)分别为s和t的NFA，建立s|t的NFA
    - 图3-41：已知正则表达式s和t，N(s)和N(t)分别为s和t的NFA，建立st的NFA
    - 图3-42：已知正则表达式s，N(s)为s的NFA，建立s*的NFA

    ![image-20231203205757953](编译原理.assets/image-20231203205757953.png)

    ![image-20231203205809143](编译原理.assets/image-20231203205809143.png)

举例：求正则表达式(a|b)*abb  对应的NFA

![image-20231203211302901](编译原理.assets/image-20231203211302901.png)

###### NFA到DFA

每个NFA都有一个等价的DFA  

一个NFA被称为DFA，如果

- 没有标号为ε的转换
- 对于每个状态s和每个输入符号a，有且仅有一条标号为a的离开s的边

**NFA到DFA的转换算法**

![image-20231203212344525](编译原理.assets/image-20231203212344525.png)

![image-20231203212415375](编译原理.assets/image-20231203212415375.png)

![image-20231203212422979](编译原理.assets/image-20231203212422979.png)

**举例：**

![image-20231203220642499](编译原理.assets/image-20231203220642499.png)

![image-20231203221107193](编译原理.assets/image-20231203221107193-1701612668009-1.png)

###### DFA状态数量最小化

DFA状态越少，空间效率越高

一个正则语言可对应于多个识别此语言的DFA

通过DFA的最小化可得到状态数量最少的DFA (不计同构，这样的DFA是唯一的)

![image-20231203221201703](编译原理.assets/image-20231203221201703.png)

**DFA最小化算法**

把所有可区分的状态分开 (迭代过程)

- 基本步骤：

  ε区分了接受状态和非接受状态

- 归纳步骤：如果状态s和t是可区分的，且s'到s、t'到t有标号为a的边，那么s'和t'也是可区分的

  - 最终没有区分开的状态就是等价的
  - 所有的死状态都是等价的（死状态：对于一个状态而言，任意输入符号a都转向自己的非接收状态，那么这个状态是死状态）
  - 从划分得到的等价类中选取代表，并重建DFA

- 具体实现

  ![image-20231204204249513](编译原理.assets/image-20231204204249513.png)

  划分完毕后，需要将划分后的状态重新整理

  ![image-20231204204336238](编译原理.assets/image-20231204204336238.png)

**例子：**

![image-20231204211110894](编译原理.assets/image-20231204211110894.png)

![image-20231204211158620](编译原理.assets/image-20231204211158620.png)

###### 自动机到词法分析器

![image-20231204211249576](编译原理.assets/image-20231204211249576.png)

![image-20231204211309318](编译原理.assets/image-20231204211309318.png)

**举例**

![image-20231204211328705](编译原理.assets/image-20231204211328705.png)

![image-20231204211342592](编译原理.assets/image-20231204211342592.png)

![image-20231204211354434](编译原理.assets/image-20231204211354434.png)

###### 词法分析器状态的最小化

基本思想和DFA最小化算法相同

差别：

- 词法分析器中的接受状态对应于不同的模式

- 对应不同模式的接受状态一定是不等价的

- 初始划分为：

  所有非接受状态集合 + 对应各模式的接受状态集合

Ø 其余划分和构造的方法均相同

Ø 接受状态对应的模式就是原来的模式

**举例**（3-54就是下面PPT中的图）

![image-20231204211720990](编译原理.assets/image-20231204211720990.png)

![image-20231204211734060](编译原理.assets/image-20231204211734060.png)

### Question

**Q：为什么要设立独立的词法分析？（或为什么要将编译过程的分析阶段分为词法分析阶段和语法分析阶段）**

**A：**

1. **简化编译器的设计**。例如我们不希望语法分析器还要去除注释和空白。
2. 提高编译器效率。把词法分析器独立出来使我们能够使用专用于词法分析任务、不进行语法分析的技术。
3. 增强编译器的可移植性。输入设备相关的特殊性可以被限制在词法分析器中。

**Q3.1.1**

![image-20231201223918227](编译原理.assets/image-20231201223918227.png)

**A3.1.1**

- float是关键字，自己一个词法单元，无属性值
- 函数名、变量名属于标识符，归纳于id词法单元，名称为属性值
- "<="、">="等判断符号与"+"、"-"、"*"、"/"等计算符号与"? :"等条件表达式符号，都属于操作符，归纳于op词法单元，具体符号名为属性值
- 常数归纳于num词法单元，具体数值为属性值

```
<float> <id, limitedSquaare> <(> <id, x> <)> <{>
  <float> <id, x>
  <return> <(> <id, x> <op,"<="> <num, -10.0> <op, "||"> <id, x> <op, ">="> <num, 10.0> <)> <op, "?"> <num, 100> <op, ":"> <id, x> <op, "*"> <id, x>
<}>
```

**Q3.1.2**

![image-20231201224449525](编译原理.assets/image-20231201224449525.png)

**A3.1.2**

- 文字归于`text`词法单元，文字内容为属性值
- 像`<B></B>``<P></P>`成对出现的
  - 左符号对应`nodestart`词法单元，属性值为符号名
  - 右符号对应`nodeend`词法单元，属性值为符号名
- 像`<IMG SRC = ".....">`单独出现的元素，归纳与词法单元`selfendnode`，属性值为符号名

```
<text, "Here is a photo of"> <nodestart, b> <text, "my house"> <nodeend, b>
<nodestart, p> <selfendnode, img> <selfendnode, br>
<text, "see"> <nodestart, a> <text, "More Picture"> <nodeend, a>
<text, "if you liked that one."> <nodeend, p>
```

**Q3.3.1**

![image-20231202223013518](编译原理.assets/image-20231202223013518.png)

**A3.3.1**

感觉这道题不重要，略

**Q3.3.2**

![image-20231202223315546](编译原理.assets/image-20231202223315546.png)

**A3.3.2**

1. {aa,aaa,aba,aaaa,aaba,abaa,abba,...}

   **描述为：a开头，a结尾，中间为若干个a和若干个b混合的串**

2. {$\epsilon$,a,b,aa,ab,ba,bb,aaa,aab,aba,baa,abb,bba,bbb,...}

   **描述为：符号a和符号b混合的串**

   1. 先解释里面($\epsilon$|a)b*：{$\epsilon$,a,b,ab,bb,abb,bbb,abbb...}
   2. 然后是零个或多个($\epsilon$|a)b*，结果就是a和b任意混合

3. **描述：符号a和符号b混合而成的串，其中倒数第三个符号为a**

   1. 先解释a(a|b)(a|b)={aaa,aab,aba,abb}
   2. 然后前面加上若干个a和b的混合串

4. {bbb,abbb,babb,bbab,bbba,...}

   **描述：符号a和符号b混合而成的串，其中只含有3个b**

5. **描述：符号a和符号b混合而成的串，其中符号a的个数和符号b的个数都是偶数**

**Q3.3.3**

试说明在一个长度为n的字符串中，分别有多少个

1. 前缀
2. 后缀
3. 真前缀
4. 字串
5. 子序列

**A3.3.3**

1. n + 1（注意包括$\epsilon$）

2. n + 1（注意包括$\epsilon$）

3. n - 1（真前缀不包括字符串本身和空串，在前缀个数n+1基础上减去2，为n-1）

4. $\frac{n(n+1)}{2}+1$

   我的计算方法是枚举找规律：

   - 长度为n时，只有1个字串
   - 长度为n-1时，有2个字串
   - 长度为n-2时，有3个字串
   - 长度为n-3时，有4个字串
   - 以此类推，长度为1时，有1个字串
   - 所以长度1到长度n，共有$\frac{n(n+1)}{2}$个字串
   - 最后加上$\epsilon$（长度为0）的特殊情况，共有$\frac{n(n+1)}{2}+1$个字串

   > 书上给的答案是C(n+1,2) + 1 ，结果一样，但不知道书的思路是怎样

5. Σ(i=0,n) C(n, i)

**Q3.3.4**

![image-20231203135808985](编译原理.assets/image-20231203135808985.png)

**A3.3.4**

```
select -> [Ss][Ee][Ll][Ee][Cc][Tt]
```

**Q3.3.5**

![image-20231203161251706](编译原理.assets/image-20231203161251706.png)

**A3.3.5**

1. other为去掉5个元音的字符类

   由于串中的元音按顺序出现，且必须包含这5个元音，所以我们首先按顺序列出5个元音：aeiou

   然后依次在其中插入字符串：

   - a前面为去除aeiou的任意小写字母串other*
   - ae之间为去除eiou的任意小写字母串(other|a)*，可以含有a，因为位于a和e之间
   - 同理：ei之间为去除iou的任意小写字母串(other|e)*，可以含有e，因为位于e和i之间，但不能含有a，否则会破坏顺序

   ```
   want -> other* a (other|a)* e (other|e)* i (other|i)* o (other|o)* u (other|u)*
   other -> [bcdfghjklmnpqrstvwxyz]
   ```

2. ```
   want -> a* b* ... z*
   ```

3. 对下面符号进行解释：

   - 由于/和*在正则表达式中有特殊的含义，因此需要使用转义字符\将其去特殊化
   - `\/\*`匹配"/*"，表示注释开始
   - `([^*"]*|".*"|\*+[^/])*`匹配任意字符
     - `[^*"]*`：匹配除了星号 `*` 和双引号 `"` 之外的任意字符，零次或多次。
     - `".*"`：匹配双引号内的内容，即引号中的任意字符，零次或多次。
     - `\*+[^/]*`：匹配一个或多个星号 `*` 后跟除了斜杠 `/` 之外的任意字符，零次或多次。
   - `\*\/`匹配"*/"，表示注释结束

   ```
   \/\*([^*"]*|".*"|\*+[^/])*\*\/
   ```

4. 略

5. 略

6. 略

7. 略

8. 不含字串abb

   需要保证b的后面一定是a

   ```
   b*(a+b?)*
   ```

9. 含有子序列abb的情况

   `_a_b_b_`  "_"为可选的字符串填空

   题目要求不含有子序列abb，那么不能同时存在这三个字母

   - 不含a：`b*`
   - 颠倒次序：即a和b无交集，`b*a+`，
   - a后面只含1个b：即`b*a+ba*`，例如bbbbaaaabaaa

   ```
   b* | b*a+ | b*a+ba*
   ```

   

**Q3.3.6**

![image-20231203164603001](编译原理.assets/image-20231203164603001.png)

**A3.3.6**

```
[A-Ja-j]
[bcdfghjklmnpqrstvwxzy]
[0-9a-f]
[.?!]
```



**Q3.4.1&Q3.4.2**

练习3.3.2的正则表达式

![image-20231203160542531](编译原理.assets/image-20231203160542531.png)

练习3.3.5的正则表达式

![image-20231203161251706](编译原理.assets/image-20231203161251706.png)

![image-20231203160521569](编译原理.assets/image-20231203160521569.png)



**A3.4.1**



## Chapter 4：语法分析

本章介绍语法分析器

![image-20231221204141351](编译原理.assets/image-20231221204141351.png)

### 语法分析器的分类

**通用的**

如Cocke-Younger-Kasami、Earley算法等通用语法分析方法可以对任意文法做语法分析，但效率很低，不能用于编译器产品

**非通用的（专用）**

- 自顶向下的：从顶（根节点）向底部（叶子）构造语法分析树
- 自底向上的：从叶子逐渐向根节点构造语法分析树

自顶向下和自底向上的方法只能处理某些文法子类，但已经足够描述现代编程语言的大部分语法

**语法分析器可以和前端的其余部分用一个模块来实现**

- 将词法单元的信息收集到符号表中、类型检查和其他类型的语义分析、生成中间代码等

### 上下文无关文法

程序设计语言构造的语法可使用上下文无关文法  

以下提到的文法均为上下文无关文法

![image-20231221204806021](编译原理.assets/image-20231221204806021.png)

### 推导

将待处理的串中的某个非终结符号替换为这个非终结符号的某个产生式的体(右部)

从起始符号出发，不断进行上面的替换，就可以得到文法的不同句型

![image-20231221205613375](编译原理.assets/image-20231221205613375.png)

### 句型/句子/语言

![image-20231221205826776](编译原理.assets/image-20231221205826776.png)

![image-20231221205940184](编译原理.assets/image-20231221205940184.png)

### 最左/最右推导

![image-20231221210725172](编译原理.assets/image-20231221210725172.png)

### 语法分析树

- 推导的图形表示形式
  - 根结点的标号是文法的起始符号
  - 每个叶子结点的标号是**非终结符号、终结符号或ε**
  - 每个内部结点的标号是**非终结符号**
  - 每个内部结点表示某个产生式的一次应用
  - 结点的标号为产生式头，其子结点**从左到右**是产生式的体
- 树的叶子组成的序列是根的文法符号的一个**句型**
- 一棵语法分析树可对应多个推导序列
  - 但只有**唯一的最左推导及最右推导**

**语法分析树例子**

文法： E → E + E| E ∗ E | -E | (E) | id

句子： - (id + id)

![image-20231221211024554](编译原理.assets/image-20231221211024554.png)

### 词法分析和语法分析的比较

![image-20231221211530677](编译原理.assets/image-20231221211530677.png)

### 上下文无关文法和正则表达式的比较

上下文无关文法是正则表达式的超集

- 所有的正则语言都可以使用文法描述
- 但有一些用文法描述的语言不能用正则表达式描述  

**为什么使用正则表达式定义一个语言的词法语法**

- 将一个语言的语法结构分为词法和非词法可以很方便地将编译器前端模块化，将前端分解为两个大小适中的组件
- 一个语言的词法规则通常很简单，不需要使用像文法这样的功能强大的表示方法来描述这些规则
- 和文法相比，正则表达式通常提供了更加简洁且易于理解的表示词法单元的方法。
- 根据正则表达式自动构造得到的词法分析器的效率要高于任意文法自动构造得到的分析器

总结来说就是两点

1. 和文法相比，正则表达式更**加简洁且易于理解**
2. 根据正则表达式自动构造的词法分析器的**效率高**于根据任意文法自动构造得到的分析器

**什么时候使用正则表达式，什么时候使用文法？**

- 正则最适合描述id、常量、关键字这样的语言构造的结构
- 文法最适合描述**嵌套结构**，如对称的括号、对应的if-then-else等，这些无法用正则描述

### 设计文法

![image-20231222110455568](编译原理.assets/image-20231222110455568.png)

在进行高效的语法分析之前，需要对文法做以下处理

-  消除二义性

  - **二义性：**文法可以为一个句子生成多颗不同的分析树

    - 换句话说，二义性文法就是对同一个句子有多个最左推导或多个最右推导的文法

    （非二义性文法一个句子只有唯一的最左/最右推导）

    - ![image-20231222110920852](编译原理.assets/image-20231222110920852.png)
    - 程序设计语言的文法通常是无二义的 ，否则就会导致一个程序有多种“正确”的解释  

  - **消除二义性方法：**

    图中提到“最左推导中，更深层的非终结符总是会被优先替换”，这句话等价于我们真正想要的推导放到更深的层次，

    ![image-20231222111804975](编译原理.assets/image-20231222111804975.png)

    ![image-20231222113046150](编译原理.assets/image-20231222113046150.png)

- 消除左递归

  - ![image-20231224093024366](编译原理.assets/image-20231224093024366.png)

  - 消除左递归方法：

    - **直接左递归：**根据公式消除

      ![image-20231224093841535](编译原理.assets/image-20231224093841535.png)

      举个例子：
      $$
      \begin{aligned} 
      E&->E+T|T  (1)\\
      T&->T*F|F  (2)\\
      F&->(E)|id (3)
      \end{aligned}
      $$
      解决过程：直接套公式：
      $$
      (1)\\
      E->E+T|T \\
      变成\\
      E->TE'\\
      E'->+TE'| \epsilon\\
      \\
      (2)\\
      T->T*F|F \\
      变成\\
      T->FT'\\
      T'->*FT'| \epsilon\\
      \\
      (3)\\
      没有左递归不需要变换\\
      F->(E)|id
      $$
      
    - 间接左递归
    
      - 消除直接左递归的方法无法作用于间接左递归
      - 消除间接左递归的方法见龙书4.3.3节（考试不考）
  
- 提取左公因子

  详情见预测语法分析章节

### 自顶向下的语法分析

#### 递归向下的语法分析

通用的递归下降技术可能需要**回溯**



![image-20231224092823530](编译原理.assets/image-20231224092823530.png)

![image-20231224092756386](编译原理.assets/image-20231224092756386.png)



**注意避免左递归的情况，需要消除左递归，具体如何消除左递归见设计文法章节**



#### 基于预测的语法分析

虽然基于预测的语法分析也是自顶向下，但是与递归下降的语法分析不同，基于预测语法分析根据下一字符，预测正确的产生式，从而避免回溯

##### 简介

- 试图从开始符号推导出输入符号串

- 每次为最左边的非终结符号选择适当的产生式

  - 通过查看下一个输入符号来选择这个产生式

  - 例子

    - 文法：

      ```
      A->aX | bY 
      X->xxx 
      Y->yyy
      ```

    -  输入：axxx

  - 当两个产生式具有相同前缀时无法预测  

    例如：

    - 文法： 

      ```
      A->aX | aY 
      X->xxx 
      Y->yyy
      ```

    - 输入：axxx

    **我们需要提取公因子**

##### 提取公因子的文法变换

![image-20231224100141710](编译原理.assets/image-20231224100141710.png)

##### 预测分析法：LL（k）

- L: left-to-right 从左到右扫描
- L: left-most 最左推导
- k: 向前看k个符号
  - 实践当中，通常k=1，即LL(1)
  - 每次为最左边的非终结符号选择产生式时，向前看1个输入符号，预测要使用的产生式

##### FIRST和FOLLOW

![image-20231224100801716](编译原理.assets/image-20231224100801716.png)

在上面表述中

FIRST对应

- $\alpha\rightarrow^*a$
- $\alpha\rightarrow^*\epsilon$

FOLLOW对应

- $\beta$以a开头

因此FIRST和FOLLOW相结合就能完成选择

###### FIRST

- FIRST(α)

  - FIRST
  - 可以从α推导得到串的首符号的集合
  - 如果$\alpha⇒^∗ \epsilon$，那么$\epsilon$也在FIRST(α)中

- FIRST函数的意义

  - FIRST(α)的意义在于可以对文法符号串α向前看下一个输入符号a，如果当前句子的下一个输入符号b在FIRST(α)里面，则选择文法符号串α

  - 假设A的产生式 $A \rightarrowα | β$，且FIRST(α)和FIRST(β)不相交

    当下一个输入符号是a，若a ∈ FIRST(α)，则选择$A\rightarrowα$，若a ∈ FIRST(β)，则选择$A\rightarrowβ$

**FIRST(X)的计算方法**

- X是终结符号，那么添加X
- X是非终结符号，且$X\rightarrow Y_1Y_2…Y_k$是产生式
  - 如果a在FIRST($Y_i$)（注意下标是i不是1）中，且ε在FIRST($Y_1$), … , FIRST($Y_{i-1}$)中，那么也添加a
  - 如果ε在FIRST($Y_1$), … , FIRST($Y_k$)中，那么也添加ε
- X是非终结符号且$X\rightarrowε$，那么也添加ε

计算FIRST($X_1X_2…X_n$)

- 加入FIRST(X1)中所有非ε符号
- 若ε在FIRST(X1)中，加入FIRST(X2)中所有非ε符号 …
- 若ε在所有FIRST(Xi)中，也加入ε

![image-20231224103800063](编译原理.assets/image-20231224103800063.png)

###### FOLLOW

FOLLOW(A)

- 可能在某些句型中紧跟在A右边的终结符号的集合
- 例如：$S\rightarrowαAaβ$，终结符号a ∈ FOLLOW(A)

 FOLLOW函数的意义

- 如果$A\rightarrowα$，当$α \rightarrow\epsilon$ 时，FOLLOW(A)可以帮助我们选择恰当的产生式
- 例如：$A\rightarrowα$，而b属于FOLLOW(A)，如果$α \rightarrow\epsilon$ ，而当前输入符号是b，则可以选择$A\rightarrowα$，因为A最终到达了$\epsilon$，而且后面跟着b

**FOLLOW的计算方法**

- 将输入结束标记$加入FOLLOW(S)中
- 按照下面两个规则不断迭代，直到所有的FOLLOW集合都不再增长为止
  - 如果存在产生式$A\rightarrowαBβ$，那么FIRST(β)中所有非ε的符号都加入FOLLOW(B)中
  - 如果存在一个产生式$A\rightarrowαB$，或者$A\rightarrowαBβ$且FIRST(β)包含ε，那么FOLLOW(A)中所有符号都加入FOLLOW(B)中

**由于$\alpha，\beta$表示可能为空的文法符号串，S表示开始符号（非终结符号），A、B、C等表示非终结符号**

**我们可以对以上计算方法写的更明白一点：**

**规则1：（FIRST($\beta$)不为空，且不仅仅包含$\epsilon$）**

**产生式$A\rightarrowαBβ$**

- 如果$\alpha$为空，产生式为：$A\rightarrow Bβ$
- 如果$\alpha$不为空，$A\rightarrowαBβ$

也就是说，如果产生式为：
$$
A\rightarrow Bβ\\
A\rightarrowαBβ\\
$$
中的任意一个，那么**FIRST(β)中所有非ε的符号都加入FOLLOW(B)中**

**规则2：(FIRST($\beta$)为空，或包含$\epsilon$)**

> 规则2简而言之就是：
>
> 假设存在A->$\alpha BC$,寻找当前产生式最后一个非终结符C和倒数第二个非终结符B
>
> $\alpha$可以为空，也就是A-> BC
>
> - 一定能执行的：FOLLOW(A）的所有符号加入最后一个非终结符FOLLOW(B)
> - 如果最后一个非终结符C的FIRST(C)含有$\epsilon$，那么FOLLOW(A)的所有符号也能加入FOLLOW(B)

产生式$A\rightarrowαB$或产生式$A\rightarrowαBβ$且FIRST($\beta$)包含$\epsilon$，

根据$\alpha和\beta$是否为空，有以下情况
$$
A\rightarrow B(1)\\ 
A\rightarrow αB(2)\\
A\rightarrow Bβ(3)\\
A\rightarrowαBβ(4)\\
$$
若出现上述产生式，

- 对于（1）和（2），FOLLOW(A)中所有符号都加入FOLLOW(B)中
- 对于（3）和（4），如果FIRST($\beta$)包含$\epsilon$，那么FOLLOW(A)中所有符号都加入FOLLOW(B)中

> 总结：FOLLOW表示下一个输入符号
>
> FOLLOW计算方法如下：
>
> 1. 我们首先判断FIRST($\beta$)是否含有$\epsilon$
>    - 如果含有，那么能使用规则2
>      - 进一步判断是否含有除了$\epsilon$以外的符号，如果含有，那么能使用规则1
> 2. 如果不含有，则判断FIRST($\beta$)是否为空
>    - 如果为空，则使用规则2
>    - 如果不为空，则使用规则1

![image-20231224104503656](编译原理.assets/image-20231224104503656.png)

###### FIRST和FOLLOW例子求解过程

计算FIRST和FOLLOW时都需要把所有产生式遍历一遍，直到所有的FIRST集合和FOLLOW集合不再增长为止

文法列举如下：
$$
E\rightarrow TE'(1)\\
E'\rightarrow+TE'|\epsilon(2)\\
T\rightarrow FT'(3)\\
T' \rightarrow *FT'|\epsilon(4)\\
F\rightarrow (E)|id(5)\\
$$
**首先求FIRST**

依次扫描所有式子

第一次迭代：

1. (1)式没有终结符号
   $$
   \begin{aligned}
   FIRST(E)&=\{\}\\
   FIRST(E')&=\{\}\\
   FIRST(T)&=\{\}\\
   FIRST(T')&=\{\}\\
   FIRST(F)&=\{\}\\
   \end{aligned}
   $$

2. (2)式出现终结符号，FIRST(E')={+,$\epsilon$}
   $$
   \begin{aligned}
   FIRST(E)&=\{\}\\
   FIRST(E')&=\{+,\epsilon\}\\
   FIRST(T)&=\{\}\\
   FIRST(T')&=\{\}\\
   FIRST(F)&=\{\}\\
   \end{aligned}
   $$

3. （3）式没有终结符号
   $$
   \begin{aligned}
   FIRST(E)&=\{\}\\
   FIRST(E')&=\{+,\epsilon\}\\
   FIRST(T)&=\{\}\\
   FIRST(T')&=\{\}\\
   FIRST(F)&=\{\}\\
   \end{aligned}
   $$

4. （4）式出现终结符号，FIRST(T')={*,$\epsilon$}
   $$
   \begin{aligned}
   FIRST(E)&=\{\}\\
   FIRST(E')&=\{+,\epsilon\}\\
   FIRST(T)&=\{\}\\
   FIRST(T')&=\{*,\epsilon\}\\
   FIRST(F)&=\{\}\\
   \end{aligned}
   $$

5. （5）式出现终结符号，FIRST(F)=\{(,id}
   $$
   \begin{aligned}
   FIRST(E)&=\{\}\\
   FIRST(E')&=\{+,\epsilon\}\\
   FIRST(T)&=\{\}\\
   FIRST(T')&=\{*,\epsilon\}\\
   FIRST(F)&=\{(,id\}\\
   \end{aligned}
   $$
   

第一次迭代完成，第二次迭代，扫描第一次没有终结符号的式子（1）和（3）

1. (1)式FIRST(T)未知，跳过
   $$
   \begin{aligned}
   FIRST(E)&=\{\}\\
   FIRST(E')&=\{+,\epsilon\}\\
   FIRST(T)&=\{\}\\
   FIRST(T')&=\{*,\epsilon\}\\
   FIRST(F)&=\{(,id\}\\
   \end{aligned}
   $$
   
2. （3）式FIRST(F)和FIRST(T')已知

   - 按照规则1：FIRST(F)内除了”$\epsilon$“还有别的终结符号”(“，将其加入FIRST(T)中
   - 按照规则2：FIRST(F)和FIRST(T')均含有”$\epsilon$“，将其加入FIRST(T)中

   综上，FIRST(T)={（，$\epsilon$}
   $$
   \begin{aligned}
   FIRST(E)&=\{\}\\
   FIRST(E')&=\{+,\epsilon\}\\
   FIRST(T)&=\{(,id\}\\
   FIRST(T')&=\{*,\epsilon\}\\
   FIRST(F)&=\{(,id\}\\
   \end{aligned}
   $$
   

第二次迭代结束，第三次迭代，扫描式子(1)

1. FIRST(T)和FIRST(E')均已知

   - 按照规则1：FIRST(T)内除了”$\epsilon$“还有别的终结符号”(“，将其加入FIRST(E)中
   - 按照规则2：FIRST(F)和FIRST(T')均含有”$\epsilon$“，将其加入FIRST(E)中

   综上，FIRST(T)={（，$\epsilon$}
   $$
   \begin{aligned}
   FIRST(E)&=\{(,id\}\\
   FIRST(E')&=\{+,\epsilon\}\\
   FIRST(T)&=\{(,id\}\\
   FIRST(T')&=\{*,\epsilon\}\\
   FIRST(F)&=\{(,id\}\\
   \end{aligned}
   $$
   

**接着求FOLLOW**

> $\alpha，\beta$表示可能为空的文法符号串（可以是终结符号，也可以是非终结符号），S表示开始符号（非终结符号），A、B、C等表示非终结符号

根据以上FOLLOW计算方法的总结

1. 我们首先判断FIRST($\beta$)是否含有$\epsilon$，如果含有，两个规则都能用
2. 如果不含有，则判断FIRST($\beta$)是否为空
   - 如果为空，则使用规则2
   - 如果不为空，则使用规则1

同样，FOLLOW也需要扫描所有式子

首先含有开始符号的式子初始化，加入$符号
$$
\begin{aligned}
FOLLOW(E)&=\{\$\}\\
FOLLOW(E')&=\{\}\\
FOLLOW(T)&=\{\}\\
FOLLOW(T')&=\{\}\\
FOLLOW(F)&=\{\}\\
\end{aligned}
$$
第一次迭代：

1. 根据(1)式查询FIRST(E')，查询发现FIRST(E')不只是包含$\epsilon$，那么可以使用规则1和规则2

   - 规则1：FIRST(E')所有非$\epsilon$的符号加入FOLLOW(T)中，所以FOLLOW(T)={$+,\$$}
   - 规则2：我们可以视作 E->T$\beta$ (FIRST($\beta$ )包含$\epsilon$)或 E->TE'
     - E->T$\beta$ (FIRST($\beta$ )包含$\epsilon$)：FOLLOW(E)的所有符号都加入FOLLOW(T)，即：将"$"加入FOLLOW(T)
     - E->TE'：FOLLOW(E)的所有符号都加入FOLLOW(E')，即：将"$"加入FOLLOW(E')

   $$
   \begin{aligned}
   FOLLOW(E)&=\{\$\}\\
   FOLLOW(E')&=\{\$\}\\
   FOLLOW(T)&=\{\$,+\}\\
   FOLLOW(T')&=\{\}\\
   FOLLOW(F)&=\{\}\\
   \end{aligned}
   $$

2. （2）式略，没变化

3. 根据(3)式查询FIRST(T')，查询发现FIRST(T')不只是包含$\epsilon$，那么可以使用规则1和规则2

   - 规则1：FIRST(T')所有非$\epsilon$的符号加入FOLLOW(F)中，所以FOLLOW(F)={$*$}
   - 规则2：
     - FOLLOW(T)的所有符号都加入FOLLOW(T')，即：将"$"和"+"加入FOLLOW(T')
     - 因为FIRST(T')包含$\epsilon$,FOLLOW(T)的所有符号$\{\$,+\}$都加入FOLLOW(F)，即：FOLLOW(F)=$\{\$,+,*\}$

   $$
   \begin{aligned}
   FOLLOW(E)&=\{\$\}\\
   FOLLOW(E')&=\{\$\}\\
   FOLLOW(T)&=\{\$,+\}\\
   FOLLOW(T')&=\{\$,+\}\\
   FOLLOW(F)&=\{\$,+,*\}\\
   \end{aligned}
   $$

   

4. （4）式也没变化，不信你看

   根据(4)式查询FIRST(T')，查询发现FIRST(T')不只是包含$\epsilon$，那么可以使用规则1和规则2

   - 规则1：FIRST(T')所有非$\epsilon$的符号加入FOLLOW(F)中，即：将"*"加入FOLLOW(T')
   - 规则2：
     - FOLLOW(T’)的所有符号都加入FOLLOW(T')
     - 因为FIRST(T')包含$\epsilon$,FOLLOW(T‘)的所有符号$\{\$,+\}$都加入FOLLOW(F)，即：FOLLOW(F)=$\{\$,+,*\}$

   $$
   \begin{aligned}
   FOLLOW(E)&=\{\$\}\\
   FOLLOW(E')&=\{\$\}\\
   FOLLOW(T)&=\{\$,+\}\\
   FOLLOW(T')&=\{\$,+\}\\
   FOLLOW(F)&=\{\$,+,*\}\\
   \end{aligned}
   $$

   

5. 根据(5)式查询FIRST(')')

   - 规则1：FIRST(T')所有非$\epsilon$的符号加入FOLLOW(F)中，即：将")"加入FOLLOW(E)
   - FIRST(')')不含有$\epsilon$规则2无法使用

   $$
   \begin{aligned}
   FOLLOW(E)&=\{\$,)\}\\
   FOLLOW(E')&=\{\$\}\\
   FOLLOW(T)&=\{\$,+\}\\
   FOLLOW(T')&=\{\$,+\}\\
   FOLLOW(F)&=\{\$,+,*\}\\
   \end{aligned}
   $$

   

**第二次迭代不用看规则1了，因为FIRST不会改变**

1. 根据(1)式查询FIRST(E')，查询发现FIRST(E')不只是包含$\epsilon$，那么可以使用规则1和规则2

   - 规则2：
     - FOLLOW(E)的所有符号都加入FOLLOW(T)，即：将"）"加入FOLLOW(T)
     - FOLLOW(E)的所有符号都加入FOLLOW(E')，即：将"）"加入FOLLOW(E')

   $$
   \begin{aligned}
   FOLLOW(E)&=\{\$,)\}\\
   FOLLOW(E')&=\{\$,)\}\\
   FOLLOW(T)&=\{\$,+,)\}\\
   FOLLOW(T')&=\{\$,+\}\\
   FOLLOW(F)&=\{\$,+,*\}\\
   \end{aligned}
   $$

2. (2)式略

3. 根据(3)式查询FIRST(E')，查询发现FIRST(E')不只是包含$\epsilon$，那么可以使用规则1和规则2

   - 规则2：
     - FOLLOW(T)的所有符号都加入FOLLOW(F)，即：将"）"加入FOLLOW(F)
     - FOLLOW(T)的所有符号都加入FOLLOW(T')，即：将"）"加入FOLLOW(T')

   $$
   \begin{aligned}
   FOLLOW(E)&=\{\$,)\}\\
   FOLLOW(E')&=\{\$,)\}\\
   FOLLOW(T)&=\{\$,+,)\}\\
   FOLLOW(T')&=\{\$,+,)\}\\
   FOLLOW(F)&=\{\$,+,*,)\}\\
   \end{aligned}
   $$

   至此所有迭代结束

#### LL(1)文法

![image-20231224164353058](编译原理.assets/image-20231224164353058.png)

##### 预测分析表构造算法

![image-20231224165926184](编译原理.assets/image-20231224165926184.png)

![image-20231224165946521](编译原理.assets/image-20231224165946521.png)

##### 预测分析表冲突

**悬空else问题**

略

**二义性文法没有对应的LL(1)文法，或者说，LL(1)文法一定是无二义性的**

##### LL(1)文法的递归下降分析

![image-20231224170622355](编译原理.assets/image-20231224170622355.png)

#### 非递归的预测分析

##### **使用栈代替递归**

分析时的处理过程

- 初始化时，栈中仅包含开始符号S (和$)
  - 如果栈顶元素是终结符号，那么跟输入进行匹配
  - 如果栈顶元素是非终结符号
    - 使用预测分析表来选择适当的产生式
    - 在栈顶用产生式右部替换产生式左部
- 对所有文法的预测分析都可以用同样的驱动程序

##### 预测分析算法

![image-20231224185427402](编译原理.assets/image-20231224185427402.png)

##### 预测分析例子

按照前面举例的预测分析表和文法，对输入id+id*id进行处理，处理过程如下：

![image-20231224191203067](编译原理.assets/image-20231224191203067.png)

**部分输出如下图，语法分析树根据输出结果进行绘制**

![image-20231224191329255](编译原理.assets/image-20231224191329255.png)

#### 自顶向下语法分析的局限

![image-20231224191454605](编译原理.assets/image-20231224191454605.png)

### 自底向上的语法分析

#### 归约

自底向上的语法分析过程可以看成是从串w归约为文法开始符号S的过程  

> 引入句柄概念后，归约就是将句柄还原成对应产生式左边的非终结符号的过程

归约步骤：一个与某产生式体匹配的特定子串被替换为该产生式头的非终结符号

![image-20231224214121599](编译原理.assets/image-20231224214121599.png)

#### 句柄

![image-20231224214325469](编译原理.assets/image-20231224214325469.png)

#### 移入-归约分析技术

- 使用一个栈来保存归约/扫描移入的文法符号
- 栈中符号 (从底向上) 和待扫描的符号组成了一个最右句型
- 开始时刻：栈中只包含\$，而输入为w\$
- 结束时刻：栈中为S\$，而输入为\$
- 在分析过程中，不断移入符号，并在识别到句柄时进行归约
- 句柄被识别时总是出现在栈的顶部

移入：将下一个输入符号移入到栈顶

- 当无法归约时移入

归约：将句柄归约为相应的非终结符号

- **句柄总是在栈顶**

  - 具体解释如下：

    ![image-20231224221249707](编译原理.assets/image-20231224221249707.png)

- 具体操作时弹出句柄，压入被归约到的非终结符号

接受：宣布分析过程成功完成

报错：发现语法错误，调用错误恢复子程序

![image-20231224215325558](编译原理.assets/image-20231224215325558.png)

##### 移入-归约分析中的冲突

对于有些不能使用移入-归约分析的文法，不管用什么样的移入-归约分析器都会到达这样的格局

- 即使知道栈中所有内容、以及后续k个输入符号，仍然

  - 无法知道是否该进行归约(移入-归约冲突)
  - 或无法知道按照什么产生式进行归约(归约-归约冲突)

- 产生移入/归约冲突的原因：

  设栈中符号串是αβ，接下来的k个符号是x，产生移入/归约冲突的原因是存在y和y'使得aβxy是最右句型且β是句柄 (需归约)，而aβxy'也是最右句型，但是句柄的剩余部分还在右边 (需移入)

**举个例子**

1. 移入-归约冲突：

   程序不知道应该移入还是应该归约

   解决方法：规定优先级，保证移入或归约中有一个先进行

![image-20231224221544998](编译原理.assets/image-20231224221544998.png)

![image-20231224221611523](编译原理.assets/image-20231224221611523.png)

2. 归约-归约冲突：

   由于文法没有细分变量类型对应的词法单元名字，程序不知道归约哪个产生式

   解决方法也很简单：根据变量类型区分开不同词法单元名字即可

   ![image-20231224222258027](编译原理.assets/image-20231224222258027.png)

#### LR语法分析技术

LR(k)的语法分析概念

- L表示最左扫描，R表示**反向**构造出**最右推导**
- k表示最多向前看k个符号

当k增大时，相应的语法分析器的规模急剧增大

- k = 2时，程序语言的语法分析器的规模通常非常庞大
- 当k = 0, 1时，已经可以解决很多语法分析问题，因此具有实践意义
- 我们只考虑k <= 1的情况

##### LR语法分析器的优点（了解即可）

- 由表格驱动，虽然手工构造表格工作量很大，但表格可以自动生成
- 对于几乎所有的程序设计语言，只要写出上下文无关文法，就能够构造出识别该语言的LR语法分析器Ø 最通用的无回溯移入-归约分析技术
- 能分析的文法比LL(k)文法更多

##### LR语法分析思路

![image-20231224223327454](编译原理.assets/image-20231224223327454.png)

## ![image-20231224223357293](编译原理.assets/image-20231224223357293.png)

![image-20231224223440889](编译原理.assets/image-20231224223440889.png)

项：产生式和加上在其中某处的一个点

LR(0)项集规范族：一组项集，提供构建一个确定有穷自动机的基础

LR(0)自动机：每个状态代表了LR(0)项集规范族的一个项集

##### LR(0)项集规范族的构造  

三个相关定义

- 增广文法（引入起始状态）
- 项集闭包CLOSURE （状态机确定化）
-  GOTO函数（定义状态跳转）

###### 增广文法

引入新的开始产生式目的是：告诉语法分析器何时应该停止语法分析并宣称接受输入符号串（说人话就是，让接收状态只有一个，方便自动机执行）

- G的增广文法G'是在G中增加新开始符号S'，并加入产生式S'->S而得到的
- 显然G'和G接受相同的语言，且按照S'->S进行归约实际上就表示已经将输入符号串归约成为开始符号
- 方便引入S的项，表示识别的起始(S’->·S)/结束(S' ->S·)

###### 项集闭包CLOSURE  

![image-20231224225217485](编译原理.assets/image-20231224225217485.png)

![image-20231224225227547](编译原理.assets/image-20231224225227547.png)

![image-20231224231405512](编译原理.assets/image-20231224231405512.png)

###### GOTO函数

![image-20231224232209438](编译原理.assets/image-20231224232209438.png)

###### 求规范LR(0)项集族的算法  

![image-20231224232435792](编译原理.assets/image-20231224232435792.png)



###### 规范LR(0)项集族构造示例

![image-20231225164820060](编译原理.assets/image-20231225164820060.png)

以第一次迭代为例，以下是算法执行过程：

![image-20231225164812571](编译原理.assets/image-20231225164812571.png)

之后重复算法执行，直到没有新的项集产生为止

##### LR(0)自动机

###### 构造方法

- 基于规范LR(0)项集族可以构造LR(0)自动机
- **规范LR(0)项集族中的每个项集对应于LR(0)自动机的一个状态**
- 状态转换：如果GOTO(I, X) = J，则从 I 到 J有一个标号为 X的转换
- **开始状态为CLOSURE({ S' ->·S })对应的项集**
- 所有状态都是接受状态

###### 作用 

假设文法符号串γ 使LR(0)自动机从开始状态运行到状态 (项集) j 

 （1）如果j中存在项A->α·，那么

- α是γ 的后缀，且是该句型的句柄 (对应于产生式A->α)
- 表示可能找到了当前最右句型的句柄，可以归约
- 在γ 之 后 添 加 一 些 终 结 符 号 可 以 得 到 一 个 最 右 句 型

（2）如果j中存在项B ->α·Xβ，那么

- 该句型中αXβ是句柄，但还没找到，还需移入
- 在γ 之后添加Xβ和一些终结符号可以得到一个最右句型

**LR(0)自动机的使用**

- 移入-归约时，LR(0)自动机被用于识别句型
- 已得到的文法符号序列对应于LR(0)自动机的一条路径

无需每次用该文法符号序列来运行LR(0)自动机

- 文法符号可省略，由LR(0)状态可确定相应的文法符号
  - 状态间的转换是唯一的，转换边上有文法符号
- 在移入后，根据原来的栈顶状态可以知道新的状态
  - **根据原栈顶状态和移入符号，查询GOTO**
  - 在归约时，根据归约产生式的右部长度弹出相应状态，也可以根据此时的栈顶状态知道新的状态
- **归约相当于先弹出，再移入**
- **归约产生式的选择根据当前栈顶状态的项决定，也就是前面作用章节提到的(1)**

**LR(0)自动机的作用的演示**  

对照以下项集转换图和自动机执行过程一起看

![image-20231225171434870](编译原理.assets/image-20231225171434870.png)

**该自动机执行步骤见龙书P157 例4.43**

补充几点：

1. 如果状态$I_i$通过带有文法符号$\alpha$的边转换到状态$I_j$，且当前状态$I_j$位于栈顶，那么要归约时，根据归约的产生式右边，弹出产生式右边对应的所有文法符号对应的状态

   举个例子：

   第7行，当前栈顶位状态10，且需要按照T->T*F归约，那么需要从状态10依次弹出T、\*、F对应的状态，弹出状态次序为：10->7->2，弹出后栈只剩状态0；弹出之后移入产生式左边的符号对应的状态，即需要移入状态0经过T到达的状态2，移入之后，栈为状态0 2

2. **归约产生式的选择根据当前栈顶状态的项和当前栈顶状态对应的文法符号决定**

   举个例子：

   第8行，当前栈顶状态为2，只有项E->T·最右边是点·，所以选择这个产生式进行归约

   第7行，当前栈顶状态为10，对应的文法符号为F，项的右边为T*F，这表示产生式为T->T\*F

3. 最后栈顶状态为1，有输入符号$对应的边，直接移入，到达状态accept

![image-20231225171248143](编译原理.assets/image-20231225171248143.png)

#### LR语法分析算法  

LR语法分析与前面介绍的**移入归约分析**有点像，只是将栈内移入的文法符号替换为了状态数

另外，仿照**LR(0)分析技术**，引入了ACTION和GOTO函数

**语法分析器决定下一个动作时，首先读入当前输入符号$a_i$和栈顶状态$s_m$**

![image-20231225205248845](编译原理.assets/image-20231225205248845.png)

所有LR语法分析器按照一下算法执行，不同LR语法分析器唯一的区别在于：它们的语法分析表的ACTION项和GOTO表项中包含的信息不同

![image-20231225204519632](编译原理.assets/image-20231225204519632.png)

##### LR分析过程的例子

> $s_i$表示移入并将状态i压栈
>
> $r_j$表示按照编号为j的产生式归约
>
> acc表示接受
>
> 空白表示报错

![image-20231225205909404](编译原理.assets/image-20231225205909404.png)

![image-20231225205924831](编译原理.assets/image-20231225205924831.png)

#### SLR语法分析算法

> **以LR(0)自动机为基础的意思是，已经通过LR(0)自动机获取了所有项集和所有GOTO函数**
>
> 根据得到的项集和GOTO函数构造ACTION表和GOTO表

![image-20231225212308740](编译原理.assets/image-20231225212308740.png)

##### SLR语法分析例子

![image-20231225171434870](编译原理.assets/image-20231225171434870.png)

![image-20231225212338773](编译原理.assets/image-20231225212338773.png)

**每个SLR(1)文法都是无二义性的，但是存在很多不是SLR(1)的无二义性文法**

**SLR语法分析器有许多弱点，有更强大的LR语法分析器**

![image-20231225214832963](编译原理.assets/image-20231225214832963.png)

#### 规范LR(1)项方法

最通用的为文法构造LR语法分析表的技术

**LR（1）项**

![image-20231226093811299](编译原理.assets/image-20231226093811299.png)

**可行前缀：**

可以出现在一个移入-归约语法分析器的栈中的最右句型前缀被称为可行前缀

可行前缀的定义为：一个可行前缀是一个最右句型的前缀，并且它没有越过该最右句型的最右句柄的右端

根据这个定义，我们总是可以在一个可行前缀之后增加一些终结符号来得到最右句型



##### LR(1)项集族构造方法

![image-20231226093915461](编译原理.assets/image-20231226093915461.png)

![image-20231226094024717](编译原理.assets/image-20231226094024717.png)

![image-20231226094030589](编译原理.assets/image-20231226094030589.png)

![image-20231226094039929](编译原理.assets/image-20231226094039929.png)

##### LR(1)项集族构造例子

![image-20231226210715358](编译原理.assets/image-20231226210715358.png)

![image-20231226210810082](编译原理.assets/image-20231226210810082.png)

![image-20231226210823286](编译原理.assets/image-20231226210823286.png)

##### LR(1)语法分析表的构造

向前看符号细化了归约的条件

![image-20231226210907573](编译原理.assets/image-20231226210907573.png)

![image-20231226211452906](编译原理.assets/image-20231226211452906.png)

![image-20231226211601263](编译原理.assets/image-20231226211601263.png)

#### LALR方法

- SLR(1)语法分析表的分析能力较弱
- LR(1)语法分析表的状态数量很大
- LALR(1)是实践中常用的方法
  - 状态数量和SLR(1)的状态数量相同
  - 能够方便地处理大部分常见程序设计语言的构造

**LALR技术本质**  

对LR(1)项集规范族中的同核心项集进行合并

- 使得分析表保持了LR(1)项中的向前看符号信息
- 又使状态数减少到与SLR分析表的一样多

![image-20231226214456142](编译原理.assets/image-20231226214456142.png)

**！注意：**

原来无冲突的LR(1)分析表在合并之后得到LALR(1)分析表，新表中可能存在冲突

- 合并不会导致移入/归约冲突
- 合并会引起归约/归约冲突，即不确定按照哪个产生式进行归约  

![image-20231226214650858](编译原理.assets/image-20231226214650858.png)

![image-20231226214803291](编译原理.assets/image-20231226214803291.png)



![image-20231226214902690](编译原理.assets/image-20231226214902690.png)



#### LALR分析器和LR分析器  

处理语法正确的输入时，LALR语法分析器和LR语法分析器的动作序列完全相同

- 栈中的状态名字不同，但是状态序列之间有对应关系
- 如果LR分析器压入状态$I$，那么LALR分析器压入$I$对应的合并项集
  - 当LR分析器压入状态$I_3$时，LALR分析器压入状态$I_{36}$

当处理错误的输入时，LALR可能多执行一些归约动作，但不会多移入一个符号

- 也就是不会发生移入-归约冲突



## Chapter 5：语法制导定义（语法分析）

本章节可分为以下部分

- 语义分析
  - 计算程序构造的语义信息  
  - 检查程序是否符合语言的语义规则
  - 类型规则、变量使用规则、函数调用规则……
- 语法制导定义 (Syntax-Directed Definition)
  - **三要素：文法、属性 (继承/综合)、产生式规则**
  -  **属性值表示语义信息、产生式规则计算语义信息**
- SDD的其它应用– 抽象语法树 (AST)、代码翻译
- 语法制导翻译 (Syntax-Directed Translation)
  - 明确指定SDD语义动作的执行时机
  - SDT的实现 (遍历语法树/与语法分析同步进行)

### 语法制导的定义  

Syntax-Directed Definition (SDD) 是上下文无关文法和属性/规则的结合

- 属性和文法符号相关联，按照需要来确定各个文法符号需要哪些属性
- 规则和产生式相关联

**SDD三要素：⽂法、属性、规则**

对于文法符号X和属性a，我们用X.a表示分析树中某个标号为X的结点的值

一个分析树结点和它的分支对应一个产生式规则，而对应的语义规则确定了这些结点上属性的取值和计算语法制导的定义 (SDD)

**基于SDD，我们可以在⼀个程序的分析树上进⾏语义信息的计算**

#### 综合属性 (Synthesized Attribute)

**【自底向上】**

结点N的属性值由N的产生式所关联的语义规则来定义

通过N的子结点或N本身的属性值来定义

#### 继承属性 (Inherited Attribute)

**【自顶向下】**

结点N的属性值由N的父结点所关联的语义规则来定义

依赖于N的父结点、N本身和N的兄弟结点上的属性值

**我们不允许节点N上的继承属性通过N的子节点上的属性值来定义，但允许节点N上的一个综合属性通过节点N本身的继承属性来定义**

**终结符号可以具有综合属性，但不能具有继承属性**

**终结符号的属性值是由词法分析器提供的词法值，在SDD中没有计算终结符号的属性值的语义规则**

> **属性值**是对象或实体的属性直接取值。
>
> **综合属性值**是通过计算规则或逻辑从其他属性值中派生而来的值。
>
> **继承属性值**是从父类或上级对象继承而来的属性值，如果子类没有显式设置某个属性值，系统会查找父类是否有对应的属性值。



### SDD的求值顺序

#### 注释语法分析树 (annotated parse tree)

- 包含了各个结点的各属性值的语法分析树

步骤

- 对于任意的输入串，首先构造出相应的分析树
- 给各个结点 (根据其文法符号) 加上相应的属性
- 按照语义规则计算这些属性的值

**语法分析树上的SDD求值**   

按照分析树中的分支对应的文法产生式，应用相应的语义规则计算属性值

计算顺序

- 如果某个结点N的属性a为f(N1.b1, N2.b2, …, Nk.bk)，那么我们需要先算出N1.b1, N2.b2, …, Nk.bk的值

如果可以给各个属性值排出计算顺序，那么这个注释分析树就可以计算得到

- S属性的SDD一定可以按照自底向上的方式求值

![image-20231227215855948](编译原理.assets/image-20231227215855948.png)



**SDD的求值顺序**  

在对SDD的求值过程中

- 如果结点N的属性a依赖于结点$M_1$的属性$a_1$，$M_2$的属性$a_2$，…那么我们必须先计算出$M_i$的属性$a_i$，才能计算N的属性a

  $N.a =… M_1.a_1 … M_2.a_2 …  $

使用依赖图来表示计算顺序

- 这些值的计算顺序形成一个偏序关系，**如果依赖图中出现了环，表示属性值无法计算**

#### 依赖图

![image-20231227220405819](编译原理.assets/image-20231227220405819.png)

**属性值的计算顺序**  

各个属性值需要按照依赖图的拓扑顺序计算

- **如果依赖图中存在环，则属性计算无法进行**

给定一个SDD，很难判定是否存在一棵分析树，其对应的依赖图包含环

**但是特定类型的SDD一定不包含环，且有固定的计算顺序**

- **如：S属性的SDD，L属性的SDD**

### S属性的SDD

![image-20231227215440490](编译原理.assets/image-20231227215440490.png)

![image-20231227220608137](编译原理.assets/image-20231227220608137.png)

![image-20231227220747259](编译原理.assets/image-20231227220747259.png)

### L属性的SDD

![image-20231227222327698](编译原理.assets/image-20231227222327698.png)

#### L属性SDD和自顶向下语法分析

![image-20231227222535849](编译原理.assets/image-20231227222535849.png)

L属性的例子：基本类型和数组类型的L属性定义

### SDD的应用

#### 类型分析  

![image-20231228094321583](编译原理.assets/image-20231228094321583.png)

![image-20231228094557073](编译原理.assets/image-20231228094557073.png)

![image-20231228094521368](编译原理.assets/image-20231228094521368.png)

#### 语法树（Syntax Tree)

抽象语法树内部节点为运算符，叶子节点为运算分量，去除了冗余的非终结符号（例如产生式E->T这种没有实质信息的运算）

![image-20231227222839787](编译原理.assets/image-20231227222839787.png)

以下为实现AST的例子：

- 我们使用了node属性传递中间推导过程
- 只保留必要的词法元素
  - 当遇到运算符创建内部节点Node
  - 当遇到运算分量创建叶子节点Leaf

![image-20231228094637065](编译原理.assets/image-20231228094637065.png)



### 语法制导的翻译方案（SDT）

语法制导定义：产生式和语义规则区分开，每条产生式对应一个语义规则

语法制导的翻译方案：在产生式体中嵌入程序片段的一个上下文无关文法，这个程序片段称为语义动作，可以出现在产生体种所有地方

| 语法制导定义（SDD）       | 产生式$E\rightarrow E_1+T$              | 语义规则 $E.code=E_1.code||T.code||'+'$ |
| ------------------------- | --------------------------------------- | --------------------------------------- |
| 语法制导的翻译方案（SDT） | $E\rightarrow E_1+T\{E.code=E_1.code\}$ |                                         |

SDT的基本实现方法

- 建立语法分析树 (CST)
- 将语义动作看作是虚拟结点 (绑定语义动作)
- **深度优先、从左到右地遍历（先序遍历）**分析树，在访问虚拟结点时执行相应的语义动作

用SDT实现两类重要的SDD

- 基本文法是LR的，SDD是S属性的
- 基本文法是LL的，SDD是L属性的

![image-20231228150231830](编译原理.assets/image-20231228150231830.png)

#### 后缀翻译方案

**文法可以自底向上分析 (即LR的) 且其SDD是S属性的，必然可以构造出后缀SDT**

后缀SDT：所有动作都在产生式最右端的SDT

构造方法

- 将每个语义规则看作是一个赋值语义动作
- 将所有的语义动作放在规则的最右端

![image-20231228150649467](编译原理.assets/image-20231228150649467.png)



#### 产生式内部带有语义动作的SDT  

![image-20231228150839049](编译原理.assets/image-20231228150839049.png)



#### L属性的SDT  

![image-20231228151135480](编译原理.assets/image-20231228151135480.png)

![image-20231228151802630](编译原理.assets/image-20231228151802630.png)![image-20231228152707241](编译原理.assets/image-20231228152707241.png)

##### L属性SDD的实现

![image-20231228153508557](编译原理.assets/image-20231228153508557.png)

![image-20231228153722163](编译原理.assets/image-20231228153722163.png)



#### 边扫描边生成属性   

当属性值的体积很大，对其进行运算会效率很低

- code可能是一个上百K的串
- 许多代码片段被反复复制，很低效

可逐步生成属性的各个部分，并增量式地添加到最终的属性值中

三个条件

1. 存在一个主属性，且其为综合属性
2. 在产生式中，主属性是通过产生式体中各非终结符号的主属性连接而得到，同时还会连接一些其它元素
3. 各个非终结符号的主属性的连接顺序与它们在产生式体中的顺序相同

![image-20231228153953831](编译原理.assets/image-20231228153953831.png)

##### 边扫描边生成属性的例子

C函数会打印C.code，S1函数也会打印S1.code

当执行完S函数，也就打印了原来S.code的内容

![image-20231228154132479](编译原理.assets/image-20231228154132479.png)

![image-20231228154103741](编译原理.assets/image-20231228154103741.png)

## Chapter 6：中间代码生成

中间表示形式(Intermediate Representations, IRs)  有抽象语法树（AST）和三地址码

**中间代码表示的好处：**

1. 可复用：为新的机器建编译器，只需要做从中间代码到新的目标代码的翻译器(**前端独立**)
2. 高层次的优化：优化与**源语言和目标机器都无关**

**编译器前端的逻辑结构**  

![image-20231228214744859](编译原理.assets/image-20231228214744859.png)

![image-20231228214731485](编译原理.assets/image-20231228214731485.png)

### AST和三地址码的异同

- AST是高层的标识，刻画了源程序的自然的层次性结构，适用于静态类型检查这样的处理
- 中间代码紧凑、明晰的控制流信息 (易于分析与优化) ，与具体语言无关 (通用) ，与具体机器无关 (通用++)  

![image-20231228214330902](编译原理.assets/image-20231228214330902.png)

![image-20231228214338588](编译原理.assets/image-20231228214338588.png)

### 三地址代码

目标

- 接近大多数目标机器的执行模型 (机器码)
- 支持大多数目标机器提供的数据类型和操作
- 提供有限度的、高于机器码的抽象表达能力，更容易表达出大多数 (命令式)高级语言的特性

特征

- 以指令为单位
- 每条指令只有有限数量的运算分量 (通常≤3)
- 支持基本数据类型及其运算
- 支持复合数据类型 (如数组、结构体) 及其操作
- 支持函数

三地址代码基于两个概念：地址和指令

**地址**

地址可以具有以下形式：

- 变量：源程序中的名字作为三地址代码的地址
- 常量：源程序中出现或生成的常量
- 编译器生成的临时变量 (也可与源程序变量等同视之)

**指令**

每条指令右侧最多有一个运算符

- 接近机器码 (易于从机器角度优化)
- 大大减少组合情况的数量 (易于处理)

**指令集合**

![image-20231228215502765](编译原理.assets/image-20231228215502765.png)

![image-20231228215547856](编译原理.assets/image-20231228215547856.png)

- x=&y：将x的右值设置为y的地址（左值）
- x=*y：x的右值等于存储在y表述位置中的值
- *x=y：把y的右值赋给由x指向的目标的右值

### 静态单赋值 (SSA)  

![image-20231228220947044](编译原理.assets/image-20231228220947044.png)

![image-20231228220956431](编译原理.assets/image-20231228220956431.png)

![image-20231228221210881](编译原理.assets/image-20231228221210881.png)

![image-20231228221413711](编译原理.assets/image-20231228221413711.png)

![image-20231228221439494](编译原理.assets/image-20231228221439494.png)

### 类型和声明

类型检查 (Type checking)：利用一组规则来检查运算分量的类型和运算符的预期类型是否匹配

类型信息的用途：

- 查错
- 确定名字 (对应的数据) 所需的内存空间
- 计算数组元素的地址
- 类型转换
- 选择正确的运算符

类型表达式 (Typ e express ion)：表示类型的表达式

- 基本类型：类型名字
- 复合类型：通过**类型构造算子**作用于类型表达式得到

![image-20231229091659378](编译原理.assets/image-20231229091659378.png)

![image-20231229091705126](编译原理.assets/image-20231229091705126.png)

![image-20231229091712644](编译原理.assets/image-20231229091712644.png)

#### 类型等价性  

判断两个类型是否等价

- 类型检查的基础（类型检查规则一般为：如果两个类型表达式相同，那么返回某种类型，否则出错）
- 不同的语言有不同的类型等价的定义

当语言允许为自定义类型命名时，主要有两类等价性判定方式

- 名等价 ( N a m e Equivalence)
  - 类型表达式t与u等价当且仅当它们对应的类型名字相同
- 结构等价 (Structure Equivalence)
  - 对于基本类型，比较它们名字是否相同
  - 对于复合类型，比较类型构造算子；若相同，(递归) 比较构造算子的各参数分量

#### 类型的声明

![image-20231229092559273](编译原理.assets/image-20231229092559273.png)

#### 局部变量的存储布局  

变量的类型可以确定变量需要的内存

- 即类型的宽度 (该类型一个对象所需的存储单元的数量)
- 可变大小的数据结构只需要考虑指针，为指向这些数据的指针留一个已知的固定大小的存储区域

函数的局部变量总是分配在连续的区间

- 因此给每个变量分配一个相对于这个区间开始处的**相对地址 (偏移量)**

**变量的类型信息保存在符号表中**

![image-20231229093158379](编译原理.assets/image-20231229093158379.png)

![image-20231229093205694](编译原理.assets/image-20231229093205694.png)



**数组的宽度由数组元素的个数乘以单个数组元素的宽度得到**

**实际变量声明将变量的类型信息存放在符号表中，而不是上例的继承属性或全局变量**

#### 声明的序列

![image-20231229094034063](编译原理.assets/image-20231229094034063.png)

![image-20231229094041869](编译原理.assets/image-20231229094041869.png)

![image-20231229094625038](编译原理.assets/image-20231229094625038.png)

![image-20231229095044905](编译原理.assets/image-20231229095044905.png)

### 表达式的翻译

以下为语法制导定义将表达式翻译为三地址码的过程

top.get表示获取id对应词法单元名称所在的符号表条目

E.addr为存放E的地址

![image-20231229110820270](编译原理.assets/image-20231229110820270.png)



![image-20231229111225434](编译原理.assets/image-20231229111225434.png)

![image-20231229111233233](编译原理.assets/image-20231229111233233.png)

当然，我们可以使用增量翻译

![image-20231229110834190](编译原理.assets/image-20231229110834190.png)

#### 数组引用生成代码的翻译方案

##### 数组元素的寻址

$w_1对应i_1的元素,表示A[i_1]的大小，例如int A[i_1][i_2][i_3]中A[i_1]的元素为int[i_2][i_3]，即w_1=i_2*i_3*4(int.width)$

$i_1*w_1为第一个基地址，对应A[i_1]，A[i_1][i_2]表示在A[i_1]基础上偏移了i_2个元素，所以要加上i_2*w_2$

![image-20231229111709194](编译原理.assets/image-20231229111709194.png)

##### 数组引用生成代码的翻译方案

![image-20231229164653658](编译原理.assets/image-20231229164653658.png)



#### ![image-20231229164735200](编译原理.assets/image-20231229164735200.png)布尔表达式的控制流翻译

![image-20231229162009508](编译原理.assets/image-20231229162009508.png)

![image-20231229165253054](编译原理.assets/image-20231229165253054.png)

![image-20231229170008348](编译原理.assets/image-20231229170008348.png)

![image-20231229170134628](编译原理.assets/image-20231229170134628.png)

##### 布尔表达式的翻译

![image-20231229170440210](编译原理.assets/image-20231229170440210.png)

![image-20231229172625988](编译原理.assets/image-20231229172625988.png)

![image-20231229171834361](编译原理.assets/image-20231229171834361.png)

同理，不满足(1)就会自动执行(2)

![image-20231229172058460](编译原理.assets/image-20231229172058460.png)

![image-20231229172359338](编译原理.assets/image-20231229172359338.png)

![image-20231229173513008](编译原理.assets/image-20231229173513008.png)

![image-20231229173521200](编译原理.assets/image-20231229173521200.png)

### 类型检查

类型系统

- 给每一个组成部分赋予一个类型表达式
- 通过一组逻辑规则来表达类型表达式必须满足的条件
- 可发现错误、提高代码效率、确定临时变量的大小、

强类型：保证它接受的程序在运行时刻不会发生类型错误（类型错误通常发生于类型转换）

![image-20231229144145718](编译原理.assets/image-20231229144145718.png)

### 回填

![image-20231229173813566](编译原理.assets/image-20231229173813566.png)



肯定是索引好

![image-20231229174357386](编译原理.assets/image-20231229174357386.png)

![image-20231229174409263](编译原理.assets/image-20231229174409263.png)

![image-20231229174809806](编译原理.assets/image-20231229174809806.png)

![image-20231229174817937](编译原理.assets/image-20231229174817937.png)

![image-20231229200019950](编译原理.assets/image-20231229200019950.png)

![image-20231229200137273](编译原理.assets/image-20231229200137273.png)

![image-20231229200653392](编译原理.assets/image-20231229200653392.png)



![image-20231229200210877](编译原理.assets/image-20231229200210877.png)



从以上例子我们可以总结：

回填就是

- 在B.true和B.false处引入新的符号M，在B.true或B.false指向的位置回填B.truelist和B.falselist内的所有跳转指令
- 在跳转到其他地方(goto)处引入新的符号N

## Chapter 7：运行时刻环境

运行时刻环境

- 为数据分配安排存储位置
- 确定访问变量时使用的机制
- 过程之间的连接、参数传递
- 和操作系统、输入输出设备相关的其它接口

主题

- 存储管理：栈分配、堆管理、垃圾回收
- 对变量、数据的访问

运行时刻环境  

- 静态分配
  - 编译器在编译时刻就可以做出存储分配决定，不需要考虑程序运行时刻的情形
  - 全局常量、全局变量
- 动态分配
  - 栈式存储：和过程的调用/返回同步进行分配和回收，值的生命期与过程生命期相同
  - 堆存储：数据对象可比创建它的过程调用更长寿
    - 手工进行回收
    - 垃圾回收机制

### 活动树 (activation tree)  

过程调用(过程活动)在时间上总是嵌套的

- 后调用的先返回
- 因此用**栈**来分配过程活动所需内存空间

程序运行的所有过程活动可以用树表示

- 每个结点对应于一个过程活动
- **根结点对应于main过程的活动**
- 过程p的某次活动对应的结点的所有子结点
  - 表示此次活动所调用的各个过程活动
  - **从左向右，表示调用的先后顺序**
- 又称为调用树 (Call Tree)

![image-20231229202948279](编译原理.assets/image-20231229202948279.png)

### 活动记录

![image-20231229203027596](编译原理.assets/image-20231229203027596.png)

![image-20231229203116198](编译原理.assets/image-20231229203116198.png)

![image-20231229203122747](编译原理.assets/image-20231229203122747.png)

![image-20231229204357114](编译原理.assets/image-20231229204357114.png)

### 调用代码序列  

> 实现过程调用的代码段称为调用代码序列

**调用代码序列(Calling sequence)**为活动记录分配空间，填写记录中的信息

**返回代码序列(Return sequence)**恢复调用者状态，使调用者继续运行

调用代码序列会分割到调用者和被调用者中

- 根据源语言、目标机器和操作系统的限制，可以有不同的分割方案
- **把代码尽可能放在被调用者中**
  - 因为如果一个过程在n个不同点上被调用，分配给调用者的那部分调用代码序列会被生成n次，而分配给被调用者的部分只被生成一次。因此我们希望把调用代码序列尽可能放在被调用者中。

#### 调用/返回代码序列的要求  

数据方面

- 能够把参数正确地传递给被调用者
- 能够把返回值传递给调用者

控制方面 

- 能够正确转到被调用过程的代码开始位置
- 能够正确转回调用者的调用位置(的下一条指令)

调用代码序列与活动记录的布局相关

![image-20231229204438268](编译原理.assets/image-20231229204438268.png)

![image-20231229204411185](编译原理.assets/image-20231229204411185.png)

注意：Calling sequence过程中，被调用者保存调用者的寄存器信息，以便恢复。

![image-20231229205316725](编译原理.assets/image-20231229205316725.png)

因为变长数组的实际大小不知道，因此只存它们的指针在活动记录里方便寻找

### 栈中非局部数据的访问

#### 非局部数据的访问(无嵌套过程)  

没有嵌套过程时的数据访问

- C语言中，每个函数能访问的变量：
  - 函数的局部变量：相对地址已知，且存放在当前活动记录内，top_sp指针加上相对地址即可访问
  - 全局变量：在静态区，地址在编译时刻可知

对全局变量进行静态分配的一个好处：很容易将C语言的函数作为参数进行传递

- 参数中只需包括函数代码的开始地址
  - 静态分配意味着函数在内存中的位置是固定的，因此将函数作为参数时，只需传递函数的起始地址即可。
- 在函数中访问非局部变量的模式很简单，不需要考虑过程是如何激活的
  - 全局变量是在程序整个生命周期内存在的，因此无论函数何时被调用，它都可以访问这些全局变量，而无需考虑函数调用的上下文。

#### 非局部数据的访问(有嵌套过程)  

![image-20231229210051148](编译原理.assets/image-20231229210051148.png)

#### 嵌套深度

为了说明嵌套深度，我们可以先了解嵌套语言ML

![image-20231229211313629](编译原理.assets/image-20231229211313629.png)

**注意：内嵌不代表着调用，在函数内声明或调用都算内嵌**

![image-20231229211200800](编译原理.assets/image-20231229211200800.png)

#### 访问链

![image-20231229211708550](编译原理.assets/image-20231229211708550.png)

上图说的不够清楚，应该为：假定栈顶的过程p的嵌套深度为$n_p$且p需要访问x，而x是在某个包围p的嵌套深度为$n_q$的过程q中定义的一个元素。注意$n_q<=n_p$，当且仅当p和q是同一个过程时两者相等。



**补充：**

**p的深度大于q**：有一个前提需要补充，过程q调用过程p，过程p一定是已经定义了才能被过程q调用。假设过程q内嵌套了过程r的定义，过程r内嵌套过程p的定义，那么在过程q的视角，根本没有过程p的存在，也就无法调用。因此如果p的深度大于q且过程q能够调用过程p，说明过程p必然在q中直接定义

**p的深度小于q**：从q的活动记录开始，经过$n_p-n_q+1$步就能找到栈中最高的r的活动记录

![image-20231229213843610](编译原理.assets/image-20231229213843610.png)

![image-20231229213918886](编译原理.assets/image-20231229213918886.png)



在传递过程指针参数时，过程型参数中不仅包含过程的代码指针(开始地址)，还包括正确的访问链

#### 堆管理  

**堆空间**

- 用于存放生命周期不确定、或生存到被明确删除为止的数据对象
- 例如：new生成的对象可以生存到被delete为止，malloc申请的空间生存到被free为止

**存储管理器**

分配/回收堆区空间的子系统

根据语言而定

- C/C++需要手动回收空间
- Java可以自动回收空间(垃圾收集)

基本功能

- 分配：为内存请求分配一段连续、适当大小的堆空间
  - 首先从空闲的堆空间分配
  - 如果不行则从操作系统中获取内存、增加堆空间
- 回收：把被回收的空间返回空闲空间缓冲池，以满足其它内存需求。通常不会将内存返回给操作系统，即使当这个程序不再需要那么多堆空间时也不会归还给操作系统。

评价存储管理器的特性

- 空间效率：使程序需要的堆空间最小，即减小碎片
- 程序效率：运用内存系统的层次，使程序运行更快
- 低开销：使分配/收回内存的操作尽可能高效

#### 计算机的存储层次结构  

![image-20231229215935460](编译原理.assets/image-20231229215935460.png)

#### 程序中的局部性  

程序具有高度的局部性(Locality)

- 时间局部性：一个程序访问的存储位置很可能将在一个很短的时间段内被再次访问
- 空间局部性：被访问过的存储位置的临近位置很可能在一个很短的时间段内被访问

90%的时间用来执行10%的代码

局部性这一特性恰好可以充分利用计算机的层次存储结构

- 将常用的放在快而小的存储中，将其他与部分放入慢而大的存储中

#### 堆空间的碎片问题  

![image-20231229220010321](编译原理.assets/image-20231229220010321.png)

#### 堆空间分配方法  

堆空间分配有两种策略：Best-fit和First-fit

Best-fit

- 总是将请求的内存分配在满足请求的最小的窗口中
- 好处：可以将大的窗口保留下来，应对更大的请求

First-fit

- 总是将对象放置在第一个能够容纳请求的窗口中
- 放置对象时花费时间较少，但是总体性能比best-fit策略差
- 通常具有较好的数据局部性：同一时间段内生成的对象经常被分配在连续的空间内

为更好地实现Best-fit，我们可以根据空闲空间块的大小，将它们分在若干个容器中。

![image-20231229220606584](编译原理.assets/image-20231229220606584.png)

- 如果被请求的尺寸有一个专有容器，即该容器只包含该尺寸的存储块，我们可以从该容器中任意取出一个存储块（小尺寸的请求通常就是这么做的）
- 如果被请求的尺寸没有专有容器，可以选择Best-fit或First-fit策略寻找对应包含该尺寸的存储块的容器。空闲存储块的大小不是正好合适，通常将该块的剩余部分放到对应于更小尺寸的容器中。
- 如果所有容器都无法满足，使用荒野块进行拓展。

对best-fit的更进一步改进：找不到恰巧等于请求尺寸的存储块时，如果刚刚分割的存储块还有足够的空间容纳这个对象，则将这个对象放置在这个存储块中

#### 管理和接合空闲空间  

当回收一个块时，可以把这个块和相邻的块接合起来，构成更大的块

- 有些管理方法不需要进行接合

支持相邻块接合的数据结构

- 边界标记：在每个存储块的两端，分别设置一个free/used位，并在相邻的位置上存放字节总数
- 双重链接的空闲块列表：列表的指针存放在空闲块中、用双向指针的方式记录了有哪些空闲块

![image-20231229221711244](编译原理.assets/image-20231229221711244.png)

**空闲块的双向链表顺序是不确定的，也就是说一个节点的前驱并不是它邻近的块，只是另一个空闲的块**



### 垃圾回收

**人工存储管理处理存在两大问题**

- 内存泄露(Memory leak)：未能删除不可能再被引用的数据
- 悬空指针引用(Dangling pointer)：引用已被删除的数据

其他问题

- 空指针访问/数组越界访问

**垃圾**

- 广义：不需要再被引用的数据
- 狭义：不能被引用(不可达)的数据

**垃圾回收：自动回收不可达数据的机制，解除了程序员的负担**

- 提供垃圾回收机制的语言：Java、Perl、ML、Modula-3、Prolog、Smalltalk

### 垃圾回收器的设计目标  

基本要求

- 语言必须是类型安全的：保证回收器能够知道数据元素是否为一个指向某内存块的指针 
  - 静态类型ML：在编译时刻就能确定数据的类型
  - 动态类型Java：类型不能在编译时刻确定，但能在运行时刻确定
- 类型不安全的语言：程序可以在任何时候引用内存中的任何位置
  - 存储地址可以进行任意操作：可以将任意的算术运算应用于指针，创建出一个新的指针，并且任何整数都可以被强制转化为指针
  - C/C++类型不安全，但实践上也有垃圾回收器

性能目标

- 总体运行时间：不显著增加应用程序的总运行时间
- 空间使用：最大限度地利用可用内存
- 停顿时间：当垃圾回收机制启动时，可能引起应用程序的停顿，这个停顿应该比较短。（很少在实时应用中使用）
- 程序局部性：改善空间局部性和时间局部性

### 可达性

可达性就是指一个存储块可以被程序访问到

根集：不需要指针解引用就可以直接访问的数据

- Java：静态成员、栈中变量

可达性

- 根集的成员都是可达的
- 对于任意一个对象，如果指向它的一个指针被保存在可达对象的某字段或数组元素中，那么这个对象也是可达的

性质

- **一旦一个对象变得不可达，它就不会再变成可达的**

#### 改变可达对象集合的操作

新的对象通过对象分配被引入，参数传递、返回值和赋值传递可达性，赋值和过程结束可能结束对象的可达性。当一个对象变得不可达，可能会导致更多对象变得不可达。 

- 对象分配
  - 存储管理器完成。返回一个指向新存储块的引用，该操作向可达对象集中添加成员
- 参数传递和返回值
  - 对象引用从实在输入参数传递到相应的形式参数，也可以从返回结果传回给调用者。这些引用指向的对象仍然是可达的。
- 引用赋值：形容u=v的赋值语句
  - v的引用被复制到u中，u中原有引用丢失；(可能)使u原来指向的对象变得不可达，并递归使更多对象变得不可达
- 过程返回
  - 当一个过程退出时，保存其局部变量的活动记录出栈，局部变量消失，根集变小，如果这个活动记录中保存了某个对象的唯一引用，那个对象就变得不可达。
  - 同样地，如果这个刚刚变得不可达的对象保存了其他对象的唯一引用，那么那些对象也将变得不可达

### 垃圾回收方法  

1. 关注不可达：跟踪相关操作，捕获对象变得不可达的时刻，回收对象占用的空间
   - 基于引用计数的垃圾回收器
2. 关注可达：在需要时，标记出所有可达对象，回收其它对象
   - 基于跟踪的垃圾回收器

### 基于引用计数的垃圾回收器  

> 在引用计数中，每个对象都有一个与之关联的计数器，记录着**指向该对象**的引用数。

每个对象有一个用于存放引用计数的字段，并按如下方式维护

- 对象分配：引用计数设为1
- 参数传递：引用计数加1
- 引用赋值：u = v，u指向的对象引用减1，v指向的对象引用加1
- 过程返回：局部变量指向对象的引用计数减1

- **如果一个对象的引用计数为0，在删除对象之前，此对象中各个指针所指对象的引用计数减1**
  - 引用计数为0表明该对象没有被其他对象引用，即该对象不可达，由可达性的性质得到：当一个对象不可达，它就永远不可能变为可达，所以该对象不可能再被引用，需要删除

当一个对象从可达转变为不可达时，该回收器就可以将该对象确认为垃圾

当一个对象的引用计数为0时，该对象就会被删除

 特点：

1. 不能回收不可达的**循环数据结构**

   ![image-20231230114839283](编译原理.assets/image-20231230114839283.png)

2. 开销较大，但不会引起停顿

![image-20231230111712750](编译原理.assets/image-20231230111712750.png)

首先明确一点：A->B（A指向B）表示A引用B（B被A引用），引用计数针对的是B，即引用计数记录的是某对象被引用的次数（被指向的次数）

**操作Y=X：表示Y引用X**

1. ①对应：Y原来引用的对象失效，即“Y所指对象的引用计数减1”。
   - 对应图示为：Y原来指向其他对象的箭头消失
2. ②对应：X被Y引用，所以”X及X所指的对象引用计数加1“。
   - 对应图示为：新增一个Y指向X的箭头。
3. ③④对应：B的引用计数为0，将被删除，所有指向B的对象的引用计数减1。
   - 对应图示为：删除所有指向B的箭头。
   - **补充：C→I处的箭头也要删除，忘记删了**

**操作：Y是当前函数f的局部变量，且f返回**

⑤对应：Y消失，Y对X的引用失效，对应图示箭头Y→X删除

### 基于跟踪的垃圾回收  

与基于引用计数的垃圾回收器不同，基于引用计数的垃圾回收器在垃圾产生时就进行回收，而基于跟踪的垃圾回收器是周期性运行，寻找不可达对象并回收它们的空间。通常在空闲空间被耗尽或空闲空间数量低于某个阈值时启动垃圾回收器。

#### 标记-清扫式垃圾回收

![image-20231230115346315](编译原理.assets/image-20231230115346315.png)

这个垃圾回收方法由标记阶段和清扫阶段组成

**标记阶段**就是广搜，将可达的节点全部reached设为1，那么reached为0的节点自然不可达

- 遍历集合Unscanned中的节点，每遍历一个节点就将该节点删除，将该节点引用的其他节点（该节点指向的其他节点）做个标记reached位设为1，并加入集合中，直到集合为空停止

也就是说，只有存在某节点没有箭头指向它，它就是不可达的

**清扫阶段**

遍历堆区每个内存块，将reached为0的节点（空闲且不可达）加入到Free中释放

将reached为1的节点（可达）reached设为0，表示下次可用

![image-20231230115432766](编译原理.assets/image-20231230115432766.png)

![image-20231230115805651](编译原理.assets/image-20231230115805651.png)



#### 标记-拷贝式垃圾回收

![image-20231230121508264](编译原理.assets/image-20231230121508264.png)

![image-20231230121531477](编译原理.assets/image-20231230121531477.png)

#### 标记-整理式垃圾回收

![image-20231230121559914](编译原理.assets/image-20231230121559914.png)

![image-20231230121609976](编译原理.assets/image-20231230121609976.png)

#### 分代式垃圾回收  

不考

#### 垃圾回收算法比较  

![image-20231230121629463](编译原理.assets/image-20231230121629463.png)



**标记-清扫式算法优缺点：**

优点：

- **实现简单，无需移动对象(修改引用地址)**  

缺点：

- **回收效率不高**：由于清扫阶段需要遍历整个堆来清理未标记的对象，它的时间复杂度与堆的大小成正比。当堆中的对象数量庞大时，清扫阶段的时间开销会较大，导致垃圾回收的停顿时间较长。
- **易造成碎片**：标记-清扫式垃圾回收会产生内存碎片问题。当一部分内存被回收后，可能会留下不连续的小块内存，这些小块内存可能无法被充分利用，导致堆空间的碎片化。碎片化可能会限制程序分配大对象的能力，影响内存的使用效率。



**标记-复制式算法优缺点：**  

优点

- 只处理可达对象(减少回收时间)
- 将可达对象安排到一起(减少内存碎片)

缺点

- 一半预留区域的内存无法使用



## Chapter 8：代码生成

本章讨论编译器模型的最后一个步骤：代码生成器。它将**编译器前端生成的中间表示（IR）**和**相关的符号表信息**作为**输入**，**输出**语义等价的**目标程序**

> 将**编译器前端生成的中间表示（IR）**和**相关的符号表信息**用于确定IR中的名字所指的数据对象的运行时刻地址

要产生高效目标程序的编译器都会在代码生成之前包含一个优化步骤。优化器把一个IR映射为另一个可用于产生高效代码的IR

**编译器的代码优化**和**代码生成步骤**称为编译器的**后端**

![image-20231221193434843](编译原理.assets/image-20231221193434843.png)

**代码生成器有三个任务**

- 指令选择：选择适当的指令实现IR语句
- 寄存器分配和指派：把哪个值放在哪个寄存器中
  - 选择把哪个值放寄存器是分配问题
  - 选择把值放在哪个寄存器是指派问题
- 指令排序：按照什么顺序安排指令执行

**代码生成器输入IR的选择**

- 四元式、三元式、字节代码、堆栈机代码、后缀表示、抽象语法树、DAG图、...
  - 本章讨论的中间表示形式IR主要为三地址代码、树和DAG（有向无环图）

**代码生成器的输出**

代码生成器的输出是目标程序，目标程序如何编写取决于目标机的体系结构

目标机体系结构：RISC（精简指令集计算机）、CISC（复杂指令集计算机）、基于堆栈的结构（目前主要是Java虚拟机（JVM）在使用）

> RISC
>
> - 很多寄存器、三地址指令、简单寻址方式、指令集简单
>
> CISC
>
> - 较少寄存器、二地址指令、多种寻址方式和多种类型寄存器、指令集复杂（可变长度指令、具有副作用指令）
>
> 基于堆栈的结构
>
> - JVM是Java字节码的软件解释器，该解释器提供了跨平台的软件兼容性。
> - 字节码是Java编译器生成的一种中间语言。
> - 为了克服JVM作为解释器的性能限制，人们还创造了即时（Just In Time，JIT）编译器，该JIT编译器在运行时刻把字节码翻译成目标机上的本地硬件指令集
> - 当然，还可以直接涉及编译器，把Java程序直接编译成目标机器指令，但这种方式不通用，仅限于当前目标机

目标程序有不同的输出形式：

- 使用绝对地址的机器语言
  - 优点：程序可以放在内存中某个固定位置上并立即执行。
- 可重定向的机器语言程序（或称为目标模块，object module）
  - 一组可重定位的目标模块可以被一个链接加载器链接到一起并加载运行。
  - 链接和加载需要代价，但是提供了更多灵活性：子程序能够分开编译，并且能够从一个目标模块中调用其他已经编译好的程序
- 汇编程序
  - 优点：使代码生成更简单
  - 代价：需要增加一个汇编步骤（将汇编语言转换为机器语言）

### 目标机模型

![image-20231230144024596](编译原理.assets/image-20231230144024596.png)

![image-20231230144429352](编译原理.assets/image-20231230144429352.png)

![image-20231230144725436](编译原理.assets/image-20231230144725436.png)

![image-20231230144938018](编译原理.assets/image-20231230144938018.png)

![image-20231230145023429](编译原理.assets/image-20231230145023429.png)

![image-20231230145052852](编译原理.assets/image-20231230145052852.png)

### 程序及指令的代价  

- 不同的目的有不同的度量

  - 最短编译时间、运行时间、目标程序大小、能耗

- 不可判定一个目标程序是否最优

- 假设每个指令有固定的代价，设定为1加上运算分量寻址模式的代价

  寄存器寻址模式具有的附加代价为0，涉及内存位置或常数的寻址方式的附加代价为1

  - LD R0, R1：代价为1
  - LD R0, M：代价是2（把内存位置M中的内容加载到寄存器R0中）
  - LD R1, *100(R2)：代价为2

### 目标代码中的地址  

如何为过程调用和返回生成代码？

- 静态分配 (活动记录)
- 栈式分配 (活动记录)

如何将IR中的名字 (过程名或变量名) 转换成为目标代码中的地址？

- 不同区域中的名字采用不同的寻址方式

### 活动记录的栈式分配  

![image-20231230150927602](编译原理.assets/image-20231230150927602.png)

![image-20231230150700730](编译原理.assets/image-20231230150700730.png)

![image-20231230151849114](编译原理.assets/image-20231230151849114.png)

### 基本块（Basic block）  

对每个过程内的指令进行划分

必然连续执行的指令划入一组，称为基本块

- 控制流只能从基本块的第一条指令进入
- 除基本块的最后一条指令外，控制流不会跳转/停机

每个基本块内**只有一条**执行路径

- 易于分析

**划分基本块的方法**  

输入：三地址指令序列

输出：基本块的列表

方法

- 确定首指令leader (基本块的第一个指令)
  - 第一个三地址指令
  - 任意一个(条件或无条件) 转移指令的**目标指令**
  - 紧跟在一个(条件或无条件) 转移指令**之后的指令**
- 确定基本块
  - 每个首指令对应于一个基本块：从首指令开始到下一个首指令

![image-20231230155617568](编译原理.assets/image-20231230155617568.png)

### 流图



### 确定基本块中的活跃性、后续使用 

####  如何判断一个变量是否活跃？  

**变量值的使用**

- 三地址语句 i 向变量 x 赋值，如果另一个语句 j 的运算分量为 x，且从 i 开始有一条路径到达 j，且路径上没有对 x 赋值，那么 j 就使用了 i 处计算得到的 x 的值
- 我们说变量 x 在语句 i 后的程序点上活跃
  - 程序执行完语句 i 时，x 中存放的值将被后面的语句使用
  - **不活跃是指变量的值不会被使用（可能被截胡——有其他语句对该变量赋值），而不是变量不会被使用**

这些信息可以用于代码生成

- 如果 x 在 i 处不活跃，且 x 占用了一个寄存器，我们可以把这个寄存器用于其它目的

#### 确定基本块中的活跃性

输入

- 基本块 B，开始时（指B的最后一个语句） B 中的所有非临时变量都是活跃的

输出

- 各个语句 i 上变量的活跃性、后续使用信息

方法

- 从 B 的最后一个语句开始反向扫描
- 对于每个语句 i：x = y + z
  - 令语句 i 和 x、y、z 的当前活跃性信息/使用信息关联
  - 设置 x 为“不活跃”和“无后续使用”
  - 设置 y 和 z 为“活跃”，并指明它们的下一次使用设置为语句 i

![image-20231230162026735](编译原理.assets/image-20231230162026735.png)

### 代码生成器  

根据三地址指令序列生成机器指令

- 假设每个三地址指令只有一个对应的机器指令
- 有一组寄存器用于计算基本块内部的值

主要的目标是减少加载 (LD) 和保存 (ST) 指令，即最大限度地利用寄存器

寄存器的使用方法

- 执行运算时，运算分量必须放在寄存器中
- 存放临时变量
- 存放全局的值
- 进行运行时刻管理 (比如栈顶指针)

![image-20231230152102859](编译原理.assets/image-20231230152102859.png)

### 代码生成算法

重要子函数：getReg(I)

- 根据寄存器描述符和地址描述符等数据流信息，为三地址指令 I 选择最佳的寄存器
- 得到的机器指令的质量依赖于getReg 函数选取寄存器的算法

 代码生成算法逐个处理三地址指令

![image-20231230152306683](编译原理.assets/image-20231230152306683.png)

**基本块的收尾**

在代码结束时，基本块中使用的变量可能仅存放在某个寄存器中。

- 如果这个变量是一个只在基本块内部使用的临时变量，那就没有问题。当基本块结束时，我们可以忘记这些临时变量的值并假设这些寄存器是空的
- 如果一个变量在基本块的出口处活跃，或者我们不知道哪些变量在出口处活跃，就必须假设这个变量的值会在以后被用到。这种情况下，对于每个变量x，如果它的地址描述符表明它的值没有存放在x 的内存位置上，我们必须生成指令ST x,R ，其中R是在基本块的结尾处存放x值得寄存器

![image-20231230163322862](编译原理.assets/image-20231230163322862.png)

![image-20231230152513373](编译原理.assets/image-20231230152513373.png)

![image-20231230152825187](编译原理.assets/image-20231230152825187.png)

#### getReg函数  

目标：减少 LD/ST 指令

任务：为运算分量和结果分配寄存器

为 x = y op z 的运算分量 y 和 z 分配寄存器

- 如果 y 已经在某个寄存器中，不需要进行处理，选择这个寄存器作为 $R_y $
- 如果 y 不在寄存器中，且有空闲寄存器，选择一个空闲寄存器作为 $R_y$
- 如果不在寄存器中且没有空闲寄存器，需要选择一个非空闲寄存器存放值。若选择寄存器 R，且已知其寄存器描述符表示某变量 v 的值在 R 中，**我们需要保证要么v的值不会被再次使用，要么我们还可以到别的地方使用v**  
  1. 如果 v 的地址描述符表明可在别的地方找到 v，DONE
  2. v 就是 x (即结果)，且 x 不是运算分量 z，我们知道x的当前值不会再次被使用，DONE
  3. **如果 v 在此之后不会被使用 (不活跃)**，DONE
  4. 如果前面三种情况都不满足，生成保存指令 ST v, R (溢出操作) 并修改 v 的地址描述符；如果 R 中存放了多个变量的值，那么需要生成多条 ST 指 令

为 x = y op z 的结果 x 选择寄存器 Rx的方法基本上和上面要把 y 从内存LD 时一样，但是

- 只存放 x 值的寄存器总是可接受的
- 如果 y 在指令之后不再使用，且 Ry仅仅保存了 y 的值， 那么 Ry同时也可以作为Rx(对 z 也一样)

处理 x = y 时

- 先选择 Ry
- 然后让 Rx = Ry

### 寄存器的分配和指派  

**寄存器分配**

- 确定在程序的每个点上，哪个值应该存放在寄存器中

**寄存器指派**

- 各个值应该存放在哪个寄存器中

简单方法：把特定类型的值分配给特定的寄存器

- 数组基地址指派给一组寄存器，算术计算分配给一组寄存器，栈顶指针分配一个寄存器，循环，……
- 缺点：寄存器的使用效率较低

**全局寄存器分配**  

在循环中频繁使用的值存放在固定寄存器

- 分配固定多个寄存器来存放内部循环中最活跃的值

可以通过使用计数的方法来估算把一个变量放到寄存器中会带来多大好处，然后根据这个估算来分配寄存器

## Chapter 9：机器无关的优化

### 局部优化

#### 基本块的优化

许多局部优化技术需要先将基本块内的指令转化为有向无环图 (Directed Acyclic Graph, DAG) 

DAG可反映变量及其值对其他变量的依赖关系

- 结点表示变量的值
- 边表示计算值形成的依赖关系

##### 基本块的DAG构造方法

构造方法

- 每个变量都有一个对应的DAG结点表示其初始值
- 每个语句 s 有一个相关的结点 N，代表此计算得到的值
  - N 的子结点对应于(得到其运算分量当前值的) 其它语句，或如果没有语句对当前运算分量赋值，N的子节点是代表该运算分量的初始值的节点
  - N的标号是 s 中的运算符，同时还有一组变量被关联到 N，表示 s 是最新对这些变量进行定值的语句

- 为基本块中出现的每个变量建立结点 (表示初始值)，各变量和相应结点关联

- 顺序扫描各三地址指令，进行如下处理
  - 指令 x = y op z
    - 为该指令建立结点 N，标号为 op，令 x 和 N 关联
    - N 的子结点为 y、z 当前关联的结点
  - 指令 x = y
    - 假设 y 关联到 N，那么x现在也关联到 N
- 扫描结束后，对所有在出口处活跃的变量 x，将 x 所关联的结点设置为输出结点  

![image-20231230172655612](编译原理.assets/image-20231230172655612.png)

##### DAG的作用  

DAG图描述了基本块运行时各变量的值 (和初始值) 之间的关系

以DAG为基础，对代码进行转换

- 寻找局部公共子表达式
- 消除死代码
- 代数恒等式的使用
  - 数组引用的表示
  - 指针赋值和过程调用

##### 局部公共子表达式

![image-20231230172940717](编译原理.assets/image-20231230172940717.png)

![image-20231230173505231](编译原理.assets/image-20231230173505231.png)

![image-20231230174137275](编译原理.assets/image-20231230174137275.png)

##### 消除死代码

![image-20231230173720631](编译原理.assets/image-20231230173720631.png)

1. 首先e没有父节点，消除e
2. 消除e后，c没有父节点，消除c

##### 基于代数恒等式的优化  

除换乘，乘换加，次方换累乘

![image-20231230173848144](编译原理.assets/image-20231230173848144.png)

##### 数组引用的表示

![image-20231230174156647](编译原理.assets/image-20231230174156647.png)

![image-20231230174428476](编译原理.assets/image-20231230174428476.png)

##### 指针赋值/过程调用  

通过指针进行取值/赋值：x = \*p、\*q = y

- x 使用了任意变量，因此无法消除死代码
- *q = y 对任意变量赋值，因此杀死了全部其他结点

可通过 (全局/局部) 指针分析部分地解决这个问题：将一个指针在代码中某个位置上可能指向的变量限制在一个较小的子集中

比如：

- p = &x            *p = y

  我们知道是x而不是其他变量被赋予y的值，因此我们只需杀死以x为附加变量的节点，不需要杀死其他节点

过程调用也类似，必须安全地假设它

- 使用了可访问范围内的所有变量
- 修改了可访问范围内的所有变量

##### 从DAG到基本块

**重构的方法**

- 每个结点构造一个三地址语句，计算对应的值
- 结果应该尽量赋给一个活跃的变量
- 如果结点有多个关联的变量，则需要用赋值语句进行赋值

**重组的规则**  

注意求值顺序

- 指令顺序必须遵守DAG中结点的顺序
- 对数组赋值 (write) 要跟在原来之前的赋值/求值之后
- 对数组求值 (read) 要跟在原来之前的赋值指令之后
- 对变量的使用必须跟在所有原来在它之前的过程调用和指针间接赋值之后
- 任何过程调用或指针间接赋值必须跟在原来在它之前的变量求值之后

即保证如果两个指令之间相互影响，它们的顺序就不该改变

#### 窥孔优化（peephole optimization）  

使用一个滑动窗口 (窥孔) 来检查目标指令，在窥孔内实现优化

- 冗余指令消除
- 控制流优化
- 代数化简/强度消减
- 机器特有指令的使用

