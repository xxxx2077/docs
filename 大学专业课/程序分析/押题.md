# 押题

## 考点

### May&Must analysis

![image-20240703205643762](押题.assets/image-20240703205643762.png)

### MOP

Meet-Over-All-Paths

将**每条控制流**从entry节点到$s_i$节点向下计算，得到每条控制流的OUT值，再对其求最小上界/最大下界，即：

![image-20240703200917636](押题.assets/image-20240703200917636.png)

由于CFG中并不是每一条控制流都会被执行的，所以MOP算法并不是完全精确的。并且，由于MOP算法需要考虑所有的路径，因此它也是不现实的。

**MOP和迭代算法的比较**

![image-20240703201109459](押题.assets/image-20240703201109459.png)

dataflow analysis三个算法的精度都和MOP一样，而常量传播不满足分配率，因此其算法比MOP精度差

### 常量传播算法

**常量传播（Constant Propagation）** 问题：考虑程序点 *p* 处的变量 *x* ，求解 *x* 在 *p* 点处是否保证（Guarantee）是一个常量。

如果我们知道了某些程序点处的某些变量一定是一个常量的话，我们就可以直接优化，将这个变量视为常量，从而减少内存的消耗（可以在编译的时候就完成一部分计算，并且有些常量并不需要分配储存它的内存空间）。

#### Abstraction

![image-20240703202053067](押题.assets/image-20240703202053067.png)

![image-20240703202208964](押题.assets/image-20240703202208964.png)

#### 状态转移函数

![image-20240703202545653](押题.assets/image-20240703202545653.png)

### Worklist Algorithm

an optimization of Iterative Algorithm

![image-20240703205507036](押题.assets/image-20240703205507036.png)

![image-20240703205520636](押题.assets/image-20240703205520636.png)

### 过程间分析

#### Call Graph

![image-20240703212159447](押题.assets/image-20240703212159447.png)

![image-20240703212034855](押题.assets/image-20240703212034855.png)

调用图构建有4种方法：

- 类层级结构分析（Class Hierarchy Analysis，CHA）
- 快速类型分析（Rapid Type Analysis，RTA）
- 变量类型分析（Variable Type Analysis，VTA）
- 指针分析（Pointer Analysis，k-CFA）

上面的四种方法自上而下精度（Precision）越来越高，但是效率（Efficiency）也越来越低。这一章重点讲解类层级结构分析的方法，在后面几章里面会讲解指针分析的方法。

#### Virtual Call

virtual call 可以分解为：

- 实例object的类型（在今后用$o_i$指代）
- 调用点的函数签名
  - 类型
  - 函数名
  - 描述符
    - 返回值类型
    - 参数类型

![image-20240703213259310](押题.assets/image-20240703213259310.png)

#### Dispatch

![image-20240703213351473](押题.assets/image-20240703213351473.png)

其实，Dispatch算法模拟的是**实际运行时**的动态绑定过程。但是，在静态分析阶段，大部分情况下我们是无法直接获取接收对象的类型的，因为大多数时候，由于控制流的作用，一个调用点可能有不止一种可能的接受对象类型。

#### Class Hierarchy Analysis* (CHA)

CHA才是真正的静态分析

- CHA需要知道整个程序的类之间的继承关系，也就是层级结构；
- CHA会根据调用点处的**接收变量（Receiver Variable）** 的 **声明类型（Declare Type）** 来解析虚调用；
- CHA假设声明类型为 `A` 的接收变量 `a` 可能会指向 `A` 类以及 `A` 的所有 **子类（Subclass）** 的对象

![image-20240703214119466](押题.assets/image-20240703214119466.png)

![image-20240703214437099](押题.assets/image-20240703214437099.png)

![image-20240703214541091](押题.assets/image-20240703214541091.png)

![image-20240703214633000](押题.assets/image-20240703214633000.png)

![image-20240703214839892](押题.assets/image-20240703214839892.png)

#### Interprocedural Control-Flow Graph

![image-20240703215011681](押题.assets/image-20240703215011681.png)

![image-20240703215146631](押题.assets/image-20240703215146631.png)

![image-20240703215208294](押题.assets/image-20240703215208294.png)

![image-20240703215240056](押题.assets/image-20240703215240056.png)

![image-20240703215358774](押题.assets/image-20240703215358774.png)

#### Comparison

![image-20240703220517722](押题.assets/image-20240703220517722.png)

![image-20240703220532264](押题.assets/image-20240703220532264.png)

## 填空题

### 静态分析由哪两部分组成？

- abstraction抽象 
- over-approximation过拟合

### 过拟合由哪两部分组成

- transfer function 转换函数
- control flows 控制流

### 转换函数由哪两部分定义？

- analysis problem 分析问题
- the “semantics” of different program statements 不同程序语句的语义

### 一个data flow Analysis框架包含哪三个部分

![image-20240703202747158](押题.assets/image-20240703202747158.png)



## 简答题

### 静态分析（Static Analysis）和动态测试（Dynamic Testing）的区别是什么？

静态分析在执行程序之前对程序进行分析，分析包括解释程序的行为以及判断该程序是否满足某些性质。

动态测试则是在程序运行时对代码进行分析，分析那些静态分析时没有被察觉的错误。

### 完全性（Soundness）、正确性（Completeness）、假积极（False Positives）和假消极（False Negatives）分别是什么含义？

Soundness(纯粹性)：满足条件的一定在结果集中

Completeness(完备性)：结果集中的元素一定满足条件

举个例子：

条件：程序有bug。

结果：分析器检测出来

**Soundness：**有bug的程序一定被分析器检测出来。所以一个纯粹的分析器从来不会放过一个不正确的程序。

- overapproximate 过拟合。即报告有bug的范围比实际有bug的范围要大，从而覆盖所有有bug的程序。
- 可理解为“宁愿误报也不要漏报”

**Completeness：**被分析器检测出来的程序一定有bug。所以一个完备的分析器从来不会冤枉一个正确的程序。

- underapproximate 欠拟合。
- “宁愿漏报也不要误报”

![image-20240703104747839](押题.assets/image-20240703104747839.png)

> 对于客观世界来说，Truth是积极的
>
> 因为
>
> positive/negative（预测结果）：预测、判断为正/负
> true/false（实际结果）：（通过真实的结果来得出）预测、判断为真/假。
>
> 所以
>
> False Positive (简称FP)：判断为正，但是判断错了。（实际为负）
> False Negative (简称FN)：判断为负，但是判断错了。（实际为正）
> True Positive (简称TP)：判断为正，且实际为正。
> True Negative (简称TN)：判断未负，且实际为负。

对应静态分析，以reaching definition为例：

positive/negative：判断是/否为reaching definition

true/false：判断是/否 正确

- false negative：判断程序没有reaching definition，但是判断错了（实际有）
  - 漏报
  - 对应completeness，completeness偏悲观，为了保证正确率，倾向于判断程序没有reaching definition，结果往往导致会漏报
- false positive： 判断程序有reaching definition，但是判断错了（实际没有）
  - 误报
  - 对应soundness，soundness总是偏乐观偏全面地得到结论，即便可能是错的

### 为什么静态分析通常需要尽可能保证完全性？

完全性的静态分析虽然不是完美的但是是有用的，它能够帮助我们有效的缩小debug的范围，我们只需要暴力排查掉所有的false positive 实例就可以了

但正确性的静态分析不能够帮助我们有效缩小 debug 的范围，排除false negative的范围（理论范围为T-A，实际求解中，范围为P-A）比A大得多，这意味着排除false negative的代价非常大。

### 如何理解抽象（Abstraction）和过近似（Over-Approximation）？

**Abstraction**

将程序P中的值与我们需要研究的性质Q提取出来，从而忽略其他细节的过程，即为抽象

**Over-approximation**

静态分析给出的答案集合A和程序P关于性质Q的真相集合T之间满足$T⊆A $，则为过近似

### （*）简述从源代码编译为机器代码的过程

![image-20240703150201727](押题.assets/image-20240703150201727.png)



### 为什么说IR更适用于静态分析/AST与IR的比较

![image-20240703154429770](押题.assets/image-20240703154429770.png)

![image-20240703151250214](押题.assets/image-20240703151250214.png)

### （*）三地址码（3AC）的特征

一条指令等号右侧只有一个操作符

### （*）为什么叫三地址码？

每个三地址码最多包含三个地址

三地址指的是：

- 变量名：a,b,c
- 常量：3
- 编译时产生的局部变量：t1

### 编译器（Compiler）和静态分析器（Static Analyzer）的关系是什么？

编译器前端得到IR后，将IR提供给静态分析器进行分析

编译器的前端和静态分析器的前端相同

### 三地址码（3-Address Code, 3AC）是什么，它的常用形式有哪些？

3地址码中的地址可能有如下的几种类型：

- 名字（Name），包括
  - 变量（Variable）
  - 标签（Label）
    - 用于指示程序位置，方便跳转指令的书写
- 字面常量（Literal Constant）
- 编译器生成的临时量（Compiler-Generated Temporary）

每一种指令都有其对应的 3 地址码形式，一些常见的 3 地址码形式如下：

```bash
x = y bop z
x = uop y
x = y
goto L
if x goto L
if x rop y goto L
```

其中：

- x, y, z是变量的地址；
- `bop` 是双目操作符（Binary Operator），可以是算数运算符，也可以是逻辑运算符；
- `uop` 是单目操作符（Unary Operator），可能是取负、按位取反或者类型转换；
- `L` 是标签（Label），是标记程序位置的助记符，本质上还是地址；
- `rop` 是关系运算符（Relational Operator），运算结果一般为布尔值。
- `goto` 是无条件跳转， `if... goto` 是条件跳转。

### 调用图构建有哪四种方法？其中常用的两种是什么？精度最高的是哪种？效率最高的是哪种？

调用图构建有4种方法：

- 类层级结构分析（Class Hierarchy Analysis，CHA）
- 快速类型分析（Rapid Type Analysis，RTA）
- 变量类型分析（Variable Type Analysis，VTA）
- 指针分析（Pointer Analysis，k-CFA）

上面的四种方法自上而下精度（Precision）越来越高，但是效率（Efficiency）也越来越低。

**精度最高：指针分析 （效率最低）**

**效率最高：类层级结构分析**

### 影响指针分析的几个因素

- 堆抽象
  - 分配点
  - 无存储
- 上下文敏感性
  - 上下文敏感
  - 上下文不敏感
- 流敏感性
  - 流敏感
  - 流不敏感
- 分析范围
  - 全程序
  - 需求驱动

![image-20240704073019381](押题.assets/image-20240704073019381.png)

#### 什么是分配点抽象？

将同一分配点处分配内存而产生的具体对象抽象为一个抽象的对象，称这种堆抽象的方式为分配点抽象

#### 上下文敏感和上下文不敏感

上下文敏感：区分一个方法的不同调用语境

上下文不敏感：一个方法的所有调用语境汇合到一起分析

上下文敏感更精确但代价更高，上下文不敏感实现简单、速度更快，但精度有所损失

#### 流敏感和流不敏感

流敏感：尊重语句的执行顺序

流不敏感：将程序视为一个无序语句的集合对待

前面学的data flow analysis都是流敏感的

#### 分析范围

称为程序中所有的指针计算指向信息的指针分析为 **全程序分析（Whole-program Analysis）** ；称只计算会影响 **特定兴趣点（Specific Sites of Interest）** 的指针的指向信息的指针分析为 **需求驱动分析（Demand-driven Analysis）** 。

### 指针分析分析什么

指针有：

- 本地变量x
- 静态域C.f（有时称为全局变量）
  - 与变量相同处理方法
- 实例字段x.f
- 数组array[i]
  - 我们将其处理为array.arr

> 称对程序中指针的指向关系产生影响的语句为**指针影响型语句（Pointer-affecting Statement）**。

指针影响型语句：

- New
- Assign
- Load
- Store
- Call

![image-20240704074223549](押题.assets/image-20240704074223549.png)

### 指针流图

节点：指针，即变量或某个对象的一个字段

边：指针x->指针，表示x指向的对象能够流向y的指向集合中

指针流图在指针分析中动态更新

![image-20240704080349709](押题.assets/image-20240704080349709.png)

### 上下文敏感

上下文敏感通过区分不同语境下的不同数据流来模拟调用上下文，从而提高精度。

### 上下文敏感堆

一开始我们对分配点进行抽象：同一分配点产生的所有具体对象抽象成一个对象

现在分配点的对象已经上下文敏感了，因此分配点处分配的堆内存也应该上下文敏感。

- 抽象的对象也应当用上下文来修饰（称为堆上下文），最普遍的选择是继承该对象分配点所在方法的上下文。
- 上下文敏感的堆抽象在分配点抽象的基础上提供了一个粒度更精确的堆模型。

称区分 **堆上下文（Heap Context）** 的分配点抽象为 **上下文敏感的分配点抽象（Context-sensitive Allocation-site Abstraction）** 。

### 为什么上下文敏感以及上下文敏感的堆抽象能够提高精度

- 在动态执行的过程中，每一个方法可能在不同的调用语境中被调用多次。
- 在不同的调用语境下面，方法中的变量可能会指向不同的对象。
- 在上下文不敏感的指针分析中，不同的上下文被混合在了一起，并传递给程序的其他部分（通过返回值或者副作用），这就导致了虚假的数据流。



- 在动态执行的过程中，一个分配点可以在不同的调用语境下创建多个对象；
- 不同的对象（有相同的分配点分配）可能会携带不同的数据流被操作，比如说在它们的字段中存储不同的值。
- 在指针分析中，不带堆上下文分析这样的代码可能会由于合并不同上下文中的数据流到一个抽象对象中而丢失精度。
- 相比之下，通过堆上下文来区分同一个分配点的不同对象能够获得不少的精度。

### Differences and relationship among common context sensitivity variants

其实，在理论上，调用点敏感和对象敏感的精度是不可比的，因为它们各自有各自准的场景和不准的场景，而对于一个程序来说，各种场景的比例是不确定的东西，所以这两种上下文敏感的精度比较也就没有定论了。

不过，在实践过程中，对于面向对象语言（比如说Java）来说，对象敏感的整体表现要优于调用点敏感，因为使用面向对象语言编程的时候我们会频繁地使用对象来传递数据，从而对象敏感能够更好的避免数据流的合并，从而提升精度

![image-20240704102802724](押题.assets/image-20240704102802724.png)

### 安全

#### 机密性和完整性

- 机密性阻止机密的信息泄露
- 完整性阻止不信任的信息污染受信任的信息

机密性（L->H）

- 保密（H）
- 公开（L）

完整性（H->L）

- 信任（H）
- 不信任（L）

#### 广义的完整性

- 正确性
  - 比如说对于信息流完整性来说，受信任的关键数据不应当被不受信任的数据所污染。
- 完全性
  - 比如说一个数据库系统应当完全地储存所有的数据，不应该有数据丢失
- 一致性
  - 比如说一个文件传输系统应该保证在文件内容在两端（发送端和接受端）相同

#### 显示流和隐蔽信道

信息可以通过直接拷贝的方式进行流动，这样的信息流称为**显式流（Explicit Flow）**

信息可以通过影响控制流的方式向外传递，这样的信息流称为**隐式流（Implicit Flow）**。



称在计算系统中指示信息的机制为 **信道（Channels）** 。如果这个指示信息的机制的本意并不是信息传递，这样的信道称为 **隐蔽信道（Covert/Hidden Channels）**

隐蔽信道：

- 隐式流
  - 通过程序的控制结构来指示信息
- 终止信道
  - 通过程序是否终止来指示信息
- 时间信道
  - 通过程序的计算时间来指示信息
- 异常
  - 通过程序的异常来指示信息

#### 污点分析

**污点分析（Taint Analysis）** 将程序中的数据分为两类：

- 关心的敏感数据，我们会给这些数据加标签，加上标签后叫做 **污点数据（Tainted Data）** ；
- 其他数据，叫做 **无污点数据（Untainted Data）** 。

污点分析追踪污点数据是如何在程序中流动的，并且观察它们是否流动到了一些我们关心的敏感的地方。其中，污点数据产生的地方称为 **源头（Source）** ，我们不希望污点数据流向的敏感地带称为 **水槽（Sink）** 

### Datalog

datalog的语法语义由两部分组成：

- 数据
- 逻辑

没有副作用

没有控制流

没有函数

不是图灵完备的语言

## 程序分析题

### 构造CFG

CFG的节点为basic block，边为basic block之间的边

**basic block**

![image-20240703151744113](押题.assets/image-20240703151744113.png)

**edge**

![image-20240703153710675](押题.assets/image-20240703153710675.png)

![image-20240703154036986](押题.assets/image-20240703154036986.png)

**entry和exit节点不唯一**

### Dataflow analysis application

#### Reaching definition

##### 理论部分

程序点p有一条对v赋值的语句d，如果从程序点p到q没有第二条对v赋值的语句，则称d能够从p到达q

![image-20240703161519321](押题.assets/image-20240703161519321.png)

可用于判断变量v在使用时是否已被赋值

假设程序点q时v被使用，如果dummy definition从entry到达了点q，那么说明v没有被初始化，即v在初始化前被使用，引发错误

![image-20240703161714764](押题.assets/image-20240703161714764.png)

###### Abstraction

程序中所有对变量定义的definition语句  为我们要研究的对象

可将其抽象为bit vector

![image-20240703161930457](押题.assets/image-20240703161930457.png)

![image-20240703162104645](押题.assets/image-20240703162104645.png)

##### 实践部分

![image-20240703162251426](押题.assets/image-20240703162251426.png)

![image-20240703162358270](押题.assets/image-20240703162358270.png)

###### 几个疑问

![image-20240703163058500](押题.assets/image-20240703163058500.png)

因为entry为虚拟节点，没有语句，没有definition能够流到没有语句的地方

![image-20240703163109765](押题.assets/image-20240703163109765.png)

该算法为模板算法，对于其他analysis，它们的OUT[entry]和OUT[B]不一定相等

![image-20240703163213431](押题.assets/image-20240703163213431.png)

程序还没有分析，因此OUT[B]都为空（may analysis一般都为空，must analysis一般都为must）

![image-20240703163355122](押题.assets/image-20240703163355122.png)

![image-20240703170602504](押题.assets/image-20240703170602504.png)

![image-20240703170613576](押题.assets/image-20240703170613576.png)

#### Live Variables Analysis

##### 理论部分

在程序点 *p* 处，某个变量 *v* 的变量值（Variable Value）可能在之后的某条控制流中被用到，我们就称变量 *v* 是程序点 *p* 处的 **活变量（Live Variable）** ，否则，我们就称变量 *v* 为程序点 *p* 处的 **死变量（Dead Variable）** 。分析在各个程序点处所有的变量是死是活的分析，称为 **活跃变量分析（Live Variable Analysis）** 。

程序点 *p* 处的变量 *v* 是活变量，当且仅当在 CFG 中存在某条从 *p* 开始的路径，在这条路径上变量 *v* 被使用了，并且在 *v* 被使用之前， *v* 未被重定义。



活跃变量分析可以应用在寄存器分配（Register Allocation）中，可以作为编译器优化的参考信息。比如说，如果在某个程序点处，所有的寄存器都被占满了，而我们又需要用一个新的寄存器，那么我们就要从已经占满的这些寄存器中选择一个去覆盖它的旧值，我们应该更青睐于去覆盖那些储存死变量的寄存器。

###### Abstraction

![image-20240703171308928](押题.assets/image-20240703171308928.png)

注意，我们判断活跃变量的标准不是这个变量之后有没有可能用到，而是 **这个变量当前所储存的值在之后有没有可能被用到** 。

因此，活跃变量分析适合用逆向分析的方式来进行。

从定理3.5中我们可以知道，只要存在一条路径使得 *p* 处的变量 *v* 的值被用到，那么就认为 *v* 在 *p* 处是活的，因此，这里应该采用过近似的方式。

##### 实践部分

![image-20240703171840846](押题.assets/image-20240703171840846.png)

$def$:   redefined in B（3，4，5，6）

$use$： it's used before redefinition in B （4，6）

![image-20240703171859331](押题.assets/image-20240703171859331.png)

IN[exit]= $\phi$：因为exit点处的变量不可能再被使用

IN[B]= $\phi$：may analysis初始化为空

#### Available Expressions Analysis

##### 理论部分

我们称一个表达式（Expression）`x op y`在程序点 *p* 处是 **可用的（Avaliable）** ，如果：

- **所有** 的从程序入口到程序点 *p* 的路径都 **必须** 经过 `x op y` 表达式的评估（Evaluation），并且
- 在最后一次 `x op y` 的评估之后，没有 x或者 *y* 的重定义（Redefinition）。

对于程序中每个程序点处的可用表达式的分析，我们称之为 **可用表达式分析（Avaliable Expression Analysis）** 

可用表达式的相关信息还可以被用来检测**全局的公共子表达式**（Global Common Subexpression）

可用表达式分析是一种**必然性**分析。因为在上述表达式优化的应用场景中，我们可以不优化每一个表达式，**但不可以优化错误**（也就是说一旦决定优化某个表达式，这个表达式就必须必然是可用表达式）。

###### Abstraction

![image-20240703193726181](押题.assets/image-20240703193726181.png)





##### 实践部份

![image-20240703194056645](押题.assets/image-20240703194056645.png)

#### Comparison

![image-20240703195059853](押题.assets/image-20240703195059853.png)

### Pointer Analysis

#### 理论部分

指针分析：计算每个指针指向的内存位置

- 对于OOPL，计算每个指针指向的对象
- may analysis & over-approximation





![image-20240703221933970](押题.assets/image-20240703221933970.png)

![image-20240703222213291](押题.assets/image-20240703222213291.png)

#### 实践部分

##### 过程内指针分析

![image-20240704080458602](押题.assets/image-20240704080458602.png)

##### 过程间指针分析

![image-20240704091754383](押题.assets/image-20240704091754383.png)

##### 上下文敏感指针分析

![image-20240704095442555](押题.assets/image-20240704095442555.png)