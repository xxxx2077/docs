# 逸仙东华资源共享平台

## 项目简单介绍

逸仙东华是东华高中和中山大学的校友群体，随着校友会的发展，出现了校友数据管理、资料共享、逸仙东华资源共享平台

## 项目背景



## 技术问题

### 为什么使用FastAPI

由于我们的团队有一部分低年级的开发人员，并且这个项目的时间比较紧，因此我们尽量选择简单快捷的开发方式。

首先，我们为了照顾低年级的开发人员，选择了相比于Go更容易入门的python语言

然后，python语言有三个主流框架：Django、Flask和FastAPI，我们选择了FastAPI框架。

- 因为它首先简单易用，它能够自动生成API文档，帮助前后端快速交互
- 然后它具有极高的性能，比肩Go语言
- 它虽然简单但是功能比较齐全，支持OPENAPI和JSON Schema，能够规范化API的设计和发布；同时可以无缝整合多种数据库的使用，比如SQLAlchemy

综上所述，我们认为FastAPI能够满足我们对于该项目开发快速、容易入门同时兼具性能的需求。

### 为什么使用MinIO？

我们选择MinIO主要有三个原因：

1. 我们该项目的需求是构建一个资源共享网站，这意味着上面的资源特性一是非结构化数据为主，二是多读少写，这两点非常适合使用对象存储，而MinIO是轻量且高性能的对象存储服务器
2. 由于我们团队分布于不同地方，因此需要使用REST API来访问存储系统。而MinIO大力支持S3协议，这意味着MinIO支持REST API，所以MinIO支持我们能够使用REST API来访问资源。
3. MinIO提供纠删码机制，为存储提供了安全性。

**补充：**

存储数据主要有三种方式：块存储、文件存储和对象存储

- **块存储**以数据块为单位进行存储，每个数据块都有直接的编号，没有文件系统，因此块存储无法在不同文件系统之间共享。
  - 块存储的优点在于它的读写速率和传输速率都很高，因为它直接作用于操作系统和底层设备之间，适用于频繁进行IO。
  - 但它的缺点就是数据无法在不同的文件系统之间共享。
- **文件存储**采用树状目录结构来管理和组织方式，也就是我们常见的文件和文件夹结构，这种存储方式提供了文件系统层次结构，用户和应用程序可以通过文件路径进行数据访问
  - 弥补块存储无法共享的缺点：能够进行文件共享
  - 但是文件存储读写速率低、传输速率慢
- **对象存储**是一种基于对象的存储结构，它的结构类似于Key-Value结构，Key对应的是全局唯一标识符UID，通过UID唯一标识每个对象；Value对应文件数据和相关元数据。对象存储能够以RESTful API形式访问资源。
  - 与文件存储的树状结构不同，对象存储具有扁平化和内置的分布式特性，因此对象存储非常适用于大规模的非结构化数据存储
  - 另外，文件存储的存储空间有限，而对象存储能够无限扩容
  - 可以说对象存储结合了块存储和文件存储的优点。

### 为什么使用Elasticsearch?



### 如何部署？

使用Docker将开发代码以及依赖的环境打包为镜像，使用Docker Compose统一部署允许

## 功能实现

### 登录功能

#### 密码加密方式

为了保证用户数据的安全，数据库不存储用户密码的明文形式，而是存储用户密码加密后的值。

在本项目中，由于BCrypt算法适用于任何需要保护密码或者敏感信息的场景，我们选择使用基于BCrypt算法实现的FastAPI框架内置的哈希算法工具CryptContext

BCrypt算法通过使用一个随机的字符串与密码组合在一起生成哈希值，这个随机的字符串称为盐值，由于盐值是随机的，所以即使使用相同的密码，每次生成的哈希值也不同，这意味着我们可以有效地防止攻击者使用“彩虹表”等预先计算的哈希值来攻击系统

另外，BCrypt算法还可以使用一个“cost"值来控制哈希计算的强度和速度，cost值越高，计算时间和内存开销就越大，破解哈希值越难。

```
pwd_context = CryptContext(schemes = ["bcrypt"], deprecated = "auto")
```



#### 鉴权

##### 相关知识

> 区分Authentication和Authorization
>
> - Authentication是认证，验证你的身份的凭据（例如用户名/用户ID和密码）
> - Authorization是授权，发生在Authentication认证之后。授权是给予某个用户访问某些资源的权限。

鉴权(authentication)是指验证用户是否拥有访问系统的权力。

常见的鉴权方式有四种：

- HTTP Basic Authentication
- Session和Cookie
- Token验证
- OAuth

###### HTTP Basic Authentication

这种鉴权方式大概流程为：

1. 客户端向服务端请求页面，客户端没有被验证，缺少Authorization字段

   ```
   Get /index.html HTTP/1.0
   Host:www.google.com
   ```

2. 服务端发现客户端没有验证，发送验证请求401 Unauthorised

   ```
   HTTP/1.0 401 Unauthorised
   Server: SokEvo/1.0
   WWW-Authenticate: Basic realm=”google.com”
   Content-Type: text/html
   Content-Length: xxx
   ```

3. 客户端收到401返回值，将自动弹出登录窗口，要求用户输入用户名和密码

4. 用户输入用户名和密码后，将用户名及密码以BASE64方式编码，编码后字符串放入前一条请求中，重新发出请求

   ```
   Get /index.html HTTP/1.0
   Host:www.google.com
   Authorization: Basic d2FuZzp3YW5n
   ```

5. 服务端收到上述请求信息后，将Authorization字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库验证，如果用户名和密码正确，服务端则根据请求，将所请求资源发送给客户端

这种方法有明显的缺陷，base64并不是加密方法只是一种编码方式，而且HTTP是明文传输，如果报文被拦截，则用户名和密码非常容易获得

###### Session-Cookie

HTTP协议是无状态的，为了能让服务器知道用户当前所处的状态，需要存储一些信息在当前用户访问

**Cookie和Session的关系与区别**

- Cookie数据存放在客户的浏览器上，Session数据存放在服务器上
- Session会在一定时间内保存在服务器上，当用户访问量增多，会占用服务器的性能，考虑到减轻服务器性能方面，应当使用cookie
- 单个cookie在客户端的限制是3k，就是说一个站点在客户端存放的cookie不能超过3k

**Session-Cookie认证机制**

1. 用户输入登录信息
2. 服务器验证登录信息，如果正确，则生成session信息
3. 服务器为当前的Session信息生成一个唯一的标识SessionID，然后放入Response 头部中的SetCookie中
4. 客户端收到响应后就会把Cookie存起来，当下次请求时，浏览器会自动带上该Cookie
5. 服务端从Request头部解析Cookie获取到SessionID，通过SessionID获取保存在服务端的Session信息进行权限校验
6. 当浏览器退出登录时，浏览器端岛的Cookie和服务器端的Session都会被清除

**已经有了`Cookie`了，那为什么还需要`Session`呢？**

- 是因为`Cookie`其实有很多的限制的，每种浏览器存储`Cookie`都会有大小限制；
- `Cookie`是存储在客户端的所以很容易被篡改；
- 每次发送请求时都会带着`Cookie`所以一些敏感信息不方便存储在`Cookie`中；
- 还有就是`Cookie`有同源限制的问题；
- 所以将一些用户的登录信息存储在`Session`中比较方便，安全

**基于 Session - Cookie 认证的优缺点**

session-cookie 认证机制在基本上所有的网页浏览器上都能够支持，而且实现方式也很简单

1. 当存在多台服务器时会出现 `session`同步问题
2. 很容易遭受到 `Cookie` 欺骗和 `CRFS`攻击
3. 服务端存储压力，当很多的`session`存储到服务端时，会对服务器的存储造成压力
4. 跨域问题，`Cookie`是属于同源策略限制的条件之一

> 同源：指协议、IP地址、端口号相同

Cookie主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

###### Token认证

1. 用户输入登录凭据（账号密码）
2. 服务器验证凭据是否正确，然后返回一个经过签名的Token
3. 客户端负责存储Token，可以存在localstorage，或者cookie中
4. 之后客户端对服务器的请求带上这个Token
5. 服务器对Token进行解码，如果Token有效，则处理该请求
6. 一旦用户登出，客户端销毁Token

JWT是Token中的一种，JWT全名为JSON Web Token，它包含三个部分：

- Header头部
- Payload负载
- Signature签名

三者以”.“号做分割

###### OAuth

##### 功能实现

本项目使用基于OAuth2.0鉴权方式实现Bearer JWT 令牌验证

JWT字符串没有加密，任何人都能用它恢复原始信息



**如何生成JWT：**

1. 如果用户登录成功，我们从数据库MySQL获取当前登录人的邮箱
2. 将邮箱和过期时间作为数据传入jwt类的encode函数中，另外生成签名所需要的密钥和哈希算法类型也传入encode函数
3. 最后生成一个JWT

```
# 创建令牌
def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
```

**验证令牌并获取令牌中的用户信息**

使用jwt类的decode函数对传入参数token进行decode

```
payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
```

由于数据以字典的方式存储在JWT中，因为我们使用get函数就能获取其中的邮箱

```
mail: str = payload.get("sub")
```

通过邮箱信息，我们能够从MySQL获取该用户的全部信息

### 加水印功能

- watermark文件夹存放添加水印后未被下载的文件
- download文件夹存放添加水印并且已被下载的文件

#### 业务介绍

> 经过用户上传统计，我们发现用户上传的文件分为文档类和图书类。
>
> - 前者所有页面大小相同（文件通常比较小）
> - 后者存在较大的两个封面页，之后全是页面大小相同的内容页（文件通常比较大）

当用户点击下载按钮，后端获取该文件的文件名，并自动计算该文件的文件路径，从LRU缓存中插入该文件

编辑水印内容，判断文件大小：

- 如果在规定大小范围内，添加水印（我们认为是原创类文档）
- 如果超过规定大小，则不添加水印（我们认为这是书籍类文档），并直接将其移动到download文件夹

**Problem 1: 加水印大小自适应问题**

实现加水印过程中，我们发现用户的文件页面大小不一（比如在同一个pdf中，存在页面非常大的封面页和页面正常的内容也），不能仅仅通过创建一个水印页面适用于所有页面，否则会造成水印位置偏移等水印效果不好的情况

对于这种情况，我们尝试了多个办法

**Solution 1：单线程创建自适应pdf**

> 相关代码在`create_watermark_adapted_singleThread`和`add_watermark_file_singleThread`

我们尝试创建一个多页的水印pdf，该pdf每一页的大小与对应输入pdf的每一页大小相同，从而实现自适应

代码示例如下：

思路为：将多个水印页面合并在一个pdf内

```python
    for i in range(pageNum):
        page = pdf_input.getPage(i)
        page_width = float(page.mediaBox.getWidth())
        page_height = float(page.mediaBox.getHeight())
        pageSize=(page_width,page_height)
        pdf_watermark_data=create_watermark(content,pageSize)
        pdf_watermark_singleFile = PdfFileReader(BytesIO(pdf_watermark_data), strict=False)
        pdf_watermark_singleFilePage = pdf_watermark_singleFile.getPage(0)
        pdf_watermark_singleFilePage.compressContentStreams()
        pdf_watermark_file.addPage(pdf_watermark_singleFilePage)
```

**Problem 2：加水印过慢**

解法1能解决自适应水印页面问题，但会造成加水印速度过慢，于是我们想通过多线程加速

**Solution 2：多线程创建自适应pdf**

> 相关代码在`create_watermark_adapted_multiThread`和`add_watermark_file_multiThread`

我们通过创建线程池，对创建水印的行为进行并行操作

```python
page_results=pool.map(create_watermark_adapted_multiThread,content_list,page_list)  
```

遗憾的是，我们发现线程池并不会显著加速加水印（仅仅加速了3s，对于60s的总时间来说显然不够）

通过测速，我们发现时间主要消耗：将水印文件和输入文件合并的操作中的addPage函数，由于需要保障输出文件的有序性，addPage无法避免，因此我们也放弃了这种方法

**Solution 3：只考虑两种情况**

> 相关代码在`create_watermark`

相比于之前的方法，我们最后为了缩短下载时间选择了不那么全面的解法：我们暂时只考虑两种情况（书籍PDF和普通PDF）

书籍PDF有个显著特点：前两页为封面页，页面比较大；后面为内容页，页面比较小

普通PDF则全部页面大小都相同

因此我们用以下代码解决以上两种情况：

我们只取第一页和第三页，对其大小进行比较，取最小页面大小，从而实现水印兼容

由于水印文件只有一页，所以大大缩短了加水印的时间

```
# 获得封面页尺寸
    page = pdf_input.getPage(0)
    page_width = float(page.mediaBox.getWidth())
    page_height = float(page.mediaBox.getHeight())
    pageSize=(page_width,page_height)

    if pageNum > 3:
        page = pdf_input.getPage(0)
        page_width = min(page_width,float(page.mediaBox.getWidth()))
        page_height = min(page_height,float(page.mediaBox.getHeight()))
        pageSize=(page_width,page_height)
```

**Solution 4: LRU优化下载**

我们发现下载文件也是个非常耗时的过程，但这个主要是因为网速太慢。为了优化下载的时间，我们选择使用LRU算法实现下载API。

LRU原理如下链接：

[全面讲解LRU算法-CSDN博客](
