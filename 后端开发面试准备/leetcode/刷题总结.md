## 数组

### 移除元素

#### 解法一：暴力解法

注意一定要`i--`，因为移除后第i个元素已经被替换为新的未遍历元素

```c++
        int size = nums.size();
        for (int i = 0; i < size; i++) {
            if (nums[i] == val) {
                for (int j = i+1; j < size; j++) 
                    nums[j-1] = nums[j];
                i--;
                size--;
            }
        }
        return size;
```



#### 解法二：双指针

fast指向指向下一个不等于val的元素，slow指向新数组的下一个元素的位置（新数组的长度为slow）

当`nums[fast]!=val`表示fast指针找到了新数组的下一个元素，此时`nums[slow]=nums[fast]`，将fast找到的元素填入新数组

`slow++`保证slow永远指向数组下一个待填充元素的位置

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;
        int size = nums.size();
        for(int fast = 0;fast<size;fast++){
            if(nums[fast]!=val){
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }
};
```

### 有序数组的平方

题目说非递减数组，这个数组包含了负数和正数，因此绝对值大的数分布在数组的两侧，中间的反而是绝对值小的，因此我们只需要设立两个指针，分别比较数组两侧的平方值

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int size = nums.size();
        int k = size-1;
        int right = size-1;
        int left = 0;
        vector<int> res(size,0);
        while(left<=right){
            if(nums[left]*nums[left]<nums[right]*nums[right]){
                res[k--] = nums[right]*nums[right];
                right--;
            }
                
            else{
                res[k--] = nums[left]*nums[left];
                left++;
            }
                
        }
        return res;
    }
};
```



### 长度最小的子数组

第一想法是暴力解法：

```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = INT_MAX;
        for(int i=0;i<nums.size();i++){
            int sum=0;
            for(int j=i;j<nums.size();j++){
                sum+=nums[j];
                if(sum>=target)
                    len = min(len,j-i+1);
            }
        }
        return len == INT_MAX?0:len;
    }
};
```

但这种方法时间复杂度太高



#### 解法二：滑动窗口

暴力解法是通过for起始位置，再for终止位置，直到sum>=target计算最小长度

那我们能不能减少一次循环呢

如果我们只for起始位置，那么终止位置无从得知，还要再for一次

但如果我们只for终止位置，起始位置一开始不变，那么就能确定初步的子数组

我们这时候再移动起始位置，进一步收缩范围，就能确定最终的长度最小子数组

**fast将会一直往下找满足sum>=target的元素，如果sum<target，slow再进行收缩**

```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int slow =0;
        int minLen = INT_MAX;
        int sum=0;
        for(int fast = 0;fast<nums.size();fast++){
            sum+=nums[fast];
            while(sum>=target){
                minLen = min(minLen,fast-slow+1);
                sum-=nums[slow];
                slow++;
            }
        }
        return minLen==INT_MAX?0:minLen;
    }
};
```



### 螺旋矩阵2

注意：模拟遍历规则为左闭右开

loop=n/2是因为循环一次的上下两边是对称的，左右两边是对称的，所以需要遍历n/2次

如果n%2不为0，表明n为奇数，此时整个结果矩阵不能刚好完成循环（最后只剩下一个点），此时中间的值需要额外赋值

> 假设长度为n，mid = n/2，那么偶数时，mid指向中间两个数偏右的那个，奇数时mid指向中间那个
>
> 因此能完成的循环次数为n/2



```
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n,vector<int>(n,0));
        int startx = 0, starty = 0;
        int offset = 1;
        int loop = n/2;
        int mid = n/2;
        int count = 1;
        while(loop--){
            int i=startx;
            int j=starty;
            for(;j<n-offset;j++)
                res[startx][j] = count++;
            for(;i<n-offset;i++)
                res[i][j] = count++;
            for(;j>starty;j--)
                res[i][j] = count++;
            for(;i>startx;i--)
                res[i][j] = count++;
            startx++;
            starty++;
            offset++;
        }
        if(n%2){
            res[mid][mid]=count;
        }
        return res;
    }
};
```



## 链表

### 删除链表的节点

[LCR 136. 删除链表的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/description/)

> 思路：添加哨兵节点方便插入和删除



```c++
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        ListNode* dummyNode = new ListNode();
        dummyNode->next = head;
        ListNode* cur = dummyNode;
        while(cur->next->val!=val){
            cur = cur->next;
        }
        cur->next = cur->next->next;
        return dummyNode->next;
    }
};
```



### 设计链表

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)



### 反转链表

> 思路：每两个节点之间的反转操作都是相同的，所以最先能够想到递归（自顶向下），对应自底向上的优化做法则为迭代，故有两种做法

#### 递归版

**总思路：**反转整个链表为总问题，自顶向下进行分解，则最后分解为：最末尾的两个节点进行反转，之后逐步向上重复步骤：每两个节点之间进行反转，最终即可得到反转链表

由上述思路即可得到：

- 递归边界：到达倒数第二个节点（保证有下一个节点）

  - 对应代码`if(!head->next)`

- 子问题：改变两个节点之间的指向（反转）

  - 具体实现：当前节点的子节点已经被反转

  - 对应代码：

    ```
    ListNode* nextNode = head->next;
    nextNode->next = head;
    head->next = nullptr;
    ```



```

```

### 合并两个有序链表

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* head1 = list1;
        ListNode* head2 = list2;
        ListNode* dummyNode = new ListNode(0);
        ListNode* cur = dummyNode;

        while (head1 != nullptr && head2 != nullptr) {
            if (head1->val < head2->val) {
                cur->next = head1;
                head1 = head1->next;
            } else {
                cur->next = head2;
                head2 = head2->next;
            }
            cur = cur->next;
        }

        cur->next = head1 == nullptr ? head2 : head1;
        return dummyNode->next;
    }
};
```



## 字符串

### 字符串转为整数

```
class Solution {
public:
    int myAtoi(string s) {
        int i = 0;
        int sign = 1;
        int bdry = INT_MAX/10;
        int tmp = 0;
        while(s[i]==' ')
            i++;
        if(s[i]=='-')
            sign = -1;
        if(s[i]=='-'||s[i]=='+')
            i++;
        while(s[i]>='0'&&s[i]<='9'){
            if((tmp>bdry)||(tmp == bdry && s[i]>'7'))
                return (sign == 1)?INT_MAX:INT_MIN;
            tmp = tmp*10+(s[i++]-'0');
        }
        return sign*tmp;
    }
};
```

## 二叉树

### 先序遍历

### 中序遍历

访问顺序和遍历顺序不同，访问的节点用cur表示，遍历顺序用stack存储

访问完所有左子树再访问根节点，之后访问的右子树和遍历顺序相同



## 动态规划

### 打家劫舍系列

#### 打家劫舍1

```
class Solution {
public:
    int rob(vector<int>& nums) {
        int N = nums.size();
        if(N==0)
            return 0;
        else if(N==1)
            return nums[0];
        vector<int> dp(N,0);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        for(int i=2;i<N;i++){
            dp[i] = max(dp[i-2]+nums[i],dp[i-1]);
        }
        return dp[N-1];
    }
};
```



#### 打家劫舍2

因为头尾元素不能同时取，因此可以分类讨论将环展开

- 假设正确答案包含头元素，不包含尾元素
- 假设正确答案不包含头元素，包含尾元素

robRange即为打家劫舍1的做法

```
class Solution {
private:
    int robRange(vector<int>&nums,int low,int high){
        if(low==high)
            return nums[low];
        // 这里注意要nums.size()，因为high-low+1个元素不包含索引为high的元素
        vector<int> dp(nums.size(),0);
        dp[low] = nums[low];
        dp[low+1] = max(nums[low],nums[low+1]);
        for(int i=low+2;i<=high;i++){
            dp[i] = max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[high];
    }
public:
    int rob(vector<int>& nums) {
        int N = nums.size();
        if(N==0)
            return 0;
        if(N==1)
            return nums[0];
        int res1 = robRange(nums, 0, N-2);
        int res2 = robRange(nums,1,N-1);
        return max(res1,res2);
    }
};
```



### 股票买卖系列

#### 股票买卖1

##### 贪心算法

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int res = INT_MIN;
        for(int i=0;i<prices.size();i++){
            low = min(low,prices[i]);
            res = max(res,prices[i]-low);
        }
        return res;
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

##### 动态规划

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int N = prices.size();
        if(N==0)
            return 0;
        vector<vector<int>> dp(N,vector<int>(2,0));
        // dp[i][0]表示第i天持有股票的利润（一定为负，比谁负的更少）
        // dp[i][1]表示第i天不持有股票的利润（可能为负可能为正）
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        //这里i一定要从1开始
        for(int i = 1;i<N;i++){
            //两种情况：第i-1天持有股票 或 第i天持有股票（第i天买入股票）
            dp[i][0] = max(dp[i-1][0],-prices[i]);
            //两种情况：第i-1天不持有股票 或 第i天不持有股票（第i天卖出股票）
            dp[i][1] = max(dp[i-1][1],prices[i]+dp[i-1][0]);
        }
        //最后一天不持有股票一定是最终结果，因为其包含了前N-1天所有可能结果和第N天的可能结果的max值
        return dp[N-1][1];
    }
};
```



#### 股票买卖2

##### 贪心

```

```



##### 动态规划

与股票买卖1不同之处在于：`dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i]);`而不是`dp[i][0] = max(dp[i-1][0],-prices[i]);`

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int N = prices.size();
        if(N==0)
            return 0;
        vector<vector<int>> dp(N,vector<int>(2,0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i=1;i<N;i++){
            dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[N-1][1];
    }
};
```



#### 股票买卖3



### 子序列系列

**递增系列**

1. 最长递增子序列
2. 最长连续递增子序列

1和2的区别在于是否连续

**公共子数组系列**

1. 最长重复子数组
2. 最长公共子序列

1和2的区别在于是否连续，对于这种公共系列，我们采用了`dp[i][j]`表示nums1[i-1]和nums2[j-1]元素结尾的序列/数组，而不是用`dp[i][j]`表示nums1[i]和nums2[j]元素结尾的序列/数组，是为了简化代码，避免初始化和具体的操作有麻烦

#### 最长递增子序列

[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/)

##### 题目分析

关键词：子序列+严格递增

- 子序列说明元素可以不连续
- 严格递增说明不存在相等的情况

##### 解题思路

1. **dp[i]的含义：**dp[i]为以第i个元素结尾的最长递增子序列的长度
2. **递推公式：**当前元素为第i个元素，要获取之前的最长递增子序列的长度，需要对dp[j]寻找一遍(j<i)，因为<u>子序列是不连续的序列</u>
   - 如果nums[i]>nums[j]，则说明当前第i个元素可以作为第j个元素的最长递增子序列的下一个元素，则dp[i] = dp[j]+1
   - 如果nums[i]<=nums[j]，则说明当前第i个元素不是作为第j个元素的最长递增子序列的下一个元素，则不需要计算dp[i]
   - 这里我们有一个小设计，因为dp[i]最终表示以第i个元素结尾的最长递增子序列的长度，而在j遍历时，dp[i]是不断变化的，因此dp[i] = max(dp[i],dp[j]+1)。也就是说，dp[i]是存储上一次的dp[j]并和下一次的dp[j]比较，取最大值
3. **遍历顺序：**因为j<i，所以遍历顺序从左到右;另外，因为dp[0]我们自己初始化的，因此可以从i=1开始遍历
4. **初始化：**每个元素结尾的子序列长度最小值都为1，因此都需要初始化为1，表现为`vector<int> dp(nums.size(),1);`
5. **结果：**因为dp[i]仅表示以第i个元素结尾的最长递增子序列的长度，因此需要取整个dp数组的最大值

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int N = nums.size();
        int res = 1;
        vector<int> dp(N,1);
        for(int i=1;i<N;i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j])
                    dp[i] = max(dp[i],dp[j]+1);
            }
            res = max(res,dp[i]);
        }
        return res;
    }
};
```



#### 最长连续递增子序列

##### 题目分析

和上一题不同，这道题强调“连续”，因此我们只需要关注相邻两个元素nums[i]和nums[i-1]即可

##### 解题思路

1. **dp[i]的含义：**dp[i]为以第i个元素结尾的最长**连续**递增子序列的长度
2. **递推公式：**当前元素为第i个元素，要获取之前的最长递增子序列的长度，<u>只需要知道第i-1个元素的大小（这里体现“连续”的不同之处）</u>
   - 如果nums[i]>nums[i-1]，则说明当前第i个元素可以作为第i-1个元素的最长连续递增子序列的下一个元素，则dp[i] = dp[i-1]+1
   - 如果nums[i]<=nums[i-1]，则说明当前第i个元素不是作为第j个元素的最长递增子序列的下一个元素，则连续递增子序列从当前nums[i]断开，开始新的连续递增子序列，即dp[i]=1，由于初始化已将所有元素初始化为1，所以也就是不需要任何操作;
3. **遍历顺序：**显然i-1<i，所以遍历顺序从左到右;另外，因为dp[0]我们自己初始化的，因此可以从i=1开始遍历
4. **初始化：**每个元素结尾的子序列长度最小值都为1，因此都需要初始化为1，表现为`vector<int> dp(nums.size(),1);`
5. **结果：**因为dp[i]仅表示以第i个元素结尾的最长递增子序列的长度，因此需要取整个dp数组的最大值

```
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N,1);
        int res = 1;
        for(int i=1;i<N;i++){
            if(nums[i]>nums[i-1])
                dp[i] = dp[i-1]+1;
            res = max(res,dp[i]);
        }
        return res;
    }
};


```



#### 最长重复子数组

##### 题目分析

子数组 强调“连续”

##### 解题思路

1. **`dp[i][j]`的含义：**
   - 因为有两个数组，因此需要使用i表示nums[i]，用j表示nums[j]
   - 我们只关注两个数组中长度最长的子数组的长度，因此`dp[i][j]`表示第i-1个元素nums1[i-1]结尾和第j-1个元素nums2[j-1]结尾的公共最大长度
2. **递推公式：**当前nums1元素为第i-1个元素，当前nums2元素为第j-1个元素。
   - 首先要注意：两个数组公共数组下标可以不同，但长度一定相同，且连续
   - 如果nums1[i-1]==nums2[j-1]，则两个数组均反推前一个元素，在`dp[i-1][j-1]`基础上加1
   - 如果nums1[i-1]!=nums2[j-1]，因为两个数组公共数组长度一定相同且连续，所以说明公共子数组从此处断开，公共子数组长度重置为1
3. **遍历顺序：**显然i-1<i,j-1<j，所以遍历顺序从左到右;另外，因为`dp[i][0]`和`dp[0][j]`我们自己初始化的，因此可以从i=1开始遍历
4. **初始化：**
   - `dp[i][0]`表示nums2长度为0，所以公共长度均为0；
   - `dp[0][j]`表示nums1长度为0，所以公共长度均为0；
5. **结果：**因为`dp[i][j]`仅表示以nums1第i-1个元素结尾和nums2第j-1个元素结尾的最长公共子数组的长度，因此需要取整个dp数组的最大值

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size()+1,vector<int>(nums2.size()+1,0));
        int res = 0;
        for(int i=1;i<=nums1.size();i++){
            for(int j=1;j<=nums2.size();j++){
                if(nums1[i-1]==nums2[j-1])
                    dp[i][j] = dp[i-1][j-1]+1;
                res = max(res,dp[i][j]);
            }
        }
        return res;
    }
};
```

#### 最长公共子序列

##### 题目分析

与上题不同，子序列不连续

##### 解题思路

1. **`dp[i][j]`的含义：**

   - 因为有两个数组，因此需要使用i表示nums[i]，用j表示nums[j]
   - 我们只关注两个数组中长度最长的子数组的长度，因此`dp[i][j]`表示第i-1个元素nums1[i-1]结尾和第j-1个元素nums2[j-1]结尾的公共最大长度

2. **递推公式：**当前nums1元素为第i-1个元素，当前nums2元素为第j-1个元素。

   - 如果nums1[i-1]==nums2[j-1]，则两个数组均反推前一个元素，在`dp[i-1][j-1]`基础上加1（与上题相同）

   - 如果nums1[i-1]!=nums2[j-1]

     - 上题提到：因为两个数组公共数组长度一定相同且连续，所以说明公共子数组从此处断开，公共子数组长度重置为1

     - 但本题中由于不连续，如果nums1[i-1]!=nums2[j-1]并不一定会导致公共子序列断开，因此需要在`dp[i-1][j-1]`的基础上对nums1[i-1]和nums2[j-1]分类讨论

       - 如果加入nums1[i-1]（删除nums2[j-1]）公共子序列会不会长度增加，
       - 如果加入nums2[j-1]（删除nums1[i-1]）公共子序列会不会长度增加

       最后将分类讨论结果取最大值，即`max(dp[i-1][j],dp[i][j-1]);`

3. **遍历顺序：**显然i-1<i,j-1<j，所以遍历顺序从左到右;另外，因为`dp[i][0]`和`dp[0][j]`我们自己初始化的，因此可以从i=1开始遍历

4. **初始化：**

   - `dp[i][0]`表示nums2长度为0，所以公共长度均为0；
   - `dp[0][j]`表示nums1长度为0，所以公共长度均为0；

5. **结果：**因为`dp[i][j]`仅表示以nums1第i-1个元素结尾和nums2第j-1个元素结尾的最长公共子序列的长度，因此需要取整个dp数组的最大值

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size()+1,vector<int>(text2.size()+1,0));
        int res = 0;
        for(int i=1;i<=text1.size();i++){
            for(int j=1;j<=text2.size();j++){
                if(text1[i-1]==text2[j-1])
                    dp[i][j] = dp[i-1][j-1]+1;
                else
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
                res = max(res,dp[i][j]);
            }
        }
        return res;
    }
};
```

#### 不相交的线

[1035. 不相交的线 - 力扣（LeetCode）](https://leetcode.cn/problems/uncrossed-lines/)

本题实际为套壳的最长公共子序列



#### 最大子数组和

##### 题目分析

连续子数组，求最大和

##### 解题思路

1. **`dp[i]`的含义：** 第i-1个元素结尾的连续子数组的最大和
2. **递推公式：** 
   - 如果dp[i-1]>=0，说明当前元素nums[i]加上dp[i-1]和会更大
   - 如果dp[i-1]<0，说明当前元素nums[i]加上dp[i-1]和会变小，不满足最大和的定义，因此连续子数组会从这个地方断开，dp[i]=nums[i]
3. **遍历顺序：**显然i-1<i所以遍历顺序从左到右
4. **初始化：**`dp[0]=nums[0];`
5. **结果：**因为`dp[i]`仅表示以nums第i-1个元素结尾的连续子数组的最大和，因此需要取整个dp数组的最大值

```
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int N = nums.size();
        int res = nums[0];
        vector<int> dp(N,0);
        dp[0]=nums[0];
        for(int i=1;i<N;i++){
            if(dp[i-1]>=0)
                dp[i] = dp[i-1]+nums[i];
            else
                dp[i] = nums[i];
            res = max(res,dp[i]);
        }
        return res;
    }
};
```

可以进一步精简：

```
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(),0);
        dp[0]=nums[0];
        int res = nums[0];
        for(int i=1;i<nums.size();i++){
			dp[i] = max(dp[i-1]+nums[i],nums[i]);
            res = max(res,dp[i]);
        }
        return res;
    }
};
```



## 二分法

### 寻找旋转排序数组中的最小值

注意本题我们要让`left<right` ，因为当left==right的时候就是最小值，我们要让循环跳出来返回结果

`right = mid`，因为left<right

```
class Solution {
public:
    int findMin(vector<int>& nums) { 
        int left = 0,right = nums.size()-1;
        while(left<right){
            int mid = left+(right-left)/2;
            if(nums[mid]<nums[right])
                right = mid;
            else
                left = mid+1;
        }
        return nums[left];
    }
};
```

## 排序

### 数组中的第K个最大元素

#### 计数排序

O(n)时间复杂度并且数据范围给定，想到计数排序

```
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        vector<int> counter(20005);
        for(int i=0;i<nums.size();i++){
            counter[nums[i]+10000]++;
        }
        for(int i=20004,sum=0;i>=0;i--){
            sum+=counter[i];
            if(sum>=k)
                return i-10000;
        }
        return 0;
    }
};
```



## 技巧型

### 用rand7实现rand10

```
class Solution {
public:
    int rand10() {
        int first,second;
        while((first = rand7())>2){}
        while((second = rand7())>5){}
        return (first-1)*5+second;
    }
};
```



**如果rand7实现100**

100 = 4x5x5

```
class Solution {
public:
    int rand10() {
        int first,second;
        while((first = rand7())>2){}
        while((second = rand7())>5){}
        while((third = rand7())>5)
        return (first-1)*25+(second-1)*5+second;
    }
};
```



**一般地，对于randN实现randM**

对M进行因数分解，例如100分成2x2x5x5，但是不用分成2x2这么细，只需要小于等于N即可，因此100可分为4x5x5

假设M分为了axbxcxd，那么有

```
while((first=randN())>a)

while((second=randN())>b)

while((third=randN())>c)

while((fourth=randN())>d)
```

最后组合起来

```
(first-1)*bxcxd+(second-1)*cxd+(third-1)*d+fourth
```

原理也很简单，a将整个[1,M]分成a份，每份有bxcxd，类比于一维矩阵，第k行为(k-1)xbxcxd

b在第a份里面进一步细分，类比于二维矩阵，第k行第j列为(k-1)xbxcxd+(j-1)xcxd

其余同理



