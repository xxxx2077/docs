# Static Program Analysis

## Introduction

### Why we need static analysis?

1. Program Reliability（程序可靠性）
   - Null Pointer dereference（空指针引用）
   - memory leak（内存泄漏）
2. Program Security
   - Private Information leak（隐私信息泄漏）
   - injection attack（注入攻击）
3. Compiler Optimization
   - Dead code elimination（死代码消除）
   - code motion
4. Program Understanding
   - IDE call hierarchy（IDE调用关系图）
   - type indication（类型提示）

### What is Static Analysis

Static analysis analyzes a program P to reason about its behaviors and determines whether it <u>satisfies some properties</u> **before** running P. 

- Does P contain any private information leaks? 
- Does P dereference any null pointers? 
- Are all the cast operations in P safe? 
- Can v1 and v2 in P point to the same memory location?
-  Will certain assert statements in P fail? 
- Is this piece of code in P dead (so that it could be eliminated)? 
- …

也就是说，静态分析是在程序**运行前**分析程序行为以及程序是否满足某些**属性**（这些属性根据问题的不同而不同，某个属性可视作某个问题的抽象）

### Rice’s Theorem定理

Any **non-trivial** property of the behavior of  programs in a r.e. language is undecidable.

- r.e. (recursively enumerable) = recognizable by a Turing-machine

A property is trivial if either it is not satisfied by any r.e. language,  or if it is satisfied by all r.e. languages; otherwise it is non-trivial.

**莱斯定理的通俗理解：**

任取一个不为空也不为全集的属性，某个程序是否满足这个属性是不可判定的

举个例子：

假设给定某个程序，我们想要判断这个程序是否存在空指针引用

- 属性为“是否存在空指针引用”

根据莱斯定理，我们无法判断这个程序是否存在空指针引用，也就是，我们无法肯定地说“这个程序一定存在/不存在空指针引用”

换个角度说，Static Analysis is not **perfect**:

> Perfect: Can determine whether P satisfies such non-trivial properties, i.e., giving exact answer: Yes or No

But Static Analysis can be **useful**

在讨论如何useful之前首先要介绍两个概念Sound（纯粹性）和Complete（完备性）

- Sound: 满足条件的一定在结果集中
  - 可以误报，但不能漏报（即Over-approximate）
- Complete: 结果集中的元素一定满足条件
  - 可以漏报，但不能误报（即Under-approximate）

**举个例子：**
条件：高考成绩在全省前100名
结果：考入清华大学

**纯粹性Sound：**满足条件的一定在结果集中。

即：高考成绩前100名的本科生都来到了清华。言外之意，还有很多通过自主招生或者特别优秀的即使高考成绩没在前100名的同学也来到了清华。

**完备性Complete：**结果集中的元素一定满足条件。

即：考入清华大学的本科生一定在全省前100名。言外之意，部分在全省前100名的本科生可能没有来清华，去了北大。

**在Static Analysis中：**

- Sound：满足属性(properties)的结果一定在Sound的结果集中（即Over-approximate）
- Complete： Complete的结果集中所有结果都满足属性（即Under-approximate）

![image-20240321110322721](程序分析.assets/image-20240321110322721.png)

由于Sound和Complete不能同时满足，因此

**Useful** Static Analysis可分为Compromise soundness和Compromise completeness两种

- Compromise soundness (false negatives)：满足sound的分析方法
  - 
- Compromise completeness (false positives)：满足complete的分析方法
  - 

Mostly compromising completeness: Sound but not fully-precise static analysis

### Key point

What are the differences between static analysis and (dynamic) testing?

Understand soundness, completeness, false negatives, and false positives.

Why soundness is usually required by static analysis?

How to understand abstraction and over-approximation?

## Intermediate Representation



## 上下文敏感指针分析

上下文有不同的策略，其中一种策略为：context为一串callsite的链表（由于调入的深入，调用点信息越来越多）

可以这么理解上下文：标记数据流的来源，从而不会混淆数据流

上下文不敏感反之