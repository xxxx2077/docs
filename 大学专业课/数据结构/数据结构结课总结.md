# 数据结构结课总结

[TOC]



## 线性结构

### 线性表

#### 逻辑结构

按顺序存储元素，有唯一的起始节点（无前驱有后驱）和终止节点（有前驱无后驱）

#### 抽象数据类型定义

```c++
template<class T>
class linearList
{
    //查看表是否为空
	virtual void empty()const;
    //获取表的长度
	virtual int size()const;
    //取表中第i个数据元素
	virtual T& get(int theIndex);
    //按值查找
	virtual int indexOf(const T& theElement) const;
    //在表中第i个位置插入新的数据元素e
	virtual void insert(int theIndex,const T& theElement);  
    //删除表中第i个数据元素
	virtual void erase(int theIndex);
};
```

#### ![image-20230119203916246](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230119203916246.png)

#### 存储结构

##### 顺序表与链表的比较

<u>这里链表插入和删除的时间复杂度为O(1)，意思是指针已经指向了要插入或删除的位置，而一般我们所说的插入和删除，包含了查找的部分，所以平均时间复杂度为O(n)</u>

![image-20230130214621285](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230130214621285.png)

![image-20230130214550434](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230130214550434.png)

![image-20230130214814257](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230130214814257.png)

![image-20230130214832393](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230130214832393.png)

![image-20230130215031331](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230130215031331.png)

##### 顺序表

用一组<u>连续的</u>存储单元依次存储数据元素

数据元素之间的逻辑关系由<u>元素的存储位置</u>来表示（下标）

```c++
template<class T>
class arrayList :public linearList<T>
{
public:
    arrayList(int Capacity = 10);
	arrayList(const arrayList<T>&);
	~arrayList();
	void empty()const;
	int size()const;
	T& get(int theIndex);
	int indexOf(const T& theElement) const;
	void insert(int theIndex, const T& theElement);
	void erase(int theIndex);
protected:
	void checkIndex(int theIndex)const;//检查下标是否合法
	T* element;//存储数据元素的一维数组
	int arrayLength;//数组容量
	int listSize;//数据元素个数
};
```

**具体操作实现：**

**构造函数**

Capacity为线性表初始化的空间大小，例如想要容纳10个元素的线性表，则让Capacity=10

```C++
template<class T>
arrayList<T>::arrayList(int Capacity)
{
	if (Capacity < 1)
	{
		ostringstream s;
		s << "Initial capacity = " << Capacity << "Must be > 0";
		throw illegalParameterValue(s.str());
	}
	arrayLength = Capacity;
	element = new T[arrayLength];
	listSize = 0;
}
```

**复制构造函数**

```c++
template<class T>
arrayList<T>::arrayList(const arrayList<T>&aL)
{
	listSize = aL.listSize;
	arrayLength = aL.arrayLength;
	element = new T[arrayLength];
	copy(aL.element，aL.element + listSize, element);
	//copy函数底层实现
	//std::copy(iterator source_first, iterator source_end, iterator target_start);
}
```

**析构函数**

```C++
template<class T>
arrayList<T>::~arrayList()
{
	delete[] element;
}
```

**检查线性表是否为空**

```C++
template<class T>
bool arrayList<T>::empty()const
{
	if (listSize <= 0)
		return true;
	else
		return true;
}
```

**返回线性表的长度**

```C++
template<class T>
int arrayList<T>::size()const
{
	return listSize;
}
```

**检查下标是否合法**

```c++
template<class T>
void arrayList<T>::checkIndex(int theIndex)const
{
	if (theIndex < 0 || theIndex >= listSize)
	{
		ostringstream s;
		s << "the Index = " << theIndex << " size = " << listSize;
		throw illegalIndex(s.str());
	}
}
```

**获取指定下标的元素（按位置查找）**

```C++
template<class T>
T& arrayList<T>::get(int theIndex)
{
    //先检查下标是否合法，若不合法直接抛出异常
	checkIndex(theIndex);
    //若合法则返回函数值（不合法的话走不到这一步）
	return element[theIndex];
}
```

**获取指定值的元素（的下标）（按值查找）**

```C++
template<class T>
int arrayList<T>::indexOf(const T& theElement) const
{
    //theIndex表示该元素在线性表的第几个位置，当theIndex==listSize，表明此时没有找到目标元素(find返回尾迭代器)
    //find函数返回指定值元素的迭代器（或指针），该迭代器类型与前两个参数类型相同，若没有找到目标元素，则返回尾迭代器
	int theIndex = (int)(find(element, element + listSize, theElement)-element);
	//find函数底层
	/*
	template<class InputIterator, class T>
	InputIterator find(InputIterator first, InputIterator last, const T & val)
	{
		while (first != last) {
			if (*first == val) return first;
			++first;
		}
		return last;
	}
	*/
	if (theIndex == listSize)
		return -1;//没有找到
	else
		return theIndex;
}
```

**删除指定位置元素**

```C++
template<class T>
void arrayList<T>::erase(int theIndex)
{
    //检查下标是否合法
	checkIndex(theIndex);
    //利用copy函数将删除元素右边所有元素左移一个单位
	copy(element + theIndex+1, element + listSize, element + theIndex);
    //删除尾部多余的元素
	element[--listSize].~T();
}
```

**插入指定位置元素**

```C++
template<class T>
void arrayList<T>::insert(int theIndex, const T& theElement)
{
    //这里没有用checkIndex是因为对下标要求不同了：checkIndex为了遍历元素，下标限制在[0,listSize-1]，而插入元素位置范围为[0,listSize],所以这里是theIndex>listSize而不是theIndex>=listSize
	if (theIndex < 0 || theIndex > listSize)
	{
		ostringstream s;
		s << "the Index = " << theIndex << " size = " << listSize;
		throw illegalIndex(s.str());
	}
	//检查线性表是否已经满了，若满了，要扩容
	if (listSize == arrayLength)
	{
		changeLength1D(element, arrayLength, 2 * arrayLength);
		arrayLength *= 2;
	}
	//第三个参数是目标序列的尾迭代器，复制过程：从复制序列的尾部开始依次从目标序列的尾部开始复制
	copy_backward(element + theIndex, element + listSize, element + listSize + 1);
    //copy_backward函数的底层实现
    //std::copy——backward(iterator source_first, iterator source_end, iterator target_end);
	element[theIndex] = theElement;
	listSize++;
}
```

###### 相关STL容器

可变长度数组vector容器

[vector 详解（C++）_黑马星云的博客-CSDN博客_vector c++](https://blog.csdn.net/qiancm/article/details/119611928)

##### 链表

用一组<u>任意的</u>存储单元存储数据元素

数据元素之间的逻辑关系用<u>指针</u>来表示（下标）

```C++
template<class T>
class linearList
{
	virtual bool empty()const;//查看表是否为空
	virtual int size()const;//获取表的长度
	virtual T& get(int theIndex);//取表中第i个数据元素
	virtual int indexOf(const T& theElement) const;//按值查找
	virtual int insert(int theIndex,const T& theElement);//在表中第i个位置插入新的数据元素e
	virtual int erase(int theIndex);//删除表中第i个数据元素
};
```

**具体操作（以单链表为例）**

**构造函数**

令头指针firtstNode初始化为NULL，元素数量listSize初始化为0，表示创建空链

```c++
template<class T>
chain<T>::chain(int Capacity)
{
	if (Capacity < 1)
	{
		ostringstream s;
		s << "Initial capacity = " << Capacity << " must be > 0";
		throw illegalParameterValue(s.str());
	}
	firstNode = NULL;
	listSize = 0;
}
```

**复制构造函数**

思路

1. 复制数据元素数量listSize，根据listSize分析要复制的链表是否为空链表

2. 若为空链表，只需要令头指针firstNode为NULL

3. 若不为空链表，则需要进行复制链表操作：

   1. 建立两个可移动的指针sourceNode和targetNode负责复制操作，其中sourceNode指向需要复制的目标链表的目标节点，targetNode指向新链表的最后一个节点

   2. 创建新链表，首先要创建头指针firstNode。令souceNode指向目标链第一个节点，创建头指针，创建后指向第二个节点。

      ```C++
      firstNode = new chainNode<T>(sourceNode->element);
      ```

   3. targetNode指向新链表最后一个节点，之后的复制节点为重复操作，利用循环实现。当souceNode==NULL，表明此时sourceNode已遍历目标链表，则结束复制操作

      ```C++
      while (sourceNode != NULL)
      	{
      		//实际是将一下两步合并为一步
      		//newNode=new chainNode<T>(sourceNode->element);
      		//targetNode->next=newNode;
      		targetNode->next = new chainNode<T>(sourceNode->element);
      		targetNode = targetNode->next;
      		sourceNode = sourceNode->next;
      	}
      ```

   4. 由于targetNode指向新链表最后一个节点，别忘了最后一个节点的指针域为空

```c++
template<class T>
chain<T>::chain(const chain<T>& theList)
{
	this->listSize = theList.listSize;
	//判断是否为空表
	//若是空表，只需令头指针为NULL
	if (listSize == 0)
	{
		firstNode = NULL;
		return;
	}
	//若不是空表，则需要进行复制链操作
	chainNode<T>* sourceNode = theList.firstNode;
	firstNode = new chainNode<T>(sourceNode->element);
	sourceNode = sourceNode->next;
	chainNode<T>* targetNode = firstNode;
	while (sourceNode != NULL)
	{
		//实际是将一下两步合并为一步
		//newNode=new chainNode<T>(sourceNode->element);
		//targetNode->next=newNode;
		targetNode->next = new chainNode<T>(sourceNode->element);
		targetNode = targetNode->next;
		sourceNode = sourceNode->next;
	}
	targetNode->next = NULL;
}
```

**析构函数**

思路

创建一个临时指针nextNode存储当前节点的下一个节点，利用firstNode指向当前要删除的节点，删除当前节点（delete 指向当前节点的指针），指向下一个节点(firstNode=nextNode)

```C++
template<class T>
chain<T>::~chain()
{
	while (firstNode != NULL)
	{
		chainNode<T>* nextNode = firstNode->next;
		delete firstNode;
		firstNode = nextNode;
	}
}
```

**按序号查找（通过下标获取元素）**

从头指针开始移动theIndex次得到下标为theIndex的元素

```c++
template<class T>
T& chain<T>::get(int theIndex)
{
	checkIndex(theIndex);
	chainNode<T>* currentNode=firstNode;
	for (int i = 0; i != theIndex; i++)
	{
		currentNode = currentNode->next;
	}
    
}
```

时间复杂度

当查找第一个元素，时间复杂度为O(1)

当查找最后一个元素，时间复杂度为O(n)

所以时间复杂度为O(n)

**按值查找（通过值获取元素下标）**

思路

从头指针开始寻找值为theElement的元素

```c++
template<class T>
int chain<T>::indexOf(const T& theElement) const
{
	chainNode<T>*currentNode = firstNode;
	int index;
	for (index = 0; currentNode != NULL && currentNode->element != theElement; index++)
	{
		currentNode = currentNode->next;
	}
	if (currentNode == NULL)
		return -1;
	else
		return index;
}
```

时间复杂度

平均时间复杂度为O(n)

算法执行之间与theElement类型有关（相关语句为currentNode->element!=theElement)，

常用数据类型为O(1)；如果是结构体，就不是O(1)；

**插入新节点**

思路

从头指针开始遍历，直至找到索引为theIndex-1的节点停下，此时该元素为插入位置的前一个节点

插入过程：

1. 存储theIndex位置节点p
2. 插入theIndex位置节点q（令theIndex-1索引节点的next指向新节点q，此时theIndex-1索引节点的next被覆写（原本指向theIndex位置的老节点p，现在指向theIndex位置的新插入节点q））
3. 令新theIndex位置节点的next指向旧theIndex位置节点p![image-20230130174211283](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230130174211283.png)

```C++
template<class T>
void chain<T>::insert(int theIndex, const T& theElement)
{
	if (theIndex<0 || theIndex>listSize)
	{
		ostringstream s;
		s << "the Index = " << theIndex << " size = " << listSize;
		throw illegalIndex(s.str());
	}
	else
	{
		if (theIndex == 0)
			firstNode = new chainNode<T>(theElement, firstNode);
		else
		{
			chainNode<T>* p = firstNode;
			for (int i = 0; i != theIndex - 1; i++)
			{
				p = p->next;
			}
			p->next = new chainNode<T>(theElement, p->next);
		}
		listSize++;
	}
}
```

时间复杂度：

![image-20230130174606281](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230130174606281.png)

**删除节点**

时间复杂度:O(n)

![image-20230130212256364](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230130212256364.png)

- 按序号删除

  ```C++
  template<class T>
  void chain<T>::erase(int theIndex)
  {
  	checkIndex(theIndex);
  	chainNode<T>* deleteNode;
  	if (theIndex == 0)
  	{
  		deleteNode = firstNode;
  		firstNode = firstNode->next;
  	}
  	else
  	{
  		chainNode<T>* p = firstNode;
  		for (int i = 0; i != theIndex - 1; i++)
  		{
  			p = p->next;
  		}
  		deleteNode = p->next;
  		p->next = p->next->next;
  	}
  	listSize--;
  	delete deleteNode;//时间复杂度O（1）
  }
  ```

- 按值删除

  ```C++
  template<class T>
  void chain<T>::erase(const T& theElement)
  {
  	chainNode<T>* deleteNode=firstNode;
  	while(deleteNode!=NULL&&deleteNode->element!=theElement)
      {
          deleteNode=deleteNode->next;
      }
      if(deleteNode!=NULL)
      {
          listSize--;
  		delete deleteNode;
      }	
  }
  ```

###### 单链表

特点

1. 每个节点有一个数据域(data)和一个指针域(next)
2. 最后一个节点的指针域必为NULL
3. 头指针firstNode指向第一个节点。当firstNode=NULL时，此时链表为空表

时间复杂度

![image-20230130214202892](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230130214202892.png)

即：定位、插入、删除、合并均为O(n)

###### 有序链表

![image-20230201152824739](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230201152824739.png)

![image-20230201152906324](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230201152906324.png)

思路

建立4个头指针，p1和p2分别指向要合并的两条目标链表的目标节点，firstNode指向新链表的头节点，targetNode指向当前链表的最后一个节点

```C++
//合并有序链表
template<class T>
chainNode<T>* chain<T>::merge(chain<T>& c)
{
    chainNode<T>* p1 = this->firstNode;
    chainNode<T>* p2 = c.firstNode;
    chainNode<T>* firstNode;
    if(p1->element<p2->element)
    {
        firstNode = new chainNode<T>(p1->element);
        p1 = p1->next;
    }
    else
    {
        firstNode = new chainNode<T>(p2->element);
        p2 = p2->next;
    }
    chainNode<T>* targetNode = firstNode;
    while (p1 != NULL && p2 != NULL)
    {
        if (p1->element < p2->element)
        {
            targetNode->next = new chainNode<T>(p1->element);
            p1 = p1->next;
        }
        else
        {
            targetNode->next = new chainNode<T>(p2->element);
            p2 = p2->next;
        }
        targetNode = targetNode->next;
    }
    if (p1 == NULL)
    {
        while (p2 != NULL)
        {
            targetNode->next = new chainNode<T>(p2->element);
            p2 = p2->next;
            targetNode = targetNode->next;
        }
    }
    else 
    {
        while (p1 != NULL)
        {
            targetNode->next = new chainNode<T>(p1->element);
            p1 = p1->next;
            targetNode = targetNode->next;
        }
    }
    //targetNode永远指向最后一个节点，所以最后要给targetNode补上尾节点的指针域NULL（由于chainNode构造函数不带有自动补充指针域为NULL)
    targetNode->next = NULL;
    chainNode<T>* currentNode = firstNode;
    while (currentNode != NULL)
    {
        cout << currentNode->element << " ";
        currentNode = currentNode->next;
    }
    return firstNode;
}
```

###### 循环链表

特点

1. 拥有一个没有值的头节点headerNode

2. 尾节点指向头节点（假设lastNode此时指向尾节点，则lastNode->next==headerNode)(对比：单链表中lastNode->next==NULL)

   从第一个节点（不是头节点headerNode，而是headerNode->next)开始遍历时，结束条件不再是currentNode==NULL,而是currentNode==headerNode

3. 空表headerNode==NULL，单节点循环链表headerNode->next==headerNode，多节点循环链表lastNode->next==headerNode

![image-20230201190548482](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230201190548482.png)

**基本操作**

插入和删除操作与单链表相同

按值查找

```C++
template<class T>
int circularListWithHeader<T>::indexOf(const T& theElement)const
{
    //重点：把要查找的值放入头节点中
    headerNode->element=theElement;
    //currentNode指向第0个节点，即headerNode->next
    chainNode<T>* currentNode=headerNode->next;
    int index=0;
    //与单链表不同，可以将该条件作为循环终止条件，因为头节点中有要查找的值，如果别的节点没有要查找的值，也能在头节点结束循环
    while(currentNode->element!=theElement)
    {
        currentNode=currentNode->next;
        index++;
    }
    //检查currentNode是否回到headerNode,即是否查找到了值为theElement的元素
    if(currentNode==headerNode)
        return -1;
    else
        return index;
}
```

###### 双向链表

![image-20230201213201992](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230201213201992.png)

空表：

```C++
firstNode->prev==firstNode
```

```
firstNode->next==firstNode
```



![image-20230201213236505](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230201213236505.png)

**基本操作**

插入和删除与单链表思路相似，只是多了处理prev的步骤，与处理next相反即可

![image-20230201213710898](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230201213710898.png)

![image-20230201213811217](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230201213811217.png)

###### 相关STL容器

双向链表list

[(10条消息) STL--list容器(链表)_CE贝多芬的博客-CSDN博客](https://blog.csdn.net/hjl011006/article/details/125772142)

###### 相关问题

**1.约瑟夫问题**

N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3。

```C++
#include<iostream>
using namespace std;

struct Node
{
	int element;
	Node* next;
	Node(){}
	Node(int e):element(e){}
	Node(int e,Node* n):element(e),next(n){}
};

class circularChain
{
public:
	circularChain() { listSize = 0; }
	circularChain(int n);
	~circularChain();

​	int Josephus(int m);
​	void output();
protected:
​	int listSize;
​	Node* headerNode;
};

circularChain::circularChain(int n)
{
	headerNode = new Node(1);
	if (n > 1)
	{
		Node* currentNode = headerNode;
		for (int i = 2; i <= n; i++)
		{
			currentNode->next = new Node(i);
			currentNode = currentNode->next;
		}
		currentNode->next = headerNode;
	}
	
	listSize = n;
}

int circularChain::Josephus(int m)
{
	while (headerNode->next != headerNode)
	{	
		Node* curNode = headerNode;
		for (int i = 1; i <m-1; i++)
		{
			curNode = curNode->next;
		}
		//删除报数者
		Node* deleteNode = curNode->next;
		curNode->next = curNode->next->next;
		headerNode = curNode->next;
		cout << "delete " << deleteNode->element <<endl;
		delete deleteNode;
		listSize--;
	}
	return headerNode->element;
}

void circularChain::output()
{
	Node* curNode = headerNode;
	do
	{
		cout << curNode->element << " ";
		curNode = curNode->next;
	} while (curNode != headerNode);
	cout <<endl<< "listSize=" << listSize << endl;
}

circularChain::~circularChain()
{
	Node* deleteNode;
	for (int i = 1; i <= listSize; i++)
	{
		deleteNode = headerNode;
		headerNode = headerNode->next;
		delete deleteNode;
	}
}
int main()
{
	//n为人数，m为枪杀的第几个人
	int n, m;
	circularChain c(n);
	c.output();
	cout<<"survive: "<<c.Josephus(m) << endl;
	c.output();
}
```



### 栈

#### 逻辑结构

特殊的线性表（只能在表尾进行插入和删除操作）

后进先出（Last In,Fast Out，即LIFO)

#### 抽象数据类型定义

```c++
template<class T>
class stack
{
public:
    virtual ~stack() {}
    virtual bool empty()const = 0;//返回true，当且仅当栈顶为空
    virtual int size()const = 0;//返回栈中元素个数
    virtual T& top() = 0;//返回栈顶元素
    virtual void pop() = 0;//将栈顶元素弹出
    virtual void push(const T& theELment) = 0;//将目标元素压入栈顶
};
```

#### 存储结构

##### 顺序栈与链栈的比较

![image-20230202164533001](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230202164533001.png)

##### 顺序栈

通常以顺序表的表尾作为栈顶，表头作为栈底，利用索引变量topIndex指向栈顶

```C++
#include"stack.h"

const int MAX_SIZE = 100;

template<class T>
class seqstack:public stack<T>
{
public:
    ~seqstack() {}
    //返回true，当且仅当栈顶为空
    bool empty()const { return topIndex == -1; }
    int size()const { return topIndex + 1; }//返回栈中元素个数
    T& top();//返回栈顶元素
    void pop();//将栈顶元素弹出
    void push(const T& theELment);//将目标元素压入栈顶
protected:
    T array[MAX_SIZE];
    int topIndex;
};
```

入栈

```C++
template<class T>
void seqstack<T>::push(const T& theELement)
{
    if (topIndex == MAX_SIZE - 1)
        throw "溢出";
    topIndex++;
    array[topIndex] = theElement;
}
```

出栈

```C++
template<class T>
void seqstack<T>::pop()
{
    if (topIndex == -1)
        throw "栈空";
    array[topIndex--].~T();
}
```

返回栈顶元素

```C++
template<class T>
T& seqstack<T>::top()
{
    if (topIndex == -1)
        throw "栈空";
    return array[topIndex];
}
```

![image-20230202120130505](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230202120130505.png)

**Top(a)从左向右移动，Top(b)从右向左移动**

![image-20230202120215522](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230202120215522.png)

![image-20230202120232765](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230202120232765.png)

##### 链栈

以链表头作为栈顶，链表尾作为栈底，在链表头进行入栈出栈等操作，利用头指针topNode指向栈顶

```C++
#include"Node.h"
#include"stack.h"
template<class T>
class Linkstack :public stack<T>
{
public:
    Linkstack() { topNode = NULL; }
    ~Linkstack() {}
    bool empty()const { return topNode == NULL; }//返回true，当且仅当栈顶为空
    int size()const;//返回栈中元素个数
    T& top();//返回栈顶元素
    void pop();//将栈顶元素弹出
    void push(const T& theELement);//将目标元素压入栈顶
protected:
    Node<T>* topNode;
};
```

元素个数

```C++
template<class T>
int Linkstack<T>::size()const
{
    int index=0;
    for (Node<T>* curNode = topNode; curNode != NULL; curNode = curNode->next)
    {
        index++;
    }
    return index;
}
```

入栈

```C++
template<class T>
void Linkstack<T>::push(const T& theElement)
{
    topNode = new Node<T>(theElement, topNode);
}
```

出栈

```C++
template<class T>
void Linkstack<T>::pop()
{
    if (topNode == NULL)
        throw"下溢";
    Node<T>* deleteNode = topNode;
    topNode = topNode->next;
    delete deleteNode;
}
```

返回栈顶元素

```C++
template<class T>
T& Linkstack<T>::top()
{
    if (topNode==NULL)
        throw "栈空";
    return topNode->element;
}
```

#### 相关STL容器

[C++ stack（STL stack）容器适配器用法详解 (biancheng.net)](http://c.biancheng.net/view/6971.html#:~:text=C%2B%2B stack（STL stack）容器适配器用法详解 < 上一节 下一节 >,stack 栈适配器是一种单端开口的容器（如图 1 所示），实际上该容器模拟的就是栈存储结构，即无论是向里存数据还是从中取数据，都只能从这一个开口实现操作。 图 1 stack 适配器示意图)

#### 相关问题

**1.有三个元素按A、B、C的次序依次进栈，且每个元素只允许进一次栈，哪种出栈序列不可能实现？**

[假设有a,b,c三个元素,入栈顺序是a,b,c,那么出栈顺序有哪些可能,写出分析过程？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/386094283/answer/1137287430?ivk_sa=1024320u)

**2.汉诺塔问题**

汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？（每次只能移动1个盘子，大盘子只能放在小盘子下面）

<!--本题中，要求最后移动到柱子z，柱子y作为过渡柱-->

​	1.递归解法

**思路**

​	假设有n个盘子需要移动，

​	n=1时，我们只需将柱子x上的盘子移动到柱子z

​	n=2时，我们首先需要将柱子x上最上面的盘子1移动到柱子y，再将盘子2移动到柱子z，	最后将盘子1从柱子y移动柱子z

​	我们发现：n=1和n=2时是比较简单的子问题，而子问题2为我们解决n比较大时提供思

​	路：假设最底下的盘子是第n个，则我们将n-1个盘子当作n=2时的盘子1，则找到了n与	

​	n-1的递归关系

​	于是我们将问题分解为：

​	当n=1时，我们将柱子x上的盘子移动到柱子y（解决问题的核心）

​	当n>=2时，

​	我们将n-1个盘子移动到柱子y

```c++
TowerOfHanoi_recursion(n - 1, x, z, y);
```

​		将柱子x上的盘子（最底下的第n个盘子移动到柱子y）

```C++
cout << "Move top disk from tower " << x << " to top of tower " << y << endl;
```

​		将n-1个盘子移动到柱子z

```C++
TowerOfHanoi_recursion(n - 1, z, y, x);
```

​	**总代码**

​	该函数的核心是将柱子x上的最底下的盘子移动到柱子y(n=1时步骤1和3都失效，只有步	骤2，即该步骤成立)

```C++
//递归写法
void TowerOfHanoi_recursion(int n,int x, int y, int z)
{
	if (n >0)
	{
        //Step1
		TowerOfHanoi_recursion(n - 1, x, z, y);
        //Step2
		cout << "Move top disk from tower " << x << " to top of tower " << y << endl;
        //Step3
		TowerOfHanoi_recursion(n - 1, z, y, x);
	}
}
```

时间复杂度

移动次数为$2^n-1$，O($2^n$)



**2.用栈解决**

![image-20230207094413451](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207094413451.png)

递归过程：

![image-20230207095113205](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207095113205.png)

递归改为非递归：

![image-20230207094820197](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207094820197.png)

尾递归：将递归调用运算过程改写成只调用不运算（例如fib(n-1)+fib(n-2)改为go(n,a,b)，a+b表示fib(n-1)+fib(n-2))

![image-20230207094840178](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207094840178.png)

![image-20230207095031353](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207095031353.png)

**思路**

每个柱子以栈的方式存储int类型元素，每个元素视作一个盘子，建立一个vector数组存储这三个柱子

（关键）用栈模拟函数的递归过程：

以递归解法为例

```C++
void TowerOfHanoi_recursion(int n,int x, int y, int z)
{
	if (n >0)
	{
		TowerOfHanoi_recursion(n - 1, x, z, y);
		cout << "Move top disk from tower " << x << " to top of tower " << z << endl;
		TowerOfHanoi_recursion(n - 1, y, x, z);
	}
}
```

**递归过程：**

​	（递归）函数栈三大特点

1. 调用函数时，将调用函数的返回地址、形参和局部变量压入函数调用栈中
2. 调用函数后，原调用函数停止，进入被调用函数体内
3. 直至到达停止递归的条件，按照函数调用栈存储的返回参数进行回溯，直至回到最初的调用函数



**以下为递归解法中的调用过程：**

1. 调用main函数里的函数TowerOfHanoi_recursion(n,0,1,2)，在函数调用栈中压入返回地址和参数(n,\*,\*,\*)等信息（此时未将形参赋值）
2. 进入函数体内，进行形参复制(x=0,y=1,z=2），判断n>0后，调用函数TowerOfHanoi_recursion(n - 1, 0, 2, 1)，此时原调用函数停止，进入新调用函数TowerOfHanoi_recursion(n - 1, 0, 2, 1)，同时将返回信息压入栈内。
3. 重复步骤2，直至到达递归终止条件n==0，无调用函数，调用结束，开始回溯——将函数调用栈内返回信息弹出栈，按照返回信息返回。直至栈内TowerOfHanoi_recursion(a, 0, 2, 1)的返回信息均弹出(a表示取0到n的数)，此时表示语句TowerOfHanoi_recursion(n - 1, x, z, y)执行结束。最后弹出栈内的返回信息为TowerOfHanoi_recursion(n,0,1,2)，即返回至函数TowerOfHanoi_recursion(n,0,1,2)内继续往下执行。
4. 打印语句cout << "Move top disk from tower " << x << " to top of tower " << z << endl
5. 调用函数TowerOfHanoi_recursion(n - 1, 1, 0, 2)，进行类似于步骤2和3的递归操作
6. 执行函数TowerOfHanoi_recursion(n - 1, 1, 0, 2)完成，回到调用函数TowerOfHanoi_recursion(n,0,1,2)，往下是}，表示目前函数执行完成，返回信息TowerOfHanoi_recursion(n,\*,\*,\*)出栈回溯，回到 main函数，表示语句TowerOfHanoi_recursion(n,0,1,2)执行完成



​		那么我们可以用栈来模拟函数的调用过程（不需要包含回溯）：

​		建立一个类或结构体存储每个状态的函数执行参数，一个栈用于存储每个状态

**栈模拟函数的调用过程：**

1. 首先将初始状态的函数参数压入栈内（n,0,1,2)

   获取栈顶元素current并弹出（表示调用该函数）。

2. 进入函数体内，执行函数：

   如果current->n大于1，将(n-1,y,x,z),(1,x,y,z),(n-1,x,z,y)依次压入栈内**（注意次序！压栈顺序与调用顺序相反！）**。

   如果current->n等于1，将柱子x的唯一盘子移到柱子z

3. 获取栈顶元素current并弹出（表示调用该函数）

4. 重复步骤2和3，直至函数调用栈为空（只要栈不为空，则仍能调用，因此栈空表示调用结束）

（作为参考）递归步骤如下：

```C++
TowerOfHanoi_recursion(n - 1, x, z, y);
cout << "Move top disk from tower " << x << " to top of tower " << z << endl;
TowerOfHanoi_recursion(n - 1, y, x, z);
```

**栈模拟调用过程代码**

```C++
	status.push(new record(n, 0, 1, 2));
	while (!status.empty())
	{
		record* current = status.top();
		status.pop();
		if (current->n == 1)
		{
			int temp = stacks[current->start]->top();
			stacks[current->end]->push(temp);
			stacks[current->start]->pop();
			cout << "Move top disk from tower " << current->start << " to top of tower " << current->end << endl;
		}
		else
		{
			status.push(new record(current->n-1, current->via, current->start, current->end));	
			status.push(new record(1, current->start, current->via, current->end));
			status.push(new record(current->n - 1, current->start, current->end, current->via));
		}
	}
```

**总代码**

```C++
void TowerOfHanoi_stack(const int n)
{
	vector<stack<int>*> stacks;
	for (int i = 0; i != 3; i++)
		stacks.push_back(new stack<int>);
	stack<record*> status;
	for (int i = n; i >=1; i--)
	{
		stacks[0]->push(i);
	}
	status.push(new record(n, 0, 1, 2));
	while (!status.empty())
	{
		record* current = status.top();
		status.pop();
		if (current->n == 1)
		{
			int temp = stacks[current->start]->top();
			stacks[current->end]->push(temp);
			stacks[current->start]->pop();
			cout << "Move top disk from tower " << current->start << " to top of tower " << current->end << endl;
		}
		else
		{
			status.push(new record(current->n-1, current->via, current->start, current->end));	
			status.push(new record(1, current->start, current->via, current->end));
			status.push(new record(current->n - 1, current->start, current->end, current->via));
		}
	}
}
```



**3.数制转换**

![image-20230204143602539](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230204143602539.png)

### 队列

#### 逻辑结构

限定表头进行插入，表尾进行删除操作的线性表

先进先出(FIFO)

#### 抽象数据类型

```C++
template<class T>
class deque
{
public:
	virtual ~deque(){}
	virtual bool empty()const = 0;//返回true，当且仅当队列为空
	virtual int size()const = 0;//返回队列中元素个数
	virtual T& front() = 0;//返回首元素的引用
	virtual T& back() = 0;//返回尾元素的引用
	virtual void push(const T& theELement)=0;//把元素theElement插入队尾
	virtual void pop()=0;//删除头元素
};
```

#### 存储结构

##### 顺序存储结构和链式存储结构的比较

![image-20230205213944929](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230205213944929.png)

##### 顺序存储结构

为了避免”假溢出“和"front==back"无法判断队列满还是队列空的问题，我们采用循环队列的存储结构

![image-20230204144910921](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230204144910921.png)

**以方法1为例：**

```C++
#include"queue.h"
#include"myExceptions.h"
#include<sstream>
#include<iostream>
using namespace std;

template<class T>
class arrayCircularQueue:public queue<T>
{
public:
	arrayCircularQueue(int Capacity=10);
	~arrayCircularQueue();
	bool empty()const { return theFront == theBack; }//返回true，当且仅当队列为空
	int size()const;//返回队列中元素个数
	T& front();//返回首元素的引用
	T& back();//返回尾元素的引用
	void push(const T& theELement);//把元素theElement插入队尾
	void pop();//删除头元素
protected:
	int theFront;
	int theBack;
	int arrayLength;
	T* queue;
};
```

**构造函数**

<u>注意初始化时，让theFront=theBack=0</u>，即表示队列为空，同时都指向队列的第一个位置

当插入元素时再让theBack移动，使theFront始终指向第一个位置，且保持第一个位置为空，从而实现方法一

```C++
template<class T>
arrayCircularQueue<T>::arrayCircularQueue(int Capacity)
{
	if (Capacity < 1)
	{
		ostringstream s;
		s << "Initial capacity = " << Capacity << "Must be > 0";
		throw illegalParameterValue(s.str());
	}
	arrayLength = Capacity;
	queue = new T[arrayLength];
	theFront = theBack = 0;
}
```

**析构函数**

```C++
template<class T>
arrayCircularQueue<T>::~arrayCircularQueue()
{
	delete[]queue;
}
```

**元素个数**

theBack>theFront时，

theBack-theFront即为元素个数

theBack<theFront时，

我们采用移位的方式，把theBack及之前的元素调整到theFront后面，重新变成theBack>theFront的处理方法，此时theBack的下标为theBack+arrayLength,按照theBack>theFront的计算，元素个数为theBack-theFront+arrayLength

我们想要统一计算格式，而我们发现（theBack>theFront时）theBack-theFront等价于（theBack-theFront+arrayLength）%arrayLength，

![image-20230204211511692](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230204211511692.png)

```C++
template<class T>
int arrayCircularQueue<T>::size()const
{
	return (theBack - theFront + arrayLength) % arrayLength;
	/*if (theFront == theBack)
		return 0;
	return abs(theBack - (theFront + 1) % arrayLength)+1;*/
}
```

**返回队列首元素**

```C++
template<class T>
T& arrayCircularQueue<T>::front()
{
	if (theFront == theBack)
		throw queueEmpty();
	int index = (theFront + 1) % arrayLength;
	return queue[index];
}
```

**返回队列尾元素**

```C++
template<class T>
T& arrayCircularQueue<T>::back()
{
	if (theFront == theBack)
		throw queueEmpty();
	return queue[theBack];
}
```

**入队**

```C++
template<class T>
void arrayCircularQueue<T>::push(const T& theElement)
{
	if ((theBack + 1) % arrayLength == theFront)//判断是否队列满
	{
		T* newqueue = new T[arrayLength * 2];
		int start = (theFront + 1) % arrayLength;
		if (start < 2)
			copy(queue + start, queue + start+arrayLength - 1, newqueue);
		else
		{
			copy(queue + start, queue + arrayLength, newqueue);
			copy(queue, queue + theBack + 1, newqueue + arrayLength - start);
		}
		theFront = arrayLength * 2 - 1;
		theBack = arrayLength - 2;
		arrayLength = arrayLength * 2;
		queue = newqueue;
	}
	theBack = (theBack + 1) % arrayLength;
	queue[theBack] = theElement;
}
```

**出队**

```C++
template<class T>
void arrayCircularQueue<T>::pop()
{
	if (theFront == theBack)
		throw queueEmpty();
	theFront = (theFront + 1) % arrayLength;
	queue[theFront].~T();
}
```

##### 链式存储结构

以单链表为链式存储结构的队列，有两种存储方法：有头节点和无头节点

<u>从根本上说，有无节点的区别在于queueFront指向的节点不同</u>

**无头节点**

队列为空时，queueBack=queueFront=NULL

队列不为空时，queueFront指向第一个有效节点，queueBack指向最后一个有效节点

```C++
//不带头节点的链队列
template<class T>
class LinkedQueue_noHeaderNode:public queue<T>
{
public:
	LinkedQueue_noHeaderNode(int Capacity = 10)
	{
		queueFront =queueBack= NULL;
		queueSize = 0;
	}
	~LinkedQueue_noHeaderNode();
	bool empty()const//返回true，当且仅当队列为空
	{
		return queueSize==0;
	}
	int size()const//返回队列中元素个数
	{
		return queueSize;
	}
	T& front();//返回首元素的引用
	T& back();//返回尾元素的引用
	void push(const T& theELement);//把元素theElement插入队尾
	void pop();//删除头元素
protected:
	chainNode<T>* queueFront;
	chainNode<T>* queueBack;
	int queueSize;
};
```

**有头节点**

队列为空时，queueBack=queueFront≠NULL,queueBack和queueFront共同指向一个空节点，该空节点为头节点

队列不为空时，queueFront指向头节点，queueBack指向最后一个有效节点

**判断队列为空时，无论有无节点链队列均满足queueBack=queueFront，只是无节点要求queueBack和queueFront均指向空，有节点要求均指向头节点，因此在此方面，节点的有无判断队列为空的条件也有细微差别。但我们有另外且简单统一的判断队列为空的条件：queueSize==0**

```C++
//带头节点的链队列
template<class T>
class LinkedQueue_withHeaderNode :public queue<T>
{
public:
	LinkedQueue_withHeaderNode(int Capacity = 10)
	{
		queueBack=queueFront = new chainNode<T>;
		queueSize = 0;
	}
	~LinkedQueue_withHeaderNode();
	bool empty()const//返回true，当且仅当队列为空
	{
		return queueSize == 0;
	}
	int size()const//返回队列中元素个数
	{
		return queueSize;
	}
	T& front();//返回首元素的引用
	T& back();//返回尾元素的引用
	void push(const T& theELement);//把元素theElement插入队尾
	void pop();//删除头元素
protected:
	chainNode<T>* queueFront;
	chainNode<T>* queueBack;
	int queueSize;
};
```

**基本操作**

**构造函数**

无论有无头节点，初始化时空链队列均满足queueFront==queueBack

**无头节点：**

由于没有头节点，queueFront和queueBack均指向空

```C++
	LinkedQueue_noHeaderNode(int Capacity = 10)
	{
		queueFront =queueBack= NULL;
		queueSize = 0;
	}
```

**有头节点：**

有头节点，queueFront和queueBack均指向头节点

```C++
	LinkedQueue_withHeaderNode(int Capacity = 10)
	{
		queueBack=queueFront = new chainNode<T>;
		queueSize = 0;
	}
```

**析构函数**

无头节点和有头节点的析构函数一样，都要从队列最前面的节点开始删除节点，而有头节点的链队列要删除多余的头节点，但操作是一样的

```C++
template<class T>
LinkedQueue_withHeaderNode<T>::~LinkedQueue_withHeaderNode()
{
	while (queueFront != NULL) 
	{
		chainNode<T>* deleteNode = queueFront;
		queueFront = queueFront->next;
		delete deleteNode;
	}
}
```

**返回队列首元素**

有无头节点的区别在于queueFront指向的节点不同（<u>队列不为空时，无头节点queueFront指向第一个有效元素，有头节点queueFront指向头节点，第一个有效元素为queueFront->next</u>)，因此该方法的实现方式不同

**无头节点**

```C++
T& LinkedQueue_noHeaderNode<T>::front()
{
	if (queueSize==0)
		throw queueEmpty();
	return queueFront->element;
}
```

**有头节点**

```C++
template<class T>
T& LinkedQueue_withHeaderNode<T>::front()
{
	if (queueSize == 0)
		throw queueEmpty();
	return queueFront->next->element;
}
```

**返回队列尾元素**

无论有无头节点，queueBack都指向最后一个有效元素，因此该方法实现方式相同

**有/无节点**

```C++
template<class T>
T& LinkedQueue_noHeaderNode<T>::back()
{
	if (queueSize == 0)
		throw queueEmpty();
	return queueBack->element;
}
```

**入队**

入队能够很明显体现有无头节点的区别：

- **无头节点**插入元素时需要判断队列是否为空，根据队列是否为空做出相应不一样的操作

  **队列为空**，则queueBack指向空，不能用语句

  ```C++
  queueBack->next=newNode;
  ```

  并且要让queueFront和queueBack都指向newNode

  **队列不为空**，则直接

  ```C++
  queueBack->next=newNode;
  ```

  再让queueBack指向newNode即可

- **有头节点**插入元素时不需要判断队列是否为空，统一执行语句

  ```C++
  queueBack->next = newNode;
  queueBack = newNode;
  ```

**无头节点**

```C++
template<class T>
void LinkedQueue_noHeaderNode<T>::push(const T& theElement)
{
	chainNode<T>* newNode = new chainNode<T>(theElement, NULL);	
	if (queueSize == 0)//链队列为空
		queueFront = newNode;
	else // 链队列不为空
		queueBack->next = newNode;
	queueBack = newNode;
	queueSize++;
		
}
```

**有头节点**

```C++
template<class T>
void LinkedQueue_withHeaderNode<T>::push(const T& theElement)
{
	chainNode<T>* newNode = new chainNode<T>(theElement, NULL);
	queueBack->next = newNode;
	queueBack = newNode;
	queueSize++;
}
```

**出队**

让首元素出队，有无头节点区别在于queueFront与首元素的关系，该区别导致了<u>出队时删除元素的位置</u>以及<u>需要移动的指针或节点是哪个</u>

**无头节点：**queueFront指向首元素，直接delete queueFront

​					queueFront始终指向第一个有效元素，因此queueFront直接往后移动一个

```
queueFront=queueFront->next;
```

**有头节点：**queueFront->next指向首元素，delete queueFront->next

​					同时queueFront始终指向头节点，因此第一个有效元素需要更换移动

```
queueFront->next=queueFront->next->next;
```

**无头节点**

```C++
template<class T>
void LinkedQueue_noHeaderNode<T>::pop()
{
	if (queueSize == 0)
		throw queueEmpty();
	chainNode<T>* deleteNode = queueFront;
	queueFront = queueFront->next;
	delete deleteNode;
	queueSize--;
}
```

**有头节点**

```C++
template<class T>
void LinkedQueue_withHeaderNode<T>::pop()
{
	if (queueSize == 0)
		throw queueEmpty();
	chainNode<T>* deleteNode = queueFront->next;
	queueFront->next = queueFront->next->next;
	delete deleteNode;
	queueSize--;
}
```

##### 相关STL容器

queue容器（单向队列）

[(10条消息) C++ queue容器详解_＆不逝的博客-CSDN博客_c++队列容器](https://blog.csdn.net/qq_52324409/article/details/121043685)

deque容器（双向队列）

[C++ STL deque容器（详解版） (biancheng.net)](http://c.biancheng.net/view/6860.html)

##### 相关问题

**1.利用队列计算杨辉三角**

假设已知第i行数据，求第i+1行数据

解法：

我们把杨辉三角的每行两端加上0形成新杨辉三角，将新杨辉三角的第i行称为第i行数据

1.把第i行数据后加入队列

2.要计算第i+1行数据，则执行以下操作：

1. 取出队列的第一个数temp(包含front()和pop()操作)
2. 将取出第一个数temp后队列的第一个数与temp相加得到第i+1行的相应元素temp'
3. 将temp'加入队列中

我们假设010为第一行，0110为第2行，第i行有i+2个数，只需执行以上操作至第i行数据只剩下最后的0（0后无第i行数据了，无法取front())，故只需执行i+2-1==i+1次操作，恰好等于我们要计算的第i+1行的行数

所以该操作执行次数为i+1（要计算的第i+1行的行数）

3.步骤2执行完后，给队列加入数据0，形成完整的第i+1行数据，方便进行下一次计算



计算整个杨辉三角

将解法中的i换成1即可

```C++
#include<iostream>
#include<queue>
#define N 10
using namespace std;

int main()
{
	queue<int> q;
	q.push(0);
	q.push(1);
	q.push(0);
	cout << "line" <<1 << ":1"<<endl;
    //要计算的行数为第i行。从第2行开始计算
	for (int i = 2; i <=N; i++)
	{
		cout << "line" << i << ":";
        //执行次数为第i行的行数i
		for(int j=1;j<=i;j++)
		{
			int temp = q.front();
			q.pop();
			temp += q.front();
			cout << temp << " ";
			q.push(temp);
		}
        //补充数字0，形成完整的第i行数据
		q.push(0);
		cout << endl;
	}
}
```

### 字符串

#### 逻辑结构

特殊的线性表（数据元素均为字符的线性表）

字符串相等：长度相同，每个字符相同

空串与空白串不同：空串没有字符，空白串的字符为空格（""为空串，" "为空白串)

#### 抽象数据类型

![image-20230207100342144](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207100342144.png)

#### 存储结构

![image-20230207100453239](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207100453239.png)

##### 顺序存储结构

![image-20230207100645507](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207100645507.png)

![image-20230207101046157](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207101046157.png)

![image-20230207102150662](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207102150662.png)

![image-20230207102302927](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207102302927.png)

##### 链式存储结构

![image-20230207102339677](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207102339677.png)

![image-20230207102523919](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207102523919.png)

##### 相关STL容器

string（可变长度的定长字符串）

注意string获取字串的函数substr()用法

[(10条消息) C++string类中substr()函数的使用方法_&Mr.Gong的博客-CSDN博客_c++ string substr](https://blog.csdn.net/weixin_42258743/article/details/107782394)

##### 相关问题

![image-20230207103024383](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207103024383.png)

![image-20230207103036781](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207103036781.png)

**回溯法（低效）**

思路

将模式串与目标串逐个字符比较，如果出现不相同，则回溯到模式串的首个字符，模式串向后移动一位



### 哈希表

![image-20230207105657551](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207105657551.png)

![image-20230207105715812](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207105715812.png)

#### 逻辑结构

![image-20230207105828478](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207105828478.png)

![image-20230207110034703](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207110034703.png)

![image-20230207110756841](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207110756841.png)

![image-20230207110813153](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207110813153.png)

![image-20230207110921843](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207110921843.png)

![image-20230207111000870](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207111000870.png)

![image-20230207111018668](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207111018668.png)

##### 基于顺序表的哈希

![image-20230207111148045](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207111148045.png)

#### 碰撞处理

![image-20230207111552550](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207111552550.png)

##### 拉链法

![image-20230207111753593](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207111753593.png)

![image-20230207112914180](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207112914180.png)

![image-20230207112929087](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207112929087.png)

![image-20230207112947722](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207112947722.png)

![image-20230207112716998](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207112716998.png)

##### 开放定址法

###### 线性探测

![image-20230207113127654](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207113127654.png)

![image-20230207113104851](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207113104851.png)

![image-20230207113215429](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207113215429.png)

注意：线性探测中删除之后需要标记被删位置，如果直接删除，会造成空位置提前，导致后面元素信息丢失（因为线性探测是探测到空位置结束）

![image-20230207204100661](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207204100661.png)

###### 平方探测

![image-20230207204511110](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207204511110.png)

![image-20230207204737769](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207204737769.png)

###### 伪随机探测

![image-20230207205217120](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207205217120.png)

###### 双重哈希

![image-20230207205147046](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207205147046.png)

###### （重要）杜鹃哈希

如果要插入的位置有元素，把已有元素e赶出来，直接插入该位置，再计算已有元素e的哈希索引。重复以上插入操作直至插入完成。

![image-20230207205653943](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207205653943.png)

#### 哈希表满时的处理

![image-20230207205307510](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230207205307510.png)

### 跳表

跳表的查找：

1.从头指针最顶层开始

2.查找是否有右节点：

​		如果有，将key与右节点数据data进行比较：

​			如果key>data，则指针移动到右节点

​			如果key<data，则指针往当前节点的下一级移动

​		如果无，则指针往当前节点的下一级移动

3.重复Step2直到找到目标节点



以下图为例：

Step1：从头指针最高层开始，查找是否有右节点，发现有右节点8

Step2：将右节点data（8）与key（55）比较，发现key>data，则移动到右节点(8)

Step3：重复Step2，当前处于节点(8)，发现没有右节点，则指针往下一级移动。位于节点（8）的第二级，有右节点，判断为key>data(34)，则移动指针至节点（34）。节点（34）没有右节点，往下一级移动。位于节点（34）的第二级，有右节点（89），判断为key<data(89)，则往下一级移动。位于节点（34）的第三级，有右节点，判断为key==data(55)，移动到右节点，停止循环。

![image-20230306162830429](数据结构结课总结.assets/image-20230306162830429.png)

![image-20230208151149891](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208151149891.png)

## 排序

### 算法的稳定性

![](数据结构结课总结.assets/image-20230310203852422.png)

#### 稳定的算法

- 直接插入排序、折半插入排序
- 冒泡排序
- 归并排序

#### 不稳定的算法

- 希尔排序
- 快速排序
- 堆排序

### 算法时间复杂度

- 直接插入排序：

  - 一般情况：O($n^2$)
  - 最好情况：O($n-1$)
  - 最差情况：O($n^2$)

- 折半插入排序

  - 一般情况：O($nlog_2n$)

- 希尔排序

  - - ![image-20230310212559067](数据结构结课总结.assets/image-20230310212559067.png)

- 冒泡排序

  - 一般情况：O($n^2$)

- 快速排序

  - 最差情况：O($n^2$)
    - 最差情况为：初始序列为升序

  - 一般情况：O($nlog_2n$)

- 归并排序：

  - 二路归并的时间复杂度：O($n$)
  - 一般情况：O($nlog_2n$)

- 堆排序：

  - 最坏情况：O($nlog_2n$)

  


### 插入排序

插入排序分为有序区和无序区，有序区的“有序”不代表全局的有序，即有序区的最大最小值未必是排序后的最大最小值

通过不断从无序区与有序区的元素比较插入有序区中的合适的位置，从而实现将无序区缩小为有序区

#### 直接插入排序

<u>适用于较少元素的插入</u>

记共有n个元素，第一个元素为a[0]，则从第二个元素a[1]开始执行插入排序，直至遍历到a[n-1]停止插入排序

具体插入排序操作：

设当前需要执行插入排序的元素为a[k]，将其值记作key，则已排序序列中的最后一个元素为a[i]，其中i=k-1，将a[i]与key比较，如果key<a[i]，则i减1（即key从有序序列最后一个元素开始逐次比较，直到遇到key>a[i]为止）。比较结束后，i指向插入位置的前一位，将有序序列索引为[i+1,k-1]的元素向右移，再将key插入索引为i的位置

![image-20230310205740363](数据结构结课总结.assets/image-20230310205740363.png)

![image-20230310205822838](数据结构结课总结.assets/image-20230310205822838.png)

![image-20230310205911857](数据结构结课总结.assets/image-20230310205911857.png)

#### 折半插入排序（二分法排序）

在直接插入排序基础上，把逐个查找改为二分查找

二分查找比较次数为对应二分查找树的高度

![image-20230310211006288](数据结构结课总结.assets/image-20230310211006288.png)

#### 希尔排序

初始时，gap取$\lceil n/2\rceil$

![image-20230310212718511](数据结构结课总结.assets/image-20230310212718511.png)

### 交换排序

![image-20230310212957838](数据结构结课总结.assets/image-20230310212957838.png)

#### 冒泡排序

分为有序区和无序区，与插入排序不同，有序区的“有序”即为全局的有序，即目前有序区第i个元素就是排序后的第i个最小的元素

<u>经过k次冒泡可以得到k个最小（最大）元素</u>

<u>设有n个元素，经过n-1次冒泡排序结束</u>（得到第n-1个最小（最大）元素后，剩下的元素自然就是第n个最小（最大）元素）

冒泡排序有两种方法

1. 从后向前（上浮）

i从n-1开始向前遍历直到1为止（每次减1）

从第i个元素和第i-1个元素开始比较，如果反序则交换（这里的序指的是从小到大，即升序，反序则为降序）

第i次冒泡是第i小的元素上浮到第i个位置

![image-20230310213437341](数据结构结课总结.assets/image-20230310213437341.png)

注意：以下最好情况分析是优化后的冒泡排序（即遍历到第i次后，如果没有发生交换，则排序结束）

![image-20230310214401380](数据结构结课总结.assets/image-20230310214401380.png)

#### 快速排序

快速排序分为划分和递归两部分

##### 划分

###### 异侧

（i初始值为low+1，j初始值为high)

![image-20230310220936237](数据结构结课总结.assets/image-20230310220936237.png)

1. 当a[i]>=a[lo]，i停止遍历

2. 当a[j]<=a[lo]，j停止遍历

3. 当i和j都停止遍历，需要进行一次判断：

   如果i<j，则交换a[i]和a[j]

   如果i>=j（即i和j交叉)，则遍历结束

4. 如果遍历没有结束，则交换后再次重复前三步；如果遍历结束，则交换a[lo]与a[j]

（a[j]此时指向最后一个比a[lo]小的元素)

###### 同侧

（i初始值为low，j初始值为i+1)

![image-20230310223318430](数据结构结课总结.assets/image-20230310223318430.png)

核心思路：i指向小于a[lo]的元素，j指向大于a[lo]的元素

1. j向右遍历，当a[j]<a[lo]，表示发现一个新的比a[lo]小的元素，则i向右移动一位，交换a[i]和a[j] （如果i!=j，则此时i指向最后一个比a[i]小的元素应该在的位置，而j指向比a[i]小的元素，交换后就能把比a[i]小的元素换到i处）
2. j遍历结束，交换a[lo]和a[i]

同侧和异侧划分结果不同

### 归并排序

不断均分直到序列长度为1或者2，对小序列进行排序，最后归并

![image-20230311091756783](数据结构结课总结.assets/image-20230311091756783.png)

## 树

![image-20230208233322399](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233322399.png)

![image-20230208233343944](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233343944.png)

![image-20230208233358544](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233358544.png)

![image-20230208233412811](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233412811.png)

![image-20230208233424376](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233424376.png)

![image-20230208233456348](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233456348.png)

![image-20230208233510848](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233510848.png)

![image-20230208233532175](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233532175.png)

## 基础二叉树

### 逻辑结构

![image-20230208233549732](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233549732.png)

#### 二叉树的层数/高度

（根节点为第一层）

假设二叉树有n个节点，则层数为：$\lfloor log_2n+1\rfloor$

假设二叉树层数/高度为k，则对应满二叉树节点个数为：$2^k-1$

假设满二叉树有m个节点，则层数为：

$\lfloor log_2(m+1)\rfloor$

#### 二叉树与树区别

![image-20230208233906762](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233906762.png)

![image-20230208233949129](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208233949129.png)

#### 满二叉树

![image-20230208234033157](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208234033157.png)

#### 完全二叉树

完全二叉树是满二叉树的局部（仅仅缺少右下角的叶子节点）

**满二叉树是特殊的完全二叉树**

![image-20230208234230691](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208234230691.png)

### 存储结构

#### 顺序存储结构

一般用于**完全二叉树**和**满二叉树**，此时从上到下，从左到右标号为i的节点，对应一维数组中索引为i的位置

![image-20230208235338355](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208235338355.png)

对于非完全二叉树，可以通过补充空节点，使其变成完全二叉树，但会浪费许多存储空间

![image-20230208235323824](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208235323824.png)

#### 链式存储结构

适用于**非完全二叉树**

![image-20230208235425630](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208235425630.png)

![image-20230208235451053](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208235451053.png)

![image-20230208235516528](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208235516528.png)

![image-20230208235527135](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208235527135.png)

### 相关问题

#### 遍历二叉树

遍历二叉树的每个节点，且每个节点仅访问一次

![image-20230208235741327](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230208235741327.png)

##### 前序遍历

![image-20230209000636364](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230209000636364.png)

##### 中序遍历

![image-20230209001232477](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230209001232477.png)

##### 后序遍历 

![image-20230209001430174](C:\Users\13712\AppData\Roaming\Typora\typora-user-images\image-20230209001430174.png)

### 堆

#### 逻辑结构

关键字存在树的节点中

大根堆：子节点的关键字不能大于父节点的关键字（根节点最大）

小根堆：子节点的关键字不能小于父节点的关键字（根节点最小）

#### 存储结构

完全二叉树的顺序表表示，以层次遍历次序存储

![image-20230308004106413](数据结构结课总结.assets/image-20230308004106413.png)

**插入元素**

在二叉堆末尾插入，然后不断调整堆结构，实现”上浮“

具体操作为：比较插入节点与根节点的大小关系，以大根堆为例，如果插入节点大于根节点，则交换插入节点与根节点的位置，重复该步骤直至插入节点小于根节点

**删除元素**

删除操作的对象是堆中的最大（最小）元素，即根节点

具体操作为：以大根堆为例，根节点与二叉堆末尾元素交换，删去此时的二叉堆末尾元素（最大元素），调整堆结构（根节点与左右子节点比较，如果根节点小于左右子节点中的最大节点，则交换根节点与最大子节点顺序），实现”下沉“

**注意：删除一个元素之后再插入该元素，尽管前后元素相同，但堆很大可能不一样**

![image-20230308165640677](数据结构结课总结.assets/image-20230308165640677.png)

#### 时间复杂度

插入和删除在根节点和子节点间的比较次数均为$log_2n$

插入时，由于待插入节点需要插入到堆的末尾元素，需要判断末尾位置在哪，所以此过程多算一次比较次数

而删除需要比较左右节点，判断左右节点中的最大节点，再用最大节点和根节点比较，所以需要乘2

所以插入比较次数为1+$log_2n$，删除比较次数为2$log_2n$

![image-20230308165836263](数据结构结课总结.assets/image-20230308165836263.png)

插入和删除的数量级与堆的高度有关，堆的高度数量级为O($log_dn$)

![image-20230308170938257](数据结构结课总结.assets/image-20230308170938257.png)

#### 应用

##### 堆排序

堆元素从大到小排序：

1. 建立大根堆
2. 输出根节点（最大元素）并删除根节点（最大元素），实际算法中不一定要删除根节点，只需将末尾索引不断减一，最后输出堆的数组
3. 调整堆结构
4. 重复Step2和Step3 n-1次后完成堆排序



如下图，为实际代码实现：

每次调整堆结构需要$log_2n$

建堆用时为$n/2*log_2n=O(nlog_2n)$

堆排序通过将堆末端元素减一的方式代替删除元素，因此只需要n-1次排序即可，用时为$(n-1)*log_2n=O(nlog_2n)$

![image-20230308171758221](数据结构结课总结.assets/image-20230308171758221.png)

##### 霍夫曼编码（Huffman)

![image-20230308173418020](数据结构结课总结.assets/image-20230308173418020.png)

方法：

每个节点包含码的字符和对应的频率

1. 根据每个码对应的频率将节点从小到大排序
2. 取有序序列的前两个节点，建立这两个节点的父节点，该节点只有频率（为两个子节点的频率之和），而没有字符
3. 重复Step1和Step2，直至有序序列只剩一个节点（为最终的Huffman树）

查询对应的Huffman编码只需从根节点往下走到目标节点（往左子树走则编码低位插入'0'，往右子树走则编码低位插入'1'）

### 并查集

常用于判断两个元素是否在同一个集合中

并查集建立“老大”的概念：给同一个集合中的元素找一个老大

leader[p]表示p的老大

#### 普通并查集

合并：如将p合并到q中，采用直接将leader[p]改成q

如果集合p有6个元素，则p中所有元素i的leader[i]都要改成q，这样操作的时间复杂度为O(n)

#### 快速合并并查集（Quick-find)

采用树的逻辑结构，每个元素视作一个子节点，对应一个根节点

类似于家谱，找子孙p和子孙q是否属于同一个家族，则寻根溯源找到是否有相同的祖先即可，至于要找到多久之前，就看关系是否亲密了，如果寻根溯源到最初的祖先，两者都不拥有相同的祖先，则不是同一个家族

合并的时候，只需将找到p的根节点root，将root纳入q的子节点即可

由于一个根节点可以有多个子节点，所以并查集不是二叉树

## 查找与搜索树

### 评价指标

![image-20230306191730448](数据结构结课总结.assets/image-20230306191730448.png)

![image-20230306191748271](数据结构结课总结.assets/image-20230306191748271.png)

### 分类

#### 静态查找

##### 顺序查找

从表的一端开始逐个将记录的关键字与给定K值比较（按值查找）

![image-20230306192117849](数据结构结课总结.assets/image-20230306192117849.png)

![image-20230306192850544](数据结构结课总结.assets/image-20230306192850544.png)

##### 折半查找

与顺序查找不同，折半查找需要有前提条件：查找表中的所有记录按关键字有序。

折半查找的思想是：通过不断缩小范围（将待查记录所在区间缩小一半）直到找到或找不到记录为止

![image-20230306193222410](数据结构结课总结.assets/image-20230306193222410.png) 

纠正：根节点为第一次进行比较的中间位置的记录，根节点左子树为(key<tree[mid]时)第二次进行比较的中间位置的记录，右子树为(key>tree[mid]时)第二次进行比较的中间位置的记录

![image-20230306195114439](数据结构结课总结.assets/image-20230306195114439.png)

![image-20230306200720932](数据结构结课总结.assets/image-20230306200720932.png)

#### 动态查找

当查找表需要多次进行插入、删除或排序操作时，线性表需要移动大量记录，为此引入动态查找

##### 二叉搜索树

在随机情况下，二叉排序树的平均查找长度ASL与Log(n)（即树的深度）是等数量级的，高度为O(logn)，各操作的时间复杂度为O(logn)

最差情况下，二叉搜索树的操作时间复杂度为O(n)，此时的二叉搜索树类似于链表

![image-20230306201025509](数据结构结课总结.assets/image-20230306201025509.png)

![image-20230306201142156](数据结构结课总结.assets/image-20230306201142156.png)

![image-20230306202332739](数据结构结课总结.assets/image-20230306202332739.png)

![image-20230306205709513](数据结构结课总结.assets/image-20230306205709513.png)

![image-20230306205731530](数据结构结课总结.assets/image-20230306205731530.png)

##### k-d树

![image-20230306210906571](数据结构结课总结.assets/image-20230306210906571.png)

###### 范围查找

![image-20230306211837182](数据结构结课总结.assets/image-20230306211837182.png)

**查找步骤：**

Step1：检查待查长方形是否包含当前节点root

Step2：判断待查长方形在k-d树的位置

奇数层：若x(max)<x(root)，则往左子树走；若x(min)>x(root)，则往右子树走

偶数层：若y(max)<y(root)，则往左子树走；若y(min)>y(root)，则往右子树走

若待查长方形与分割线相交，即

奇数层：x(min)<x(root)<x(max)

偶数层：y(min)<y(root)<y(max)

则下一步同时往左右子树走

Step3：重复Step1和Step2，若Step2需要往下走的左子树或右子树为空（待查长方形与分割线相交时，左右子树均为空），则停止往下查找，回溯返回，当回溯到整棵树的根节点，则彻底结束。

**时间复杂度：**

**一般情况：O(logn)**

**最差情况：O($\sqrt n+m$)**

###### 最近邻查找

（具体过程：[13-kd-tree-1123.pdf - 坚果云 (jianguoyun.com)](https://www.jianguoyun.com/d/home#/sandbox/15d730b/6579c2fb045bb06f/%2Fsse201-slides/?previewingFileName=13-kd-tree-1123.pdf)）

查找步骤

从根节点A开始

Step1：计算待查点与节点之间的距离，更新节点到待查点最短距离

Step2：判断待查点与节点的位置关系：

​					位于k-d树的奇数层：

​						如果待查点在节点左边，优先探索左子树

​						如果待查点在节点右边，优先探索右子树

​					位于k-d树的偶数层：

​						如果待查点在节点下边，优先探索左子树

​						如果待查点在节点上边，优先探索右子树

​				如果优先探索的子树为空，则返回到当前节点

​				每次回溯，对是否要探索另一子树进行进一步判断：

​					如果<u>待查点距另一子树区间大于当前最短距离</u>或者<u>另一子树为空</u>

​					则不需要探索另一子树，则进一步回溯

附：

1.子树区间

以下图为例，D右子树区间：由k-d树可知，位于D分割线右边，C分割线下边，A分割线左边，对应左图阴影部分为子树区间

![image-20230308000950165](数据结构结课总结.assets/image-20230308000950165.png)

2.判断待查点与子树区间范围最短距离方法						![image-20230308000837187](数据结构结课总结.assets/image-20230308000837187.png)

Step3：重复Step1和Step2，直到再次回溯到A（根节点）

## 平衡二叉树(AVL树)

![image-20230310175119620](数据结构结课总结.assets/image-20230310175119620.png)

![image-20230310175138364](数据结构结课总结.assets/image-20230310175138364.png)

### 平衡化旋转

将一般的不平衡的<u>二叉搜索树</u>构造成平衡二叉树的方法：平衡化旋转

![image-20230310175359411](数据结构结课总结.assets/image-20230310175359411.png)

二叉搜索树性质：

LL1和RR1的原理

某节点左上或左下的节点都比该节点小

某节点右上或右下的节点都比该节点大

所以左上变为左下，右上变为右下，大小关系不变

#### LL型

<u>LL型中根节点的平衡因子为2，且均为左子树节点</u>

之所以叫LL型，是因为从某节点开始，该节点的平衡因子为2失去了平衡，而平衡因子为2意味着左子树高度比右子树高度多2，即多了2个左子树节点(LL)

LL1和LL2的区别在于<u>左子树节点有没有右子节点</u>

##### LL型平衡化旋转1

旋转前x>a,旋转后x仍然>a

![image-20230310185018278](数据结构结课总结.assets/image-20230310185018278.png)

##### LL型平衡化旋转2

旋转前x>a，a<d<x,旋转后x>a，a<d<x

![image-20230310185113924](数据结构结课总结.assets/image-20230310185113924.png)

子节点d为a的直接后继节点，也是x的直接前继节点

直接后继：d为a的右子节点

直接前继：d为x的左子节点

#### RR型

<u>RR型根节点的平衡因子为-2，且均为右子树节点</u>

之所以叫RR型，是因为从某节点开始，该节点的平衡因子为-2失去了平衡，而平衡因子为-2意味着右子树高度比左子树高度多2，即多了2个右子树节点(RR)

RR1和RR2的区别在于<u>右子树节点有没有左子节点</u>

##### RR型平衡化旋转1和RR型平衡化旋转2

与LL1和LL2原理相同

![image-20230310185844044](数据结构结课总结.assets/image-20230310185844044.png)

#### LR型

根节点平衡因子为2，但组成为一个左子树节点一个右子树节点

LR型需先旋转变为LL型，再变为平衡

##### LR型平衡化旋转1

![image-20230310190813550](数据结构结课总结.assets/image-20230310190813550.png)

##### LR型平衡化旋转2

![image-20230310191626178](数据结构结课总结.assets/image-20230310191626178.png)

#### RL型

根节点平衡因子为-2，但组成为一个右子树节点一个左子树节点

RL型需先旋转变为RR型，再变为平衡

##### RL型平衡化旋转1

![image-20230310191828227](数据结构结课总结.assets/image-20230310191828227.png)

##### RL型平衡化旋转2

![image-20230310191843663](数据结构结课总结.assets/image-20230310191843663.png)

## 2-3树

![image-20230310202730176](数据结构结课总结.assets/image-20230310202730176.png)

![image-20230310203311544](数据结构结课总结.assets/image-20230310203311544.png)

### 插入

如果原叶子节点由3节点变为4节点，将4节点中间的关键字移向父节点，同时分裂为2个子节点。如果4节点是根节点，由于根节点没有父节点，则只需要分裂为2个子节点

![image-20230310202845091](数据结构结课总结.assets/image-20230310202845091.png)

![image-20230310202800792](数据结构结课总结.assets/image-20230310202800792.png)

![image-20230310203238754](数据结构结课总结.assets/image-20230310203238754.png)

## B-树

2-3树的一般形式

失败节点：不含信息的叶子节点

![image-20230311103102505](数据结构结课总结.assets/image-20230311103102505.png)

## 图

### 基本概念

<u>顶点个数不能为零，但可以没有边</u>

<u>因此树不是特殊的图</u>（树节点可以为零）

![image-20230308175526687](数据结构结课总结.assets/image-20230308175526687.png)

![image-20230308175514585](数据结构结课总结.assets/image-20230308175514585.png)

![image-20230308184733443](数据结构结课总结.assets/image-20230308184733443.png)

### 存储结构

#### 邻接矩阵

主要用于比较稠密的图，比如完全图

![image-20230308185001237](数据结构结课总结.assets/image-20230308185001237.png)

![image-20230308185154589](数据结构结课总结.assets/image-20230308185154589.png)

##### 无向图的邻接矩阵

![image-20230308185256483](数据结构结课总结.assets/image-20230308185256483.png)

![image-20230308185315297](数据结构结课总结.assets/image-20230308185315297.png)

##### 有向图的邻接矩阵

![image-20230308185437130](数据结构结课总结.assets/image-20230308185437130.png)

![image-20230308185449747](数据结构结课总结.assets/image-20230308185449747.png)

![image-20230308185512297](数据结构结课总结.assets/image-20230308185512297.png)

##### 带权图的邻接矩阵

![image-20230308185543440](数据结构结课总结.assets/image-20230308185543440.png)

#### 邻接表

![image-20230308185937715](数据结构结课总结.assets/image-20230308185937715.png)

##### 无向图的邻接表

![image-20230308190011491](数据结构结课总结.assets/image-20230308190011491.png)

##### 有向图的邻接表

![image-20230308190309280](数据结构结课总结.assets/image-20230308190309280.png)

##### 带权图的邻接表

![](数据结构结课总结.assets/image-20230308190340787.png)

#### 邻接多重表

分为顶点集和边集

顶点集和边集均用顺序表存储节点元素

先分别罗列顶点集和边集，再用指针将顶点与边相连接

##### 无向图的邻接多重表

![image-20230308190944826](数据结构结课总结.assets/image-20230308190944826.png)

![image-20230308191001360](数据结构结课总结.assets/image-20230308191001360.png)

![image-20230308190931475](数据结构结课总结.assets/image-20230308190931475.png)

##### 有向图的邻接多重表

包含了入边表和出边表

![image-20230308191106124](数据结构结课总结.assets/image-20230308191106124.png)

![image-20230308191135440](数据结构结课总结.assets/image-20230308191135440.png)

![image-20230308192315251](数据结构结课总结.assets/image-20230308192315251.png)

### 图的遍历

#### 深度优先遍历(DFS)

（人）遍历过程：

1. 从图中某一起始顶点开始访问
2. 访问当前节点的其中一个未被访问的子节点
3. 重复Step2和Step3，如果Step2当前节点没有子节点或者子节点都被访问过，则回溯，直至回溯到某一节点，该节点满足拥有未被访问的子节点，再重复Step2

（计算机）DFS树构造过程：

1. 从图中某一起始顶点开始，把该顶点作为DFS树的根节点
2. 把当前节点的邻接顶点纳入树中，作为当前节点的子节点
3. 访问当前节点的其中一个没有被访问的子节点
4. 重复Step2和Step3，如果Step3当前节点没有子节点或者子节点都被访问过，则回溯，直至回溯到某一节点，该节点满足拥有未被访问的子节点，再重复Step2和Step3
5. 直至图中的所有顶点都访问过一次（在DFS树中表现为，DFS结束

![image-20230308200705793](数据结构结课总结.assets/image-20230308200705793.png)

![image-20230308200922443](数据结构结课总结.assets/image-20230308200922443.png)

#### 广度优先遍历(BFS)

（人&机）遍历过程：

建立一个队列，存放未被访问子节点的节点

从图中某一顶点开始，

1. 访问当前节点，把该节点的没有被访问过且没有在队列中的相邻节点插入队列中
2. 如果队列不为空，取出队首元素
3. 重复Step1和Step2，直到队列为空

BFS树构造过程：

从图中某一顶点开始，

1. 访问当前节点，把该节点的没有被访问过且没有在队列中的相邻节点插作为子节点，并插入队列中
2. 如果队列不为空，取出队首元素
3. 重复Step1和Step2，直到队列为空

### 最小生成树

![image-20230308210636778](数据结构结课总结.assets/image-20230308210636778.png)

#### 以图切割为基础的贪心算法

![image-20230308210727710](数据结构结课总结.assets/image-20230308210727710.png)

![image-20230308210823658](数据结构结课总结.assets/image-20230308210823658.png)



可以有以下切割方法：

1. 从图中某个顶点开始，
2. 将图的顶点集分割为两部分，该顶点和其他顶点，则交叉边为与该顶点相邻的边
3. 从该顶点的所有交叉边中选择最小权值的交叉边加入树中
4. 重复以上3个步骤，直到遍历完所有顶点

**<u>注意：如果该点的最小权值的交叉边已在树中，则该点跳过</u>**

如下图中，如果遍历顶点按CADGFEBH，则遍历至点F时，点F的最小权值交叉边为DF，权值为1，但遍历D时，该边已插入到最小生成树中，所以遍历F时，直接跳过，下一步遍历点E。

![image-20230308212015109](数据结构结课总结.assets/image-20230308212015109.png)

#### 克鲁斯卡尔(Kruskal)算法

当最小生成树中有n-1条边结束

![image-20230308232636417](数据结构结课总结.assets/image-20230308232636417.png)

#### 普里姆(Prim)算法

![image-20230308233121734](数据结构结课总结.assets/image-20230308233121734.png)

### 图的最短路径算法

有权有向图的最短路径问题是一般情况，其余的有权无向图、无权有向图、无权无向图等都是有权有向图的特殊情况

最短路径问题分为4种

1. 单源（某顶点v到各个顶点的最短路径）
2. 单目的（各个顶点到某顶点v的最短路径）
3. 源-目的对（某顶点u到某顶点v的最短路径）
4. 所有顶点对

#### 单源最短路径

以顶点s为源顶点，寻找对任意其他顶点的最短路径

一定存在一种最短路径树解法

##### 引言

###### 最短路径树

顶点s到顶点v的最短路径与顶点v的邻接顶点的最短路径强相关

5->6的最短路径取决于5->3的最短路径，5->3的最短路径为5->1->3，所以5->6的最短路径为5->1->3->6

![image-20230310010439513](数据结构结课总结.assets/image-20230310010439513.png)

edgeTo[v]表示边(edgeTo[v],v)

最短路径树中每个索引对应一个顶点，同时也对应一条边(edgeTo[index],index)，该边在最短路径树中，源顶点s到顶点index的最短距离为distTo[index]

判断源顶点的方法：distTo[s]=0或edgeTo[s]=null，则s为源顶点

![image-20230310010610274](数据结构结课总结.assets/image-20230310010610274.png)

###### 边松弛

边松弛的意思，即如果v->w的边产生更短的s到w的路径，则更新distTo[w]和edgeTo[w]

distTo[w]=distTo[v]+(v,w)的长度

![image-20230310011710017](数据结构结课总结.assets/image-20230310011710017.png)

#### 单源最短路径的算法

初始：

选定源顶点s，把distTo[s]设为0

由于源顶点s到某顶点v的最短距离在算法执行过程中一定是不断变小，所以不妨一开始设为无穷大

所以一开始除了源顶点s，其他顶点的distTo[s]=∞

![image-20230310012053563](数据结构结课总结.assets/image-20230310012053563.png)

##### 贝尔曼-福特算法

以边集为核心思路，设顶点数为V，则遍历边集至多V-1次，每次遍历边集松弛所有边

如果第i次遍历后，distTo[v]没有任何变化，则直接跳过i+1轮，而distTo[v]改变的顶点v存进一个队列中，在第i+1轮，仅对队列中的顶点执行边松弛操作(注意：当edgeTo[v]=s时，v不需要边松弛，因为此时已经是最短路径了)

当所有的distTo[v]不变，此时的表对应最小路径树

对任意的v，distTo[v]为源顶点s到某顶点v的最短距离

![image-20230310012811030](数据结构结课总结.assets/image-20230310012811030.png)

![image-20230310013019580](数据结构结课总结.assets/image-20230310013019580.png)

##### 狄克斯特拉(Dijkstra)算法

1. 选定源顶点s，将distoTo[s]设为0，edgeTo[s]设为null
2. 查找以顶点s为始点的边，松弛这些边
3. 从路径表中选出distTo[]最小的点，对它做标记表示已经访问过了
4. 重复step2和step3直到所有点都被遍历过

![image-20230310155029667](数据结构结课总结.assets/image-20230310155029667.png)

### 应用：斯坦纳树

斯坦纳树顶点集包含斯坦纳点和终端顶点

斯坦纳点不一定存在，因此斯坦纳树是最小生成树的超集

![image-20230310163334003](数据结构结课总结.assets/image-20230310163334003.png)

![image-20230310160116135](数据结构结课总结.assets/image-20230310160116135.png)

![image-20230310160146977](数据结构结课总结.assets/image-20230310160146977.png)

![image-20230310164323154](数据结构结课总结.assets/image-20230310164323154.png)

#### 基于最短路径的启发式解法

具体解法如下例

要几点要注意：

1. 以<u>不在子树T的终端顶点为源顶点</u>，寻找与子树中<u>各个顶点距离最短</u>的点（而不是以子树中的顶点为源顶点）
2. 对Dijkstra算法做简化，找距离最短顶点时，可以先找出目标顶点的相邻顶点v，得到相邻顶点的最短路径及其长度distTo[v]，再计算distTo[w]=distTo[v]+(v,w)，比较distTo[w]谁最小

![image-20230310160333802](数据结构结课总结.assets/image-20230310160333802.png)

![image-20230310162331864](数据结构结课总结.assets/image-20230310162331864.png)

![image-20230310162346212](数据结构结课总结.assets/image-20230310162346212.png)

![image-20230310162401673](数据结构结课总结.assets/image-20230310162401673.png)

![image-20230310162421365](数据结构结课总结.assets/image-20230310162421365.png)

#### 基于深度优化搜索的启发式解法

![image-20230310164614336](数据结构结课总结.assets/image-20230310164614336.png)

1. 从任意一个终端顶点开始，当遇到3个终端顶点时，根据上图原理，构造第一个斯坦纳点s1(0)，该斯坦纳点插入深度探索树
2. 继续深度向下探索，每探索到一个新的终端顶点，取该顶点的两个最近父节点与该顶点构造新的斯坦纳点，并插入深度探索树中
3. 重复Step2，直到遍历完所有终端顶点

![image-20230310165506475](数据结构结课总结.assets/image-20230310165506475.png)

![image-20230310165520431](数据结构结课总结.assets/image-20230310165520431.png)

![image-20230310165533370](数据结构结课总结.assets/image-20230310165533370.png)

![image-20230310165546396](数据结构结课总结.assets/image-20230310165546396.png)

![image-20230310165600682](数据结构结课总结.assets/image-20230310165600682.png)

## 基本算法思想

### 分治法

如归并排序，快速排序

![image-20230310165718979](数据结构结课总结.assets/image-20230310165718979.png)

快速排序

![image-20230310165750016](数据结构结课总结.assets/image-20230310165750016.png)

归并排序

![image-20230310165818468](数据结构结课总结.assets/image-20230310165818468.png)

### 贪心算法

<u>注意：贪心算法不一定正确， 正确性依据具体问题不同而不同，因此需要验证某特定问题的贪心算法的正确性。</u>

![image-20230310165846930](数据结构结课总结.assets/image-20230310165846930.png)

#### 无界限背包问题

背包容量一定，合理选择商品，使不超重前提下花最多的钱

![image-20230310170001333](数据结构结课总结.assets/image-20230310170001333.png)

贪心算法解法

先计算出每个商品的价格/重量，每次均选择单位重量价格最高的商品

![image-20230310170025104](数据结构结课总结.assets/image-20230310170025104.png)

**但这种贪心算法解法是错的！**

![image-20230310170133116](数据结构结课总结.assets/image-20230310170133116.png)

#### 活动选择问题

![image-20230310170259368](数据结构结课总结.assets/image-20230310170259368.png)

有多种选择方法：

1. 按开始时间从早到晚排序，每次选择开始最早的活动
2. 按持续时间从短到长排序，每次选择开始持续时间最短的活动
3. 按结束时间从早到晚排序，每次选择结束最早的活动

选择结束时间最早的解法（即方法3）

![image-20230310171354876](数据结构结课总结.assets/image-20230310171354876.png)

对贪心算法的正确性进行归纳求证 

![image-20230310171430038](数据结构结课总结.assets/image-20230310171430038.png)

#### 调度问题

![image-20230310173021581](数据结构结课总结.assets/image-20230310173021581.png)

### 动态规划

![image-20230311100614444](数据结构结课总结.assets/image-20230311100614444.png)