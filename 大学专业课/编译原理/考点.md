## 引论

### 请简述编译器、解释器、混合编译器的区别。  

- 编译器：
  1. 用户输入某种语言（源语言）编写的程序，编译器输出**等价的**用另一种语言（目标语言）编写的目标程序。
  2. 目标程序**可执行**。
- 解释器：
  1. 直接利用用户提供的输入，执行源程序中指定的操作
  2. 不生成目标程序，根据程序的语义直接运行。
- 混合编译器：
  1. Java语言的处理结合了编译和解释
  2. Java源程序**编译**为**字节码(bytecode)**中间表示
  3. 在**虚拟机**上对字节码**解释**执行

![image-20240107133646555](考点.assets/image-20240107133646555.png)

![image-20240107133700820](考点.assets/image-20240107133700820.png)

### 编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么？

- 编译器相对于解释器的优点：

  输入映射为输出的过程，编译器编译得到的机器语言目标程序比解释器**运行速度**快得多

  

- 解释器相对于编译器的优点：

  解释器对源程序的**错误诊断能力**比编译器更好（因为解释器逐条语句执行源程序）

### 编译器的结构

编译器分为前端和后端

- 前端/分析部分
  - 作用：
    1. 将源程序分解为组成要素（对应词法分析），以及相应的语法结构（对应语法分析）
    2. 利用语法结构创建源程序的中间表示（对应语义分析）
    3. 同时收集和源程序相关的信息，存放到符号表（对应语义分析）
- 后端/综合部分
  - 作用：
    1. 根据中间表示和**符号表**信息构造目标程序
    2. 同时对目标程序进行分析、**优化**

具体组成部分：

字符流->词法分析器->词法单元流->语法分析器->语法树->语义分析器->语法树->中间代码生成器->中间表示形式->机器无关代码优化器->中间表示形式->目标代码生成器->目标机器语言->机器相关代码优化器->目标机器语言

![image-20240107135447449](考点.assets/image-20240107135447449.png)

**编译器前端**

1. 词法分析器
2. 语法分析器 
3. 语义分析器 
4. **中间代码生成器**（输入语法树，输出中间表示形式）

**编译器后端**

1. 目标代码生成器 （输入中间表示形式，输出目标机器语言）
2. 机器相关代码优化器

**既不属于前端也不属于后端**

1. 机器无关代码优化器（输入中间代码，输出中间代码）

#### #TODO 画出编译程序的总体结构图，简述各部分的主要功能  



### 程序设计语言的分类

计算机程序语言：高级语言，汇编语言，机器语言

- 高级语言：
  1. 接近人类表达习惯
  2. 不依赖特定机器
  3. 编写效率高
- 汇编语言
  1. 依赖于特定机器，非计算机专业人员使用受限制
  2. 编写效率较低
- 机器语言
  1. 与人类表达习惯相去甚远
  2. 难记忆
  3. 难编写，难阅读，难理解

#### 分类

基于语言的代

1. 第一代：机器语言
2. 第二代：汇编语言
3. 第三代：高级程序设计语言
4. 第四代：领域特定语言DSL
5. 第五代：基于逻辑和约束的语言

基于编程范式：

1. 命令式/强制性语言
   - C、C++、C#、Java，Fortran
2. 声明式语言：函数式语言，逻辑式语言
   - ML、Haskell、Prolog

冯诺依曼语言

- C，C++，Fortran，Java，VB

面向对象语言

- Simula 67、Smalltalk、C++、C#、Java、Ruby

脚本语言

- Awk、JavaScript、Perl、PHP、Python、Ruby

### 给定以下程序，请分析每个声明的作用域。  

![image-20240107141607031](考点.assets/image-20240107141607031.png)

### 请写出参数传递的几种机制并简述区别。  

1. 值调用

   核心在于传递值，将实参的值传递给形参，改变形参的值不影响实参

   - 如果实参是表达式，计算表达式的值拷贝给形参
   - 如果实参是变量，将变量的值拷贝给形参
   - 如果实参为指针。以Java的值调用为例，Java将对象的名字拷贝给形参，被调用过程能够收到的值为对象的指针，被调用过程能够改变这个对象本身的值

2. 引用调用

   核心在于传递指针，将实参的地址传递给形参，改变形参的值能够影响实参

3. 名调用

   将形参在字面形式上直接替换为实参，替换后再计算形参的值。形参是代表实参的宏。

### 以防万一

![image-20240107142027064](考点.assets/image-20240107142027064.png)

## 词法分析

### 词法分析器的作用

![image-20240107153415088](考点.assets/image-20240107153415088.png)

### 基本概念考察

**词法单元：**

- <词法单元名（类型） 、属性值 (可选) >
- 单元名是**表示词法单位种类的抽象符号**，语法分析器通过单元名即可确定词法单元序列的结构
- 属性值通常用于**语义分析**之后的阶段

**模式**：**一类词法单元**的词素可能具有的形式

**词素**：源程序中的**字符序列**，这些字符序列与某个词法单元的模式匹配，被词法分析器识别为该词法单元的实例

**字母表：有穷符号集合。**顾名思义，一堆符号的有穷/可数集合

**串：符号的有穷序列。**字母表中多个符号组成的序列

- 串s的长度|s|就是字母的个数
- 空串表示为$\epsilon$，长度为0
- 单个符号也可以是串，长度为1

**语言：符号串的集合。**用字母表中的符号组成串，多个这样的串放在一个集合里，这个有穷/可数集合叫做语言

- 空集和包含空串的集合{$\epsilon$}也是语言，前者是含有0个串的集合，后者是含有1个串（空串也是串）的集合
- 所有语法正确的C程序的集合、所有语法正确的英语句子的集合是语言

**正则表达式**

表示若干个词素的公共特征的一种模式

![image-20240107144250335](考点.assets/image-20240107144250335.png)

**正则语言**：可以用一个正则表达式定义的语言  

正则定义：给正则表达式命名的若干个定义序列

### NFA与DFA构造考察

#### 问法

**构造⼀个最⼩化DFA，它接受Σ = {x, y}上所有包含 xy 的字符串。** 

**构造一个DFA，它接受.... 字符串。给出构造过程。**     

#### 解决方法

1. 写出正则表达式
2. 将正则表达式转换为NFA
3. 将NFA转换为DFA
4. 将DFA最小化

### 以防万一

#### 为什么要设立独立的词法分析？（或为什么要将编译过程的分析阶段分为词法分析阶段和语法分析阶段）

1. **简化编译器的设计**。例如我们不希望语法分析器还要去除注释和空白。
2. **提高编译器效率。**把词法分析器独立出来使我们能够使用专用于词法分析任务、不进行语法分析的技术。
3. **增强编译器的可移植性。**输入设备相关的特殊性可以被限制在词法分析器中。

## 语法分析

### 语法分析器的作用

![image-20240107153458614](考点.assets/image-20240107153458614.png)

### 基本概念

句子可以理解为具体的句型，语言为句子的集合

这里的语言和词法分析中的语言不冲突，因为句子是只包含终结符号/空串的句型，也就是说句子还是词法分析的符号串

语言是句子的集合，也是符号串的集合

![image-20240107154150736](考点.assets/image-20240107154150736.png)

![image-20240107154857097](考点.assets/image-20240107154857097.png)

一棵语法分析树可对应多个推导序列

- 但只有**唯一的最左推导及最右推导**

### 请说出上下文无关文法的组成部分

1. 终结符号
2. 非终结符号
3. 产生式
4. 起始符号

终结符号：组成串的基本符号（词法单元名字）

非终结符号：表示**串的集合**的语法变量。给出了语言的层次结构，语法分析和翻译的关键。

产生式：描述将终结符号和非终结符号组成串的方法

起始符号：某个被指定的**非终结符号**。**它对应的串的集合就是文法的语言**  

### 上下文无关文法和正则表达式的比较

#### 请简述上下文无关文法和正则表达式的异同  

上下文无关文法是正则表达式的超集，上下文无关文法比正则表达式的能力更强 

- 所有的正则语言都可以使用文法描述
- 但有一些用文法描述的语言不能用正则表达式描述  

#### 为什么使用正则表达式定义一个语言的词法语法

总结来说就是两点

1. 和文法相比，正则表达式更**加简洁且易于理解**
2. 根据正则表达式自动构造的词法分析器的**效率高**于根据任意文法自动构造得到的分析器

#### 什么时候使用正则表达式，什么时候使用文法？

- 正则最适合描述id、常量、关键字这样的语言构造的结构
- 文法最适合描述**嵌套结构**，如对称的括号、对应的if-then-else等，这些无法用正则描述

### 给定文法G，请画出句子 xxx 的语法分析树。  

![image-20240107154608311](考点.assets/image-20240107154608311.png)

![image-20240107154624128](考点.assets/image-20240107154624128.png)

### 设计文法相关概念

合法的程序是符合文法程序的子集，符合文法的程序不一定是合法的程序，需要语义分析来剔除一些符合文法、但不合法的程序

在进行高效的语法分析之前，需要对文法做以下处理

1. 消除二义性

   - **二义性：文法可以为一个句子生成多颗不同的分析树**
   - 消除二义性方法：分层。将真正想要的推导提取出来，放到更深的层次

2. 消除左递归

   - **左递归：文法中一个非终结符号A使得对某个串α，存在一个推导 $A =>^* Aα$，则称这个文法是左递归的**
   - 自顶向下的语法分析不能处理左递归，需要消除左递归。自底向上的语法分析可以处理左递归
   - 直接左递归：文法中存在一个形如$A\rightarrow Aα$的产生式  

3. 提取左公因子

   - 左公因子：若产生式为$A =>α\beta_1|α\beta_2|α\beta_3$，那么左公因子为$\alpha$

   - 提取左公因子：

     ![image-20240107163436820](考点.assets/image-20240107163436820.png)

     

#### 消除二义性

将更高优先级的符号放在更深层

![image-20240107160104975](考点.assets/image-20240107160104975.png)

#### 消除左递归

![image-20240107160011498](考点.assets/image-20240107160011498.png)

### 自顶向下的语法分析

普通自顶向下的语法分析需要回溯

#### 递归下降分析法

##### 假设我们有以下简化的语法规则G，请使用递归下降法来解析并生成语法树，针对以下输入字符串：xxx  

**递归下降语法分析**

为输入串构造语法分析树

- 从分析树的根结点（即文法的起始符号）开始，按照先根次序，深度优先地创建各个结点
- 对应于最左推导

基本步骤

- 确定对句型中最左边的非终结符号应用哪个产生式
- 然后对该产生式与输入符号进行匹配

![image-20240107161707396](考点.assets/image-20240107161707396.png)

![image-20240107161730050](考点.assets/image-20240107161730050.png)

#### LL（k）预测分析法

- L: left-to-right 从左到右扫描
- L: left-most 最左推导
- k: 向前看k个符号
  - 实践当中，通常k=1，即LL(1)
  - 每次为最左边的非终结符号选择产生式时，向前看1个输入符号，预测要使用的产生式

#### LL(1)文法

![image-20240107164123516](考点.assets/image-20240107164123516.png)

##### 假设我们有以下LL(1)文法，构造它的LL(1)预测分析表，然后使用这个表来解析以下输入字符串：xxx

步骤1：计算First、Follow集合

步骤2：基于First和Follow集合，构造预测分析表

步骤3：用预测分析表解析xxx

#### 非递归预测分析

![image-20240107164905383](考点.assets/image-20240107164905383.png)

#### 自底向上的语法分析

自底向上分析的过程就是识别和归约句柄的过程  

##### 知识脉络梳理

自底向上分析为一个输入串构造语法分析树的过程

- 从叶子 (输入串中的终结符号，将位于分析树的底端) 开始，向上到达根结点
  - 在实际的语法分析过程中并不一定会构造出相应的分析树，但是用分析树的概念可以方便理解
- 重要的自底向上语法分析的通用框架
  - 移入-归约 (shift-reduce)
- LR技术：
  - 以移入-归约为框架，LR(0)项集规范族和LR(0)自动机为基础
  - 核心思路：识别句柄，归约句柄
    - LR(0)项集规范族和LR(0)自动机
      - LR(0)项：一个文法产生式加上在其中某处的一个点
      - LR(0)自动机：
        - 基于规范LR(0)项集族可以构造LR(0)自动机
        - **规范LR(0)项集族中的每个项集对应于LR(0)自动机的一个状态**
        - 状态转换：如果GOTO(I, X) = J，则从 I 到 J有一个标号为 X的转换
        - **开始状态为CLOSURE({ S' ->·S })对应的项集**
        - 所有状态都是接受状态
      - LR(0)项集规范族构造方法：
        - 增广文法（引入起始状态）
        - 项集闭包CLOSURE （状态机确定化）
        - GOTO函数（定义状态跳转）
- 多种LR技术
  - 简单LR技术 (Simple LR)
  - 向前看LR技术(Look-Ahead LR)
  - LALR

###### LR通用算法表示

![image-20240107184315590](考点.assets/image-20240107184315590.png)

###### SLR语法分析算法

![image-20240107184434346](考点.assets/image-20240107184434346.png)

###### LR(1)算法



###### LALR算法

![image-20240107184531033](考点.assets/image-20240107184531033.png)



##### 基本概念

归约：一个与某产生式体匹配的特定子串被替换为该产生式头的非终结符号

![image-20240107165935812](考点.assets/image-20240107165935812.png)

##### 请简述自底向上的语法分析中，“移进-归约”操作是如何工作的。  

![image-20240107170043116](考点.assets/image-20240107170043116.png)

![image-20240107170119055](考点.assets/image-20240107170119055.png)

##### 移入-归约分析中的冲突  

移入-归约冲突：无法知道是否该进行归约

归约-归约冲突：无法知道按照什么产生式进行归约

#### LR语法分析技术

LR(k)的语法分析概念

- L表示最左扫描，R表示**反向**构造出**最右推导**
- k表示最多向前看k个符号

当k增大时，相应的语法分析器的规模急剧增大

- k = 2时，程序语言的语法分析器的规模通常非常庞大
- 当k = 0, 1时，已经可以解决很多语法分析问题，因此具有实践意义
- 我们只考虑k <= 1的情况

##### LR(0)项集规范族的构造  

![image-20240107172221558](考点.assets/image-20240107172221558.png)

![image-20240107172214842](考点.assets/image-20240107172214842.png)

![image-20240107172204518](考点.assets/image-20240107172204518.png)

![image-20240107172155632](考点.assets/image-20240107172155632.png)

##### LR语法分析

在LR(0)项集规范族和LR(0)自动机基础上做出以下改进：

- 仍然使用LR(0)规范项集族
  - 使用增广文法
  - 使用闭包获得初始项集
  - 使用GOTO函数获得新项集
- 与LR(0)自动机相同，将获得的LR(0)规范项集族中的每个项集$I_j$记作状态j
- 引入了ACTION和GOTO函数，对LR(0)项集的GOTO函数进行细分
  - ACTION函数指明每个状态（项集）遇到**输入的终结符号**应该做出的动作：移入 or 归约
  - GOTO函数指明每个状态（项集）遇到**输入的非终结符号**应该转换到哪个状态

![image-20240107174441963](考点.assets/image-20240107174441963.png)

##### SLR语法分析算法

![image-20240107184953916](考点.assets/image-20240107184953916.png)

##### LR(1)语法分析算法

在SLR基础上，对项集引入了期望的向前看符号，向前看符号个数对应LR(k)中的k

![image-20240107185823519](考点.assets/image-20240107185823519.png)

![image-20240107185843766](考点.assets/image-20240107185843766.png)

![image-20240107185942548](考点.assets/image-20240107185942548.png)

![image-20240107200145246](考点.assets/image-20240107200145246.png)

![image-20240107185949307](考点.assets/image-20240107185949307.png)

##### LALR语法分析算法

对LR(1)项集规范族中的同核心项集进行合并

![image-20240107205243199](考点.assets/image-20240107205243199.png)

![image-20240107205250158](考点.assets/image-20240107205250158.png)

## 语义分析

### SDD

语法制导的定义  Syntax-Directed Definition (SDD) 是上下文无关文法和属性/规则的结合  

- 属性和文法符号相关联，按照需要来确定各个文法符号需要哪些属性
- 规则和产生式相关联

**SDD三要素：文法、属性、规则**  

没有副作用的SDD称为属性文法 (Attribute Grammar)  

使用**依赖图**来表示计算顺序

- 这些值的计算顺序形成一个偏序关系，如果依赖图中出现了环，表示属性值无法计算
- ![image-20240107210034888](考点.assets/image-20240107210034888.png)

#### 综合属性、继承属性、S属性SDD、L属性SDD  

![image-20240107210808614](考点.assets/image-20240107210808614.png)

**综合属性 (Synthesized Attribute)**

- 结点N的属性值由N的产生式所关联的语义规则来定义
- 通过N的子结点或N本身的属性值来定义

**继承属性 (Inherited Attribute)**

- 结点N的属性值由N的父结点所关联的语义规则来定义
- 依赖于N的父结点、N本身和N的兄弟结点上的属性值

**S属性的SDD**  

- 只包含综合(Synthesized)属性的SDD称为S属性的SDD  
- S属性的SDD可以和自底向上或自顶向下的语法分析过程一起计算  
  - 自底向上（和LR语法分析器一起实现 ）
    - 在构造分析树结点的同时计算相关的属性 (此时其子结点的属性必然已经计算完毕)
  - 自顶向下
    - 在递归子程序法中，在过程A()的最后计算A的属性 (此时A调用的其他过程 (对应于其子结构) 已经调用完毕)
    - ![image-20240107210310842](考点.assets/image-20240107210310842.png)

**L属性的SDD**  

![image-20240107210426616](考点.assets/image-20240107210426616.png)

![image-20240107210926873](考点.assets/image-20240107210926873.png)

![image-20240107210938280](考点.assets/image-20240107210938280.png)

#### 具体语法树和抽象语法树的区别

![image-20240107211038141](考点.assets/image-20240107211038141.png)

#### SDD的应用

1. 类型分析
2. 语法树构造
3. 代码翻译

### SDT

对于一般的SDT，采用先序遍历分析树

![image-20240107212420213](考点.assets/image-20240107212420213.png)

![image-20240107212402122](考点.assets/image-20240107212402122.png)

#### L属性的SDD到SDT的转换

**文法可以自底向上分析 (即LR的) 且其SDD是S属性的，必然可以构造出后缀SDT**

后缀SDT：所有动作都在产生式最右端的SDT

构造方法

- 将每个语义规则看作是一个赋值语义动作
- 将所有的语义动作放在规则的最右端

![image-20240107212824681](考点.assets/image-20240107212824681.png)

#### L属性的SDD到SDT的转换

将每个语义规则看作是一个赋值语义动作

- 将赋值语义动作放到相应产生式$A\rightarrow X1 X2 … Xn$的适当位置
- 计算X i**继承属性**的动作插入到产生式体中**X i的左边**
- 计算产生式头A**综合属性**的动作在产生式的**最右边**

#### while的SDD到SDT的转换

![image-20240107213750995](考点.assets/image-20240107213750995.png)

![image-20240107214920935](考点.assets/image-20240107214920935.png)

#### 边扫描边生成属性  

逐步生成属性的各个部分，并增量式地添加到最终的属性值  

三个条件

- 存在一个主属性，且其为**综合属性**
- 在产生式中，主属性是通过产生式体中**各非终结符号的主属性连接而得到**，同时还会连接一些其它元素
-  各个非终结符号的主属性的**连接顺序**与它们在产生式体中的**顺序相同**

![image-20240107215405562](考点.assets/image-20240107215405562.png)

## 中间代码生成 

练习5.1.1，5.2.3，5.3.1  

布尔表达式的控制流翻译

练习7.5.1&7.5.2

### AST和三地址码的异同

- AST是高层的标识，刻画了源程序的自然的层次性结构，适用于静态类型检查这样的处理
  - 高级的程序表示 (贴近源语言层面) 
  - 语言相关 (与源语言语法紧密关联)
  - 适合一些类型检查
  - 不紧凑、缺少控制流信息 (不利于分析与优化)  
- 中间代码紧凑、明晰的控制流信息 (易于分析与优化) ，与具体语言无关 (通用) ，与具体机器无关 (通用++)  

### 三地址代码

三地址代码基于两个概念：地址和指令

- 每条指令右侧最多有一个运算符

![image-20240108072435895](考点.assets/image-20240108072435895.png)



### 静态单赋值 (SSA)

**静态单赋值 (SSA)  是一种特殊的三地址代码，其所有变量在代码中只被赋值一次**  

基本构造思路

- 为每个变量维护一个计数器
- 从函数入口开始遍历函数体
- 遇到**变量赋值**时，为其生成新名字，并替换
- 将新变量名传播到后续相应的使用处，并替换

通常只针对函数内的变量 (即局部变量) 计算SSA

全局变量的SSA在实际当中难以计算

**SSA形式中，定义-使用关系非常清晰，且可以线性复杂度进行计算**  

### 类型检查 

类型检查 (Type checking)：利用一组规则来检查运算分量的类型和运算符的预期类型是否匹配

类型信息的用途：

- 查错
- 确定名字 (对应的数据) 所需的内存空间
- 计算数组元素的地址
- 类型转换
- 选择正确的运算符

![image-20240108073742929](考点.assets/image-20240108073742929.png)

![image-20240108073748327](考点.assets/image-20240108073748327.png)

![image-20240108073752830](考点.assets/image-20240108073752830.png)

有两类类型等价性判定方式：

- 名等价 ( N a m e Equivalence)
  - 类型表达式t与u等价当且仅当它们对应的**类型名字**相同
- 结构等价 (Structure Equivalence)
  - 对于基本类型，比较它们名字是否相同
  - 对于复合类型，比较**类型构造算子**；若相同，(递归) 比较构造算子的各参数分量

**变量的类型信息存放在符号表**

记录类型使用专用的符号表，对其各个字段的类型和相对地址进行单独编码

- 一个记录中各个字段的名字必须互不相同
- 字段名的偏移量（相对地址）是相对于该记录的**数据区**字段而言的

类和记录一样

![image-20240108074327651](考点.assets/image-20240108074327651.png)

![image-20240108075245540](考点.assets/image-20240108075245540.png)

![image-20240108075717318](考点.assets/image-20240108075717318.png)

![image-20240108080311504](考点.assets/image-20240108080311504.png)

![image-20240108080800925](考点.assets/image-20240108080800925.png)

![image-20240108080809893](考点.assets/image-20240108080809893.png)

![image-20240108081422603](考点.assets/image-20240108081422603.png)

![image-20240108081748161](考点.assets/image-20240108081748161.png)

![image-20240108081946791](考点.assets/image-20240108081946791.png)

## 代码生成

代码生成器的三个任务

- 指令选择：选择适当的指令实现IR语句
- 寄存器分配和指派：把哪个值放在哪个寄存器中
- 指令排序：按照什么顺序安排指令执行

![image-20240108085030455](考点.assets/image-20240108085030455.png)

**寄存器的使用方法**

- 执行运算时，**运算分量**必须放在寄存器中
- 存放**临时变量**
- 存放**全局的值**
- 进行运行时刻管理 (比如**栈顶指针**)

![image-20240108090710097](考点.assets/image-20240108090710097.png)

![image-20240108091052996](考点.assets/image-20240108091052996.png)

![image-20240108091122843](考点.assets/image-20240108091122843.png)

![image-20240108091204664](考点.assets/image-20240108091204664.png)

![image-20240108091700270](考点.assets/image-20240108091700270.png)

### getReg函数  

![image-20240108091832286](考点.assets/image-20240108091832286.png)

![image-20240108091851829](考点.assets/image-20240108091851829.png)

### 基本块的优化

基本块转换为DAG，对DAG进行优化

1. 局部公共子表达式

   - 建立某个结点 M 之前，检查是否存在一个结点 N，它和 M 具有相同的运算符和子结点 (顺序也相同)
   - 如果存在，则不需要生成新的结点，用 N 代表 M

2. 消除死代码

   - 去掉非活跃附加变量

3. 基于代数恒等式的优化

   - 除换乘，乘换加，次方换累乘

4. 数组引用表示

   ![image-20240108094504856](考点.assets/image-20240108094504856.png)

5. 指针赋值/过程调用

   - 指针赋值
     - 将一个指针在代码中某个位置上可能指向的变量限制在一个较小的子集中
   - 过程调用：假设
     - 使用了可访问范围内的所有变量
     - 修改了可访问范围内的所有变量

**DAG优化后重构基本块**

重构的方法

- 每个结点构造一个三地址语句，计算对应的值
- 结果应该尽量赋给一个活跃的变量
- 如果结点有多个关联的变量，则需要用赋值语句进行赋值

![image-20240108095428307](考点.assets/image-20240108095428307.png)

### 窥孔优化

使用一个滑动窗口 (窥孔) 来检查目标指令，在窥孔内实现优化

- 冗余指令消除
- 控制流优化
- 代数化简/强度消减
- 机器特有指令的使用窥孔优化（peephole optimization）

滑动窗口 (窥孔) 并无准确定义，可理解为只需关注少量相关指令即可完成的优化

![image-20240108100325235](考点.assets/image-20240108100325235.png)

![image-20240108100353669](考点.assets/image-20240108100353669.png)

![image-20240108100400261](考点.assets/image-20240108100400261.png)

### 目标指令选择

C表示相比于SP的偏移量，M表示存放在内存的变量，ind表示将运算分量当作内存地址处理

![image-20240108101311820](考点.assets/image-20240108101311820.png)

![image-20240108101321057](考点.assets/image-20240108101321057.png)

![image-20240108101741789](考点.assets/image-20240108101741789.png)

![image-20240108101812216](考点.assets/image-20240108101812216.png)

![image-20240108101834227](考点.assets/image-20240108101834227.png)

## 机器无关优化

**控制流图 (Control-Flow Graph)**  

![image-20240108102138568](考点.assets/image-20240108102138568.png)

### 保持语义不变的转换

![image-20240108102227454](考点.assets/image-20240108102227454.png)

![image-20240108102344683](考点.assets/image-20240108102344683.png)

![image-20240108102607669](考点.assets/image-20240108102607669.png)

![image-20240108103309088](考点.assets/image-20240108103309088.png)

![image-20240108103818628](考点.assets/image-20240108103818628.png)

![image-20240108103938923](考点.assets/image-20240108103938923.png)

![image-20240108104013102](考点.assets/image-20240108104013102.png)

### 数据流分析

![](考点.assets/image-20240108104710599.png)

![image-20240108104817986](考点.assets/image-20240108104817986.png)

![image-20240108104916198](考点.assets/image-20240108104916198.png)

![image-20240108105038946](考点.assets/image-20240108105038946.png)

![image-20240108105101731](考点.assets/image-20240108105101731.png)

![image-20240108105212587](考点.assets/image-20240108105212587.png)

![image-20240108105237781](考点.assets/image-20240108105237781.png)

![image-20240108105503073](考点.assets/image-20240108105503073.png)

![image-20240108105545438](考点.assets/image-20240108105545438.png)

![image-20240108105712123](考点.assets/image-20240108105712123.png)

![image-20240108105725767](考点.assets/image-20240108105725767.png)

![image-20240108105756957](考点.assets/image-20240108105756957.png)

![image-20240108105847386](考点.assets/image-20240108105847386.png)

![image-20240108110321447](考点.assets/image-20240108110321447.png)

![image-20240108110526920](考点.assets/image-20240108110526920.png)

![image-20240108111638034](考点.assets/image-20240108111638034.png)

![image-20240108111738802](考点.assets/image-20240108111738802.png)

![image-20240108111811730](考点.assets/image-20240108111811730.png)

![image-20240108111916440](考点.assets/image-20240108111916440.png)

![image-20240108112415027](考点.assets/image-20240108112415027.png)

### 流图中的循环

![image-20240108112528547](考点.assets/image-20240108112528547.png)

![image-20240108112701939](考点.assets/image-20240108112701939.png)

![image-20240108112803627](考点.assets/image-20240108112803627.png)

![image-20240108112855193](考点.assets/image-20240108112855193.png)

![image-20240108113137141](考点.assets/image-20240108113137141.png)

### 回边和可归约性  

![image-20240108113258996](考点.assets/image-20240108113258996.png)

![image-20240108113402725](考点.assets/image-20240108113402725.png)

![image-20240108113443267](考点.assets/image-20240108113443267.png)

![image-20240108113608671](考点.assets/image-20240108113608671.png)