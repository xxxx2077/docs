## 链表

### 删除链表的节点

[LCR 136. 删除链表的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/description/)

> 思路：添加哨兵节点方便插入和删除



```c++
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        ListNode* dummyNode = new ListNode();
        dummyNode->next = head;
        ListNode* cur = dummyNode;
        while(cur->next->val!=val){
            cur = cur->next;
        }
        cur->next = cur->next->next;
        return dummyNode->next;
    }
};
```



### 设计链表

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)



### 反转链表

> 思路：每两个节点之间的反转操作都是相同的，所以最先能够想到递归（自顶向下），对应自底向上的优化做法则为迭代，故有两种做法

#### 递归版

**总思路：**反转整个链表为总问题，自顶向下进行分解，则最后分解为：最末尾的两个节点进行反转，之后逐步向上重复步骤：每两个节点之间进行反转，最终即可得到反转链表

由上述思路即可得到：

- 递归边界：到达倒数第二个节点（保证有下一个节点）

  - 对应代码`if(!head->next)`

- 子问题：改变两个节点之间的指向（反转）

  - 具体实现：当前节点的子节点已经被反转

  - 对应代码：

    ```
    ListNode* nextNode = head->next;
    nextNode->next = head;
    head->next = nullptr;
    ```



```

```

